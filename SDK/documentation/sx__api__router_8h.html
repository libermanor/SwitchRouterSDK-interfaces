<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mellanox SwitchX SDK API Guide: sdk/sx_api_router.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mellanox SwitchX SDK API Guide
   &#160;<span id="projectnumber">4.4.2044-042</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_243a4ba6b4f893d71afbb5a3e90552fa.html">sdk</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sx_api_router.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="sx__api__router_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a34f17bf4bcc4feeac94a3dad937ac9ef"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a34f17bf4bcc4feeac94a3dad937ac9ef">sx_api_router_log_verbosity_level_set</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)</td></tr>
<tr class="separator:a34f17bf4bcc4feeac94a3dad937ac9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16054cd7f48ec56a42953a3b38dfd4b3"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a16054cd7f48ec56a42953a3b38dfd4b3">sx_api_router_log_verbosity_level_get</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)</td></tr>
<tr class="separator:a16054cd7f48ec56a42953a3b38dfd4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac828368205f9110cb12ce1efaa127e36"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#ac828368205f9110cb12ce1efaa127e36">sx_api_router_ecmp_hash_params_set</a> (const sx_api_handle_t handle, const sx_router_ecmp_hash_params_t *ecmp_hash_params_p)</td></tr>
<tr class="separator:ac828368205f9110cb12ce1efaa127e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745c179a22cc63568a0cc1fa3375cd35"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a745c179a22cc63568a0cc1fa3375cd35">sx_api_router_ecmp_port_hash_params_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_router_ecmp_port_hash_params_t *ecmp_hash_params_p, const sx_router_ecmp_hash_field_enable_t *hash_field_enable_list_p, const uint32_t hash_field_enable_list_cnt, const sx_router_ecmp_hash_field_t *hash_field_list_p, const uint32_t hash_field_list_cnt)</td></tr>
<tr class="separator:a745c179a22cc63568a0cc1fa3375cd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b800ec0358c5525688d2d430c409a6"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a24b800ec0358c5525688d2d430c409a6">sx_api_router_ecmp_hash_params_get</a> (const sx_api_handle_t handle, sx_router_ecmp_hash_params_t *ecmp_hash_params_p)</td></tr>
<tr class="separator:a24b800ec0358c5525688d2d430c409a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9240dce50ddf1d16f2fee274487bd107"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a9240dce50ddf1d16f2fee274487bd107">sx_api_router_ecmp_port_hash_params_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_router_ecmp_port_hash_params_t *ecmp_hash_params_p, sx_router_ecmp_hash_field_enable_t *hash_field_enable_list_p, uint32_t *hash_field_enable_list_cnt_p, sx_router_ecmp_hash_field_t *hash_field_list_p, uint32_t *hash_field_list_cnt_p)</td></tr>
<tr class="separator:a9240dce50ddf1d16f2fee274487bd107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef69aecaf04fa448db5bca24195b338"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a1ef69aecaf04fa448db5bca24195b338">sx_api_router_init_set</a> (const sx_api_handle_t handle, const sx_router_general_param_t *general_params_p, const sx_router_resources_param_t *router_resource_p)</td></tr>
<tr class="separator:a1ef69aecaf04fa448db5bca24195b338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1cae9d18872c0657706f776130f2cf"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a2e1cae9d18872c0657706f776130f2cf">sx_api_router_deinit_set</a> (const sx_api_handle_t handle)</td></tr>
<tr class="separator:a2e1cae9d18872c0657706f776130f2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc149f2962ae58006fe5d99c30f2170"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a2dc149f2962ae58006fe5d99c30f2170">sx_api_router_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_attributes_t *router_attr, sx_router_id_t *vrid)</td></tr>
<tr class="separator:a2dc149f2962ae58006fe5d99c30f2170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3deff6c205855116423b65854ddaff"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a2c3deff6c205855116423b65854ddaff">sx_api_router_get</a> (const sx_api_handle_t handle, const sx_router_id_t vrid, sx_router_attributes_t *router_attr)</td></tr>
<tr class="separator:a2c3deff6c205855116423b65854ddaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920b436f76d03c2b0c47ba4b48b05ac6"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a920b436f76d03c2b0c47ba4b48b05ac6">sx_api_router_vrid_iter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid_key, const sx_vrid_filter_t *vrid_filter_p, sx_router_id_t *vrid_list_p, uint32_t *vrid_cnt_p)</td></tr>
<tr class="separator:a920b436f76d03c2b0c47ba4b48b05ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75e9b0a9cb41809d2b7158ad9742e88"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#aa75e9b0a9cb41809d2b7158ad9742e88">sx_api_router_interface_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_router_interface_param_t *ifc_p, const sx_interface_attributes_t *ifc_attr_p, sx_router_interface_t *rif_p)</td></tr>
<tr class="separator:aa75e9b0a9cb41809d2b7158ad9742e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726222b37bb531286106877b469ee77d"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a726222b37bb531286106877b469ee77d">sx_api_router_interface_get</a> (const sx_api_handle_t handle, const sx_router_interface_t rif, sx_router_id_t *vrid_p, sx_router_interface_param_t *ifc_p, sx_interface_attributes_t *ifc_attr_p)</td></tr>
<tr class="separator:a726222b37bb531286106877b469ee77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e983db0a332579417b4d809c79e93c4"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a5e983db0a332579417b4d809c79e93c4">sx_api_router_interface_iter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_interface_t *rif_key_p, const sx_rif_filter_t *filter_p, sx_router_interface_t *rif_list_p, uint32_t *rif_cnt_p)</td></tr>
<tr class="separator:a5e983db0a332579417b4d809c79e93c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7036a60c1a30149df0849edcf4b1cf"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a8e7036a60c1a30149df0849edcf4b1cf">sx_api_router_interface_state_set</a> (const sx_api_handle_t handle, const sx_router_interface_t rif, const sx_router_interface_state_t *rif_state_p)</td></tr>
<tr class="separator:a8e7036a60c1a30149df0849edcf4b1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca9be4809b7930481b23d13b62260c4"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#afca9be4809b7930481b23d13b62260c4">sx_api_router_interface_state_get</a> (const sx_api_handle_t handle, const sx_router_interface_t rif, sx_router_interface_state_t *rif_state_p)</td></tr>
<tr class="separator:afca9be4809b7930481b23d13b62260c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fa8aa8bb1a944fc76388b380d32e48"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a45fa8aa8bb1a944fc76388b380d32e48">sx_api_router_interface_mac_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_interface_t rif, const sx_mac_addr_t *mac_addr_list_p, const uint32_t mac_addr_cnt)</td></tr>
<tr class="separator:a45fa8aa8bb1a944fc76388b380d32e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfa5bcd99c9b86516cdbf088bbc4270"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a6cfa5bcd99c9b86516cdbf088bbc4270">sx_api_router_interface_mac_get</a> (const sx_api_handle_t handle, const sx_router_interface_t rif, sx_mac_addr_t *mac_addr_list_p, uint32_t *mac_addr_cnt_p)</td></tr>
<tr class="separator:a6cfa5bcd99c9b86516cdbf088bbc4270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717aefbc20f4378e82b1114943384025"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a717aefbc20f4378e82b1114943384025">sx_api_router_neigh_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_interface_t rif, const sx_ip_addr_t *ip_addr_p, const sx_neigh_data_t *neigh_data_p)</td></tr>
<tr class="separator:a717aefbc20f4378e82b1114943384025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418c04f432cd961383aaddf3f5de01ad"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a418c04f432cd961383aaddf3f5de01ad">sx_api_router_neigh_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_interface_t rif, const sx_ip_addr_t *neigh_key_p, const sx_neigh_filter_t *filter_p, sx_neigh_get_entry_t *neigh_entry_list_p, uint32_t *neigh_entry_cnt_p)</td></tr>
<tr class="separator:a418c04f432cd961383aaddf3f5de01ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9f7e35f14c64b05c3aa179d40f4d35"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#acf9f7e35f14c64b05c3aa179d40f4d35">sx_api_router_neigh_activity_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_interface_t rif, const sx_ip_addr_t *ip_addr_p, boolean_t *activity_p)</td></tr>
<tr class="separator:acf9f7e35f14c64b05c3aa179d40f4d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567fd03de370a075336735995e17e77b"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a567fd03de370a075336735995e17e77b">sx_api_router_uc_route_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_ip_prefix_t *network_addr, sx_uc_route_data_t *uc_route_data_p)</td></tr>
<tr class="separator:a567fd03de370a075336735995e17e77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7840f0e1e453e677668b9f652c66fc"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a7e7840f0e1e453e677668b9f652c66fc">sx_api_router_uc_route_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_ip_prefix_t *network_addr, sx_uc_route_key_filter_t *filter_p, sx_uc_route_get_entry_t *uc_route_get_entries_list_p, uint32_t *uc_route_get_entries_cnt_p)</td></tr>
<tr class="separator:a7e7840f0e1e453e677668b9f652c66fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059c220b2a25fb94729c83688e7f8ff0"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a059c220b2a25fb94729c83688e7f8ff0">sx_api_router_uc_route_operational_ecmp_get</a> (const sx_api_handle_t handle, const sx_router_id_t vrid, const sx_ip_prefix_t *network_addr_p, sx_uc_route_get_entry_t *oper_uc_route_entries_p)</td></tr>
<tr class="separator:a059c220b2a25fb94729c83688e7f8ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada19ea02653d8cea4a46b48752f524a1"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#ada19ea02653d8cea4a46b48752f524a1">sx_api_router_uc_route_counter_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_ip_prefix_t *network_addr_p, const sx_flow_counter_id_t counter_id)</td></tr>
<tr class="separator:ada19ea02653d8cea4a46b48752f524a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9e8525ebab84f8c49bff8d59f0eb59"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a8d9e8525ebab84f8c49bff8d59f0eb59">sx_api_router_uc_route_counter_bind_get</a> (const sx_api_handle_t handle, const sx_router_id_t vrid, const sx_ip_prefix_t *network_addr_p, sx_flow_counter_id_t *counter_id_p)</td></tr>
<tr class="separator:a8d9e8525ebab84f8c49bff8d59f0eb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472c9bb573ce5a76a04f14cd53346b6f"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a472c9bb573ce5a76a04f14cd53346b6f">sx_api_router_counter_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_router_counter_id_t *counter_p)</td></tr>
<tr class="separator:a472c9bb573ce5a76a04f14cd53346b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e73f38b6a51b7090c5c775c96689dfd"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a0e73f38b6a51b7090c5c775c96689dfd">sx_api_router_counter_extended_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_counter_attributes_t cntr_attributes, sx_router_counter_id_t *counter_p)</td></tr>
<tr class="separator:a0e73f38b6a51b7090c5c775c96689dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f2d9f69205e6835bd4290703106121"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a71f2d9f69205e6835bd4290703106121">sx_api_router_interface_counter_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_counter_id_t counter, const sx_router_interface_t rif)</td></tr>
<tr class="separator:a71f2d9f69205e6835bd4290703106121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81e1f46c5501aee769e56e4fa4ebf23"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#aa81e1f46c5501aee769e56e4fa4ebf23">sx_api_router_interface_counter_bind_get</a> (const sx_api_handle_t handle, const sx_router_counter_id_t counter, sx_router_interface_t *rif_p)</td></tr>
<tr class="separator:aa81e1f46c5501aee769e56e4fa4ebf23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c18223f082f72efeb16ef6ab4545c6"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#ab4c18223f082f72efeb16ef6ab4545c6">sx_api_router_counter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_counter_id_t counter, sx_router_counter_set_t *counter_set_p)</td></tr>
<tr class="separator:ab4c18223f082f72efeb16ef6ab4545c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b43b5655884e760afefdfd3f3910ea4"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a1b43b5655884e760afefdfd3f3910ea4">sx_api_router_counter_extended_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_counter_id_t counter_id, sx_router_counter_set_extended_t *counter_data_p)</td></tr>
<tr class="separator:a1b43b5655884e760afefdfd3f3910ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3d7ede0cc2b4a383aacf414c9d84a3"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a1c3d7ede0cc2b4a383aacf414c9d84a3">sx_api_router_counter_clear_set</a> (const sx_api_handle_t handle, const sx_router_counter_id_t counter, const boolean_t all)</td></tr>
<tr class="separator:a1c3d7ede0cc2b4a383aacf414c9d84a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d28b1cf1ea8606acaecf5c01c31051"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a88d28b1cf1ea8606acaecf5c01c31051">sx_api_router_mc_route_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, const sx_mc_route_attributes_t *mc_route_attr_p, const sx_mc_route_data_t *mc_route_data_p)</td></tr>
<tr class="separator:a88d28b1cf1ea8606acaecf5c01c31051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a37e74c648d6bd3de469df8cbd5b8c"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a24a37e74c648d6bd3de469df8cbd5b8c">sx_api_router_mc_route_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, sx_mc_route_key_filter_t *filter_p, sx_mc_route_get_entry_t *mc_route_get_entries_list_p, uint32_t *mc_route_get_entries_cnt_p)</td></tr>
<tr class="separator:a24a37e74c648d6bd3de469df8cbd5b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70bf9ca856f55a88e7dd5a4fe5f77fa"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#ab70bf9ca856f55a88e7dd5a4fe5f77fa">sx_api_router_mc_route_activity_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, boolean_t *activity_p)</td></tr>
<tr class="separator:ab70bf9ca856f55a88e7dd5a4fe5f77fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209bcda3949dca1c76a5e18aa6705255"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a209bcda3949dca1c76a5e18aa6705255">sx_api_router_mc_route_activity_notify</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_mc_route_activity_notify_filter_t *filter_p)</td></tr>
<tr class="separator:a209bcda3949dca1c76a5e18aa6705255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d704b1d7e401edc59dde5aff4bf376"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a49d704b1d7e401edc59dde5aff4bf376">sx_api_router_mc_egress_rif_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, const sx_router_interface_t *egress_rif_list_p, const uint32_t egress_rif_cnt)</td></tr>
<tr class="separator:a49d704b1d7e401edc59dde5aff4bf376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530c3fdb5083d5c3a8f8e74ee348da69"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a530c3fdb5083d5c3a8f8e74ee348da69">sx_api_router_mc_egress_rif_get</a> (const sx_api_handle_t handle, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, sx_router_interface_t *egress_rif_list_p, uint32_t *egress_rif_cnt)</td></tr>
<tr class="separator:a530c3fdb5083d5c3a8f8e74ee348da69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8dbefb60e445f59551a682a9177faa4"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#ad8dbefb60e445f59551a682a9177faa4">sx_api_router_cos_rewrite_pcpdei_enable_set</a> (const sx_api_handle_t handle, const sx_cos_pcp_dei_rewrite_e rewrite_pcp_dei)</td></tr>
<tr class="separator:ad8dbefb60e445f59551a682a9177faa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263b0c24b5930c791a6691a473934ee8"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a263b0c24b5930c791a6691a473934ee8">sx_api_router_cos_rewrite_pcpdei_enable_get</a> (const sx_api_handle_t handle, sx_cos_pcp_dei_rewrite_e *rewrite_pcp_dei_p)</td></tr>
<tr class="separator:a263b0c24b5930c791a6691a473934ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d98abb2561504116bda54e5e7a1647c"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a8d98abb2561504116bda54e5e7a1647c">sx_api_router_cos_prio_update_enable_set</a> (const sx_api_handle_t handle, const boolean_t update_priority_color)</td></tr>
<tr class="separator:a8d98abb2561504116bda54e5e7a1647c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bd7e45636b6128e1add0ad579b2f86"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#aa1bd7e45636b6128e1add0ad579b2f86">sx_api_router_cos_prio_update_enable_get</a> (const sx_api_handle_t handle, boolean_t *update_priority_color_p)</td></tr>
<tr class="separator:aa1bd7e45636b6128e1add0ad579b2f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3601a683f22a7e13bc89b3f80a4a3c0e"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a3601a683f22a7e13bc89b3f80a4a3c0e">sx_api_router_cos_dscp_to_prio_set</a> (const sx_api_handle_t handle, const sx_cos_dscp_t *dscp_p, const sx_cos_priority_color_t *priority_color_p, const uint32_t element_cnt)</td></tr>
<tr class="separator:a3601a683f22a7e13bc89b3f80a4a3c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dffe9f627debece49b7ed508c12bf0b"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a3dffe9f627debece49b7ed508c12bf0b">sx_api_router_cos_dscp_to_prio_get</a> (const sx_api_handle_t handle, sx_cos_dscp_t *dscp_p, sx_cos_priority_color_t *priority_color_p, uint32_t *element_cnt_p)</td></tr>
<tr class="separator:a3dffe9f627debece49b7ed508c12bf0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1c22691400cdcd80424831ff6bc942"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#abd1c22691400cdcd80424831ff6bc942">sx_api_router_ecmp_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_ecmp_id_t *ecmp_id_p, sx_next_hop_t *next_hop_list_p, uint32_t *next_hop_cnt_p)</td></tr>
<tr class="separator:abd1c22691400cdcd80424831ff6bc942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c569920c238a3289dc3877a5c10783e"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a7c569920c238a3289dc3877a5c10783e">sx_api_router_ecmp_get</a> (const sx_api_handle_t handle, const sx_ecmp_id_t ecmp_id, sx_next_hop_t *next_hop_list_p, uint32_t *next_hop_cnt_p)</td></tr>
<tr class="separator:a7c569920c238a3289dc3877a5c10783e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866dedd655aa7313be54227fe54ec57e"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a866dedd655aa7313be54227fe54ec57e">sx_api_router_ecmp_iter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_ecmp_id_t ecmp_id, const sx_ecmp_filter_t *filter_p, sx_ecmp_id_t *ecmp_list_p, uint32_t *ecmp_cnt_p)</td></tr>
<tr class="separator:a866dedd655aa7313be54227fe54ec57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c2973c659f035cbde4f0a519b1082b"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a44c2973c659f035cbde4f0a519b1082b">sx_api_router_operational_ecmp_get</a> (const sx_api_handle_t handle, const sx_ecmp_id_t ecmp_id, sx_next_hop_t *next_hop_list_p, uint32_t *next_hop_cnt_p)</td></tr>
<tr class="separator:a44c2973c659f035cbde4f0a519b1082b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa9c0bda0299d13e275a267c1249fb8"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a2aa9c0bda0299d13e275a267c1249fb8">sx_api_router_ecmp_counter_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_ecmp_id_t ecmp_id, const sx_flow_counter_id_t *counter_id_list_p, const uint32_t *offset_list_p, const uint32_t elements_cnt)</td></tr>
<tr class="separator:a2aa9c0bda0299d13e275a267c1249fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa0de25ef37a9cef1652e920c5fc019"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a2fa0de25ef37a9cef1652e920c5fc019">sx_api_router_ecmp_fine_grain_counter_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_ecmp_id_t ecmp_id, const sx_flow_counter_id_t counter_id, const uint32_t *offset_list_p, const uint32_t elements_cnt)</td></tr>
<tr class="separator:a2fa0de25ef37a9cef1652e920c5fc019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823465cf10115d18b458c33a678cfccf"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a823465cf10115d18b458c33a678cfccf">sx_api_router_neigh_activity_notify</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_neigh_activity_filter_t *filter_p)</td></tr>
<tr class="separator:a823465cf10115d18b458c33a678cfccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242f69b150debcf00867d67f8515e8a6"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a242f69b150debcf00867d67f8515e8a6">sx_api_router_ecmp_attributes_set</a> (const sx_api_handle_t handle, const sx_ecmp_id_t ecmp_id, const sx_ecmp_attributes_t *attr_p)</td></tr>
<tr class="separator:a242f69b150debcf00867d67f8515e8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa58f3a820da481643de557c94a401ea"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#afa58f3a820da481643de557c94a401ea">sx_api_router_ecmp_attributes_get</a> (const sx_api_handle_t handle, const sx_ecmp_id_t ecmp_id, sx_ecmp_attributes_t *attr_p)</td></tr>
<tr class="separator:afa58f3a820da481643de557c94a401ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1936f4c977dfe4c92e31af4ba9390845"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a1936f4c977dfe4c92e31af4ba9390845">sx_api_router_ecmp_clone_set</a> (const sx_api_handle_t handle, const sx_ecmp_id_t old_ecmp_id, sx_ecmp_id_t *new_ecmp_id_p)</td></tr>
<tr class="separator:a1936f4c977dfe4c92e31af4ba9390845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa529787aa5b258a80c567f751dbfe2ee"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#aa529787aa5b258a80c567f751dbfe2ee">sx_api_router_mc_rpf_group_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_rpf_group_id_t *rpf_group_id_p, sx_router_vinterface_t *rpf_vif_list_p, uint32_t rpf_vif_cnt)</td></tr>
<tr class="separator:aa529787aa5b258a80c567f751dbfe2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae922af870268cc2ccf178169027ac093"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#ae922af870268cc2ccf178169027ac093">sx_api_router_mc_rpf_group_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_rpf_group_id_t *rpf_group_id_p, sx_router_vinterface_t *rpf_vif_list_p, uint32_t *rpf_vif_cnt_p)</td></tr>
<tr class="separator:ae922af870268cc2ccf178169027ac093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4327a03b23e683f531b359fa569ecf"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a6a4327a03b23e683f531b359fa569ecf">sx_api_router_mc_route_counter_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, const sx_flow_counter_id_t counter_id)</td></tr>
<tr class="separator:a6a4327a03b23e683f531b359fa569ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450a42c80363d8802247f85c77fae63d"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a450a42c80363d8802247f85c77fae63d">sx_api_router_mc_route_counter_bind_get</a> (const sx_api_handle_t handle, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, sx_flow_counter_id_t *counter_id_p)</td></tr>
<tr class="separator:a450a42c80363d8802247f85c77fae63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7c89711216cab09b505dc134c03fd3"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#aed7c89711216cab09b505dc134c03fd3">sx_api_router_ecmp_redirect_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_ecmp_id_t ecmp, const sx_ecmp_id_t redirect_ecmp)</td></tr>
<tr class="separator:aed7c89711216cab09b505dc134c03fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac706ced1172271936ca0ec91f1f1fd13"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#ac706ced1172271936ca0ec91f1f1fd13">sx_api_router_ecmp_redirect_get</a> (const sx_api_handle_t handle, const sx_ecmp_id_t ecmp, boolean_t *is_redirected_p, sx_ecmp_id_t *redirected_ecmp_p)</td></tr>
<tr class="separator:ac706ced1172271936ca0ec91f1f1fd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5868a7290cad14c7af06cb86fb48b6"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a5b5868a7290cad14c7af06cb86fb48b6">sx_api_router_req_completion_info_get</a> (const sx_api_handle_t handle, sx_router_req_completion_info_get_entry_t *completion_info_p)</td></tr>
<tr class="separator:a5b5868a7290cad14c7af06cb86fb48b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a34f17bf4bcc4feeac94a3dad937ac9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f17bf4bcc4feeac94a3dad937ac9ef">&#9670;&nbsp;</a></span>sx_api_router_log_verbosity_level_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_log_verbosity_level_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>module_verbosity_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>api_verbosity_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API sets the log verbosity level of ROUTER MODULE. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- set verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module_verbosity_level</td><td>- ROUTER module verbosity level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">api_verbosity_level</td><td>- ROUTER API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a16054cd7f48ec56a42953a3b38dfd4b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16054cd7f48ec56a42953a3b38dfd4b3">&#9670;&nbsp;</a></span>sx_api_router_log_verbosity_level_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_log_verbosity_level_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>module_verbosity_level_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>api_verbosity_level_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API gets the log verbosity level of ROUTER MODULE. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- get verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">module_verbosity_level_p</td><td>- ROUTER module verbosity level </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">api_verbosity_level_p</td><td>- ROUTER API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="ac828368205f9110cb12ce1efaa127e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac828368205f9110cb12ce1efaa127e36">&#9670;&nbsp;</a></span>sx_api_router_ecmp_hash_params_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_hash_params_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_ecmp_hash_params_t *&#160;</td>
          <td class="paramname"><em>ecmp_hash_params_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the ECMP hash configuration parameters. If ecmp_hash_params_p-&gt;symmetric_hash is TRUE, then hash(*,A) = hash(A,*) This API will return error once the per port API sx_api_router_ecmp_port_hash_params_set has been called. This API cannot be used along with sx_api_router_ecmp_port_hash_params_set. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ecmp_hash_param_p</td><td>- ECMP hash configuration parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a745c179a22cc63568a0cc1fa3375cd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745c179a22cc63568a0cc1fa3375cd35">&#9670;&nbsp;</a></span>sx_api_router_ecmp_port_hash_params_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_port_hash_params_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_ecmp_port_hash_params_t *&#160;</td>
          <td class="paramname"><em>ecmp_hash_params_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_ecmp_hash_field_enable_t *&#160;</td>
          <td class="paramname"><em>hash_field_enable_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>hash_field_enable_list_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_ecmp_hash_field_t *&#160;</td>
          <td class="paramname"><em>hash_field_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>hash_field_list_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the ECMP hash function configuration parameters on a per port basis.</p>
<p>Each element in hash_field_enable_list_p enables a specific layer field to be included in the hash calculation according to the de-facto fields of the parsed packet. Each element in hash_field_list_p represents a different field to be included in the hash calculation, subject to the enables which are given in hash_field_enable_list_p.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SET/ ADD/ DELETE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- log port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ecmp_hash_params_p</td><td>- ECMP hash configuration parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_field_enable_list_p</td><td>- Array of enables to be included in the hash calculation (may be NULL if empty) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_field_enable_list_cnt</td><td>- Number of elements in hash_field_enable_list_p </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_field_list_p</td><td>- Array of fields to be included in the hash calculation (may be NULL if empty) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_field_list_cnt</td><td>- Number of elements in hash_field_list_p</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is incorrectly NULL. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a24b800ec0358c5525688d2d430c409a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b800ec0358c5525688d2d430c409a6">&#9670;&nbsp;</a></span>sx_api_router_ecmp_hash_params_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_hash_params_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_ecmp_hash_params_t *&#160;</td>
          <td class="paramname"><em>ecmp_hash_params_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets the ECMP hash function configuration parameters. This API is disabled once sx_api_router_ecmp_port_hash_params_set is called. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ecmp_hash_params_p</td><td>- ECMP hash configuration parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a9240dce50ddf1d16f2fee274487bd107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9240dce50ddf1d16f2fee274487bd107">&#9670;&nbsp;</a></span>sx_api_router_ecmp_port_hash_params_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_port_hash_params_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_ecmp_port_hash_params_t *&#160;</td>
          <td class="paramname"><em>ecmp_hash_params_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_ecmp_hash_field_enable_t *&#160;</td>
          <td class="paramname"><em>hash_field_enable_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>hash_field_enable_list_cnt_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_ecmp_hash_field_t *&#160;</td>
          <td class="paramname"><em>hash_field_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>hash_field_list_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets the ECMP hash function configuration parameters. if the given number of fields / fields enables is 0, the API will only return number of fields / enables.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- local port </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ecmp_hash_params_p</td><td>- ECMP hash configuration parameters. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hash_field_enable_list_p</td><td>- array of enables used in the hash calculation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>hash_field_enable_list_cnt_p - number of objects in hash_field_list_p </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hash_field_list_p</td><td>- array of fields used in the hash calculation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>hash_field_list_cnt_p - number of objects in hash_field_list_p</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a1ef69aecaf04fa448db5bca24195b338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef69aecaf04fa448db5bca24195b338">&#9670;&nbsp;</a></span>sx_api_router_init_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_init_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_general_param_t *&#160;</td>
          <td class="paramname"><em>general_params_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_resources_param_t *&#160;</td>
          <td class="paramname"><em>router_resource_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function Initiates the router module in SDK. The parameter uc_params-&gt;ipv4_num requires a value larger than 30. The parameter mc_params-&gt;mc_routes-&gt;ipv4_num requires a value larger than 30 when the mc_router is enabled.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">general_params_p</td><td>- general router parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">router_resource_p-</td><td>router resource parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS - if operation completes successfully. </dd>
<dd>
SX_STATUS_ALREADY_INITIALIZED - When router is already initialized. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE - When calling with bad parameters. </dd></dl>

</div>
</div>
<a id="a2e1cae9d18872c0657706f776130f2cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1cae9d18872c0657706f776130f2cf">&#9670;&nbsp;</a></span>sx_api_router_deinit_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_deinit_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This api deinitializes the router block in the sdk. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE When router is still active. </dd></dl>

</div>
</div>
<a id="a2dc149f2962ae58006fe5d99c30f2170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc149f2962ae58006fe5d99c30f2170">&#9670;&nbsp;</a></span>sx_api_router_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_attributes_t *&#160;</td>
          <td class="paramname"><em>router_attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_id_t *&#160;</td>
          <td class="paramname"><em>vrid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds/deletes/edits a virtual router. The router ID is allocated and returned to the caller when cmd is ADD, otherwise it is given by the caller. All interfaces and routes associated with a router must be deleted before the router can be deleted as well.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE/EDIT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">router_attr</td><td>- Router attributes. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vrid</td><td>- Virtual router ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if router was not added. </dd>
<dd>
SX_STATUS_NO_RESOURCES if there are no resources to create another router </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if router has interfaces or routes. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a2c3deff6c205855116423b65854ddaff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3deff6c205855116423b65854ddaff">&#9670;&nbsp;</a></span>sx_api_router_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_attributes_t *&#160;</td>
          <td class="paramname"><em>router_attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets a virtual router information. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">router_attr</td><td>- Router attributes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if router was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a920b436f76d03c2b0c47ba4b48b05ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920b436f76d03c2b0c47ba4b48b05ac6">&#9670;&nbsp;</a></span>sx_api_router_vrid_iter_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_vrid_iter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vrid_filter_t *&#160;</td>
          <td class="paramname"><em>vrid_filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_id_t *&#160;</td>
          <td class="paramname"><em>vrid_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>vrid_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets a list of valid VRIDs. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>GET/GET_NEXT/GET_FIRST </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid_key</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid_filter_p</td><td>- Filter to use (not supported yet) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vrid_list_p</td><td>- pointer to the list of valid VRIDs returned. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vrid_cnt_p</td><td>[in] number of entries to retrieve (max: 254).; [out] retrieved number of entries.</td></tr>
  </table>
  </dd>
</dl>
<p>Input/Output types</p><ul>
<li>Get first - Get a list of first n entries. Cmd should be SX_ACCESS_CMD_GET_FIRST and vrid_cnt_p should be equal to n. key is irrelevant in this case. This cmd returns the number of entries retrieved as vrid_cnt_p</li>
<li>Get next - Get n entries after a specified vrid (vrid can be non-existent). Cmd should be SX_ACCESS_CMD_GETNEXT and vrid_cnt_p should be equal to n. This cmd returns number of entries retrieved as vrid_cnt_p</li>
<li>Get - Gets a specific entry. Cmd should be SX_ACCESS_CMD_GET and vrid_cnt_p should be 1. If the input vrid_cnt_p is 0, then this API returns a count of valid VRIDs as output.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_INVALID_HANDLE if handle in invalid </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="aa75e9b0a9cb41809d2b7158ad9742e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75e9b0a9cb41809d2b7158ad9742e88">&#9670;&nbsp;</a></span>sx_api_router_interface_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_param_t *&#160;</td>
          <td class="paramname"><em>ifc_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_interface_attributes_t *&#160;</td>
          <td class="paramname"><em>ifc_attr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_interface_t *&#160;</td>
          <td class="paramname"><em>rif_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds/modifies/deletes/delete_all a router interface. A router interface is associated with L2 interface. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<p>In 802.1D mode, if ifc_p needs to be configured as type=SX_L2_INTERFACE_TYPE_VLAN, then bridge_id needs to be provided instead of ifc.vlan.vlan.</p>
<p>On Spectrum/Spectrum2/Spectrum3 with command EDIT:</p><ul>
<li>The only applicable RIF type that can be edited in ifc_p is SX_L2_INTERFACE_TYPE_PORT_VLAN and the only field that can be edited for the RIF type is the vlan field.</li>
<li>The only applicable fields in ifc_attr_p are mtu, multicast_ttl_threshold and loopback_enable. Other fields shall not be edited.</li>
</ul>
<p>On Spectrum/Spectrum2/Spectrum3 with command DELETE/DELETE_ALL:</p><ul>
<li>All MACs assigned to a specific interface/interfaces will be deleted. This includes MACs configured by <a class="el" href="sx__api__router_8h.html#a45fa8aa8bb1a944fc76388b380d32e48">sx_api_router_interface_mac_set()</a></li>
</ul>
<p>On Spectrum/Spectrum2/Spectrum3 the mac field in ifc_attr_p, is made from 38 bits of common base that is fixed and only the last 10 bits varies from one rif to another</p>
<p>On Spectrum/Spectrum2/Spectrum3 the qos_mode field in ifc_attr_p is redundant, the global router qos configuration shall be used instead. The rif must be aligned with the router global qos mode,that is configured using sx_api_router_cos_prio_update_enable_set, otherwise SX_ROUTER_QOS_MODE_NOP shall be set to use the router global configured qos mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/EDIT/DELETE/DELETE ALL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ifc_p</td><td>- Interface type and parameters . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ifc_attr_p</td><td>-Interface attributes. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rif</td><td>- Router Interface ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if router interface was not added. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no interface is available to create. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if router interface has routes. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a726222b37bb531286106877b469ee77d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726222b37bb531286106877b469ee77d">&#9670;&nbsp;</a></span>sx_api_router_interface_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t&#160;</td>
          <td class="paramname"><em>rif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_id_t *&#160;</td>
          <td class="paramname"><em>vrid_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_interface_param_t *&#160;</td>
          <td class="paramname"><em>ifc_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_interface_attributes_t *&#160;</td>
          <td class="paramname"><em>ifc_attr_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets a router interface information. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<p>When in 802.1D mode, if ifc_p has type SX_L2_INTERFACE_TYPE_VLAN, then a bridge ID is returned instead of vlan ID in ifc.vlan.vlan.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif</td><td>- Router Interface ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vrid_p</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ifc_p</td><td>- Interface type and parameters . </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ifc_attr_p</td><td>-Interface attributes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if router interface was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a5e983db0a332579417b4d809c79e93c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e983db0a332579417b4d809c79e93c4">&#9670;&nbsp;</a></span>sx_api_router_interface_iter_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_iter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t *&#160;</td>
          <td class="paramname"><em>rif_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_rif_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_interface_t *&#160;</td>
          <td class="paramname"><em>rif_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rif_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns a list of one or more router interface identifiers. The following use case scenarios apply with different input parameters X = don't-care</p><ul>
<li>1) cmd = SX_ACCESS_CMD_GET, key = X, Filter = X, Rif_list = X, Count=0: In this case the API will return the total number of RIFs in the Internal db</li>
<li>2) cmd = SX_ACCESS_CMD_GET, key = valid/invalid, Filter = X, Rif_list = Valid, Count = 1: In this case the API will check if the specified key exists. if it does the key will be returned in the rif_list along with a count of 1. If the key does not exist an empty list will be returned with count = 0</li>
<li>3) cmd = SX_ACCESS_CMD_GET, key = valid, Filter = Valid, Rif_list is Valid, Count=1: In this case the API will check if the specified key exists. if it does exist then, it will check it against the filter parameter. If the filter matches, then the key will be returned in the rif_list along with a count of 1. If the key does not exist or the filter does not match an empty list will be returned with count = 0</li>
<li>4) cmd = SX_ACCESS_CMD_GET, key = valid, Filter = Valid/invalid, Rif_list is Valid, Count &gt; 1: A count &gt;1 will be treated as a count of 1 and the behavior will be same as earlier GET use cases.</li>
<li>5) cmd = SX_ACCESS_CMD_GET_FIRST/SX_ACCESS_CMD_GETNEXT, key = X, Filter = X, Rif_list = Null, Count =0: For either SX_ACCESS_CMD_GET_FIRST/SX_ACCESS_CMD_GETNEXT a zero count will return an empty list.</li>
<li>6) cmd = SX_ACCESS_CMD_GET_FIRST, key = X, Filter = valid/invalid, Rif_list = Valid, Count &gt; 0: In this case the API will return the first count rifs starting from the head of the database. The total elements fetched will be returned as the return count. Note: return count may be less than or equal to the requested count. The key is dont-care. If a filter is specified only those rifs that match the filter will be returned. A non-Null return rif_list pointer must be provided</li>
<li>7) cmd = SX_ACCESS_CMD_GETNEXT, key = valid/invalid, Filter = valid/invalid, Rif_list = Valid, Count &gt; 0: In this case the API will return the next set of rifs starting from the next valid rif after the specified key. The total elements fetched will be returned as the return count. If a filter is specified, then only those rifs that match the filter will be returned. Note: return count may be less than or equal to the requested count. If no valid next rif exists in the db (key = end of list, or invalid key specified, or key too large), an empty list will be returned.</li>
</ul>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>: SX API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>: GET/GET_FIRST/GET_NEXT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif_key_p</td><td>: specify a rif key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>: specify a filter parameter </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rif_list_p</td><td>: return list of rif ids </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rif_cnt_p</td><td>: [in] number of rifs to get. max 400 : [out] number of rifs returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if an unexpected NULL parameter was passed. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ERROR general error. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED - if invalid cmd is passed </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED - if router module is uninitialized </dd>
<dd>
SX_STATUS_CMD_ERROR - if internal RPC mechanism to SDK server fails </dd>
<dd>
SX_STATUS_DB_NOT_INITIALIZED - if internal RIF DB is not initialized </dd></dl>

</div>
</div>
<a id="a8e7036a60c1a30149df0849edcf4b1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7036a60c1a30149df0849edcf4b1cf">&#9670;&nbsp;</a></span>sx_api_router_interface_state_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_state_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t&#160;</td>
          <td class="paramname"><em>rif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_state_t *&#160;</td>
          <td class="paramname"><em>rif_state_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets admin state of a router interface. Admin state is set per IP protocol. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif</td><td>- Router Interface ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif_state_p</td><td>- Admin state for unicast routing and multicast routing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if router interface was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="afca9be4809b7930481b23d13b62260c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca9be4809b7930481b23d13b62260c4">&#9670;&nbsp;</a></span>sx_api_router_interface_state_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_state_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t&#160;</td>
          <td class="paramname"><em>rif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_interface_state_t *&#160;</td>
          <td class="paramname"><em>rif_state_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets admin state of a router interface. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif</td><td>- Router Interface ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif_state_p</td><td>- Admin state for unicast routing and multicast routing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if router interface was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a45fa8aa8bb1a944fc76388b380d32e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45fa8aa8bb1a944fc76388b380d32e48">&#9670;&nbsp;</a></span>sx_api_router_interface_mac_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_mac_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t&#160;</td>
          <td class="paramname"><em>rif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mac_addr_t *&#160;</td>
          <td class="paramname"><em>mac_addr_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mac_addr_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds/deletes a MAC address from a router interface. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE/DELETE_ALL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif</td><td>- Router Interface ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mac_addr_list_p</td><td>- MAC addresses array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mac_addr_cnt</td><td>- MAC addresses array size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if router interface was not added. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a6cfa5bcd99c9b86516cdbf088bbc4270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cfa5bcd99c9b86516cdbf088bbc4270">&#9670;&nbsp;</a></span>sx_api_router_interface_mac_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_mac_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t&#160;</td>
          <td class="paramname"><em>rif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_mac_addr_t *&#160;</td>
          <td class="paramname"><em>mac_addr_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>mac_addr_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets MAC address of a router interface. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif</td><td>- Router Interface ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mac_addr_list_p</td><td>- MAC addresses array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mac_addr_cnt_p</td><td>- MAC addresses array size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if router interface was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a717aefbc20f4378e82b1114943384025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717aefbc20f4378e82b1114943384025">&#9670;&nbsp;</a></span>sx_api_router_neigh_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_neigh_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t&#160;</td>
          <td class="paramname"><em>rif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ip_addr_t *&#160;</td>
          <td class="paramname"><em>ip_addr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_neigh_data_t *&#160;</td>
          <td class="paramname"><em>neigh_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds/deletes/delete_all a neighbor information. The neighbor's information associates an IP address to a MAC address. The neighbor's IP addresses are learned via ARP/ND discovery at the control protocol layer. The interface that the neighbors are associated is derived from the IP interface configuration.</p>
<p>When cmd = DELETE_ALL, all neighbors which match the ip_addr_p-&gt;version and the rif, will be deleted. In case rif is rm_resource_global.router_rifs_dontcare, all neighbors, on all rifs, corresponding with the ip_addr_p-&gt;version will be deleted. If ip_addr_p-&gt;version = SX_IP_VERSION_NONE then only IPv4 neighbors will be deleted.</p>
<p>In case the action is SX_ROUTER_ACTION_TRAP_FORWARD/SX_ROUTER_ACTION_TRAP, then trap ID will be set to SXD_TRAP_ID_RTR_EGRESS0 if trap priority is BEST EFFORT, LOW or MED, or to SXD_TRAP_ID_RTR_EGRESS1 for other priorities.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE/DELETE_ALL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif</td><td>- Router Interface Id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ip_addr_p</td><td>- IP address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neigh_data_p</td><td>- Neighbors information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>In neigh_data_p, rif is deprecated and will be removed in the future.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if neighbor was not added. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no neighbor entry is available to create. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a418c04f432cd961383aaddf3f5de01ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418c04f432cd961383aaddf3f5de01ad">&#9670;&nbsp;</a></span>sx_api_router_neigh_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_neigh_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t&#160;</td>
          <td class="paramname"><em>rif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ip_addr_t *&#160;</td>
          <td class="paramname"><em>neigh_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_neigh_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_neigh_get_entry_t *&#160;</td>
          <td class="paramname"><em>neigh_entry_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>neigh_entry_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets the neighbor's information.</p>
<p>The function can receive three types of input:</p>
<ul>
<li>1) cmd SX_ACCESS_CMD_GET, gets the neighbor whose RIF and IP address match those given in rif and ip_addr_p. neigh_entry_cnt_p should be equal to 1.</li>
<li>2) cmd SX_ACCESS_CMD_GET_FIRST, get a list of first n&lt;=20 neighbors whose IP version matches ip_addr_p-&gt;version. Entries can be filtered by the rif given in filter_p. If neigh_key_p-&gt;ip_addr.version == SX_IP_VERSION_NONE only IPv4 neighbors will be returned.</li>
<li>3) cmd SX_ACCESS_CMD_GETNEXT, get a list of n&lt;=20 next neighbors after the key's IP address and RIF. The neighbor with the specific key doesn't have to exist. Entries can be filtered by the rif given in filter_p. If neigh_key_p-&gt;ip_addr.version == SX_IP_VERSION_NONE only IPv4 neighbors will be returned.</li>
</ul>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET/GET_FIRST/GET_NEXT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif</td><td>- Router Interface Id. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neigh_key_p</td><td>- neigh key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_p</td><td>- neigh key_filter. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">neigh_entry_list_p</td><td>- found neigh entries arr </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">neigh_entry_cnt_p</td><td>- found neigh entries num</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if neighbor was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="acf9f7e35f14c64b05c3aa179d40f4d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9f7e35f14c64b05c3aa179d40f4d35">&#9670;&nbsp;</a></span>sx_api_router_neigh_activity_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_neigh_activity_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t&#160;</td>
          <td class="paramname"><em>rif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ip_addr_t *&#160;</td>
          <td class="paramname"><em>ip_addr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean_t *&#160;</td>
          <td class="paramname"><em>activity_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function reads and cleans the neighbor's activity information. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ / READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif</td><td>- Router Interface Id. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ip_addr_p</td><td>- neigh IP address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">activity_p</td><td>- activity .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if neighbor was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a567fd03de370a075336735995e17e77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567fd03de370a075336735995e17e77b">&#9670;&nbsp;</a></span>sx_api_router_uc_route_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_uc_route_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ip_prefix_t *&#160;</td>
          <td class="paramname"><em>network_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_uc_route_data_t *&#160;</td>
          <td class="paramname"><em>uc_route_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function modifies unicast routes in the routing table. A route may have one of several types: IP2ME, LOCAL, or NEXT_HOP IP2ME routes trap traffic with the specified destination IP of the router host. Such traffic will have trap ID of IP2ME. Local routes allow IP forwarding to neighbors, and also trap traffic to unknown neighbors within the subnet. Such traffic will have trap ID of ARP-cache miss. Next-hop routes allow IP forwarding to next hop router(s) Next-hop routes must be defined with an ECMP container ID. ADD creates a new route and DELETE deletes an existing route. Command SET may be used to replace an existing route. This includes optionally changing its type. If a flow-counter is bound to the route, it stays bound. Command DELETE_ALL deletes all of the unicast routes of the specified virtual router, the specified route type in uc_route_data_p-&gt;type, and the IP protocol(s) in network_addr-&gt;version. If uc_route_data_p is NULL, then routes of type NEXT_HOP are deleted. If network_addr is NULL or network_addr-&gt;version is SX_IP_VERSION_NONE then all IPv4 routes of the specified type are deleted. For routes with action TRAP or TRAP_FORWARD, the trapped traffic will have Trap ID of SX_TRAP_ID_L3_UC_IP_BASE for trap priority BEST_EFFORT, LOW or MEDIUM, or (SX_TRAP_ID_L3_UC_IP_BASE+3) for higher trap priorities.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3. Note: This API supports Async Mode operation if the router is initialized with Async support</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/SET/SOFT_ADD/DELETE/DELETE_ALL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">network_addr_p</td><td>- IP network address. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">uc_route_data_p</td><td>- route data {ecmp id,action}</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_ACCEPTED if operation completes successfully in Async Mode. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no routes is available to create. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a7e7840f0e1e453e677668b9f652c66fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7840f0e1e453e677668b9f652c66fc">&#9670;&nbsp;</a></span>sx_api_router_uc_route_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_uc_route_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ip_prefix_t *&#160;</td>
          <td class="paramname"><em>network_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_uc_route_key_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_uc_route_get_entry_t *&#160;</td>
          <td class="paramname"><em>uc_route_get_entries_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>uc_route_get_entries_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets unicast route information from the routing table. The function can receive four types of input:</p>
<ul>
<li>1) Get information for a specific IP address. Set the specific IP prefix in the network_addr parameter. uc_route_get_entries_cnt_p should be set to 1. cmd should be set to SX_ACCESS_CMD_GET.</li>
<li>2) Count the number of configured IPv4/6 UC routes, according to the network_addr-&gt;version parameter. uc_route_get_entries_cnt_p should be set to 0. cmd should be set to SX_ACCESS_CMD_GET.</li>
<li>3) Get a list of first n&lt;=64 routes. Set IP prefix data in the network_addr parameter. uc_route_get_entries_cnt_p should be set to n. Set filter_p filter type(s) to filter the results by. cmd should be set to SX_ACCESS_CMD_GET_FIRST.</li>
<li>4) Get a list of n&lt;=64 routes which comes after specific IP prefix (not necessarily an existing one). Set IP prefix address in the network_addr parameter. uc_route_get_entries_cnt_p should be set to n, filter_p is the filter type(s) you want to filter the results by. cmd should be SX_ACCESS_CMD_GETNEXT.</li>
</ul>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET /GET_FIRST/ GETNEXT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">network_addr</td><td>- IP network address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_p</td><td>- UC route key_filter. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a059c220b2a25fb94729c83688e7f8ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059c220b2a25fb94729c83688e7f8ff0">&#9670;&nbsp;</a></span>sx_api_router_uc_route_operational_ecmp_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_uc_route_operational_ecmp_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ip_prefix_t *&#160;</td>
          <td class="paramname"><em>network_addr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_uc_route_get_entry_t *&#160;</td>
          <td class="paramname"><em>oper_uc_route_entries_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>This API is deprecated and will be removed in the future. Use ECMP containers. This function retrieves active unicast ECMP route information from the routing table. When using oper_uc_route_entries_p-&gt;route_data.next_hop_cnt=0 only the number of next hops will be returned. Supported devices: Spectrum, Spectrum2, Spectrum3.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">network_addr</td><td>- IP network address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">oper_uc_route_entries_p</td><td>- found uc route entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ECMP UC route was not found. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="ada19ea02653d8cea4a46b48752f524a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada19ea02653d8cea4a46b48752f524a1">&#9670;&nbsp;</a></span>sx_api_router_uc_route_counter_bind_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_uc_route_counter_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ip_prefix_t *&#160;</td>
          <td class="paramname"><em>network_addr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_flow_counter_id_t&#160;</td>
          <td class="paramname"><em>counter_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binds or un-binds a flow counter to an existing unicast route Note: A route may be created via a call to <a class="el" href="sx__api__router_8h.html#a567fd03de370a075336735995e17e77b">sx_api_router_uc_route_set()</a> A flow counter may be created via a call to <a class="el" href="sx__api__flow__counter_8h.html#a9d043e95b58d1d326128c643c0952802">sx_api_flow_counter_set()</a> Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- BIND/UNBIND </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">network_addr_p</td><td>- Network prefix of a unicast route </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_id</td><td>- A flow counter identifier. Applicable only for command BIND</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if the specified route or flow counter was not found. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a8d9e8525ebab84f8c49bff8d59f0eb59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9e8525ebab84f8c49bff8d59f0eb59">&#9670;&nbsp;</a></span>sx_api_router_uc_route_counter_bind_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_uc_route_counter_bind_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ip_prefix_t *&#160;</td>
          <td class="paramname"><em>network_addr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_flow_counter_id_t *&#160;</td>
          <td class="paramname"><em>counter_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the flow counter currently bound to a specified unicast route Notes: A flow counter may be bound to a route via a call to <a class="el" href="sx__api__router_8h.html#ada19ea02653d8cea4a46b48752f524a1">sx_api_router_uc_route_counter_bind_set()</a> If no counter if bound to the specified route, this function returns SUCCESS, and sets *counter_id_p to SX_FLOW_COUNTER_ID_INVALID Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">network_addr_p</td><td>- Network prefix of a unicast route </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter_id_p</td><td>- Returns the flow counter ID bound to the specified route</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if the specified route was not found. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a472c9bb573ce5a76a04f14cd53346b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472c9bb573ce5a76a04f14cd53346b6f">&#9670;&nbsp;</a></span>sx_api_router_counter_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_counter_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_counter_id_t *&#160;</td>
          <td class="paramname"><em>counter_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function creates/destroys a router counter. A router counter should be bound later to a router interface. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE/DESTROY. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">counter_p</td><td>- Router counter ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no counter is available to create. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a0e73f38b6a51b7090c5c775c96689dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e73f38b6a51b7090c5c775c96689dfd">&#9670;&nbsp;</a></span>sx_api_router_counter_extended_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_counter_extended_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_counter_attributes_t&#160;</td>
          <td class="paramname"><em>cntr_attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_counter_id_t *&#160;</td>
          <td class="paramname"><em>counter_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function creates/destroys a router counter by given type. A router counter should be bound later to a router interface. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE/DESTROY. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>- Router counter type. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">counter_p</td><td>- Router counter ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no counter is available to create. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a71f2d9f69205e6835bd4290703106121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f2d9f69205e6835bd4290703106121">&#9670;&nbsp;</a></span>sx_api_router_interface_counter_bind_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_counter_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_counter_id_t&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t&#160;</td>
          <td class="paramname"><em>rif</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function binds/unbinds a router counter to a router interface. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- BIND/UNBIND. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter</td><td>- Router counter ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif</td><td>- Router Interface ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if counter was not added. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if interface is already bound. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="aa81e1f46c5501aee769e56e4fa4ebf23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81e1f46c5501aee769e56e4fa4ebf23">&#9670;&nbsp;</a></span>sx_api_router_interface_counter_bind_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_counter_bind_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_counter_id_t&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_interface_t *&#160;</td>
          <td class="paramname"><em>rif_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets a router counter bind of a router interface. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter</td><td>- Router counter ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rif_p</td><td>- Router Interface ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if counter was not added. </dd>
<dd>
SX_STATUS_ENTRY_NOT_BOUND if counter was not bound. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="ab4c18223f082f72efeb16ef6ab4545c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c18223f082f72efeb16ef6ab4545c6">&#9670;&nbsp;</a></span>sx_api_router_counter_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_counter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_counter_id_t&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_counter_set_t *&#160;</td>
          <td class="paramname"><em>counter_set_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets a router counter. When using cmd=READ_CLEAR, the counters will be returned and cleared. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ/READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter</td><td>- Router counter ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter_set_p</td><td>- Router counter set values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if counter was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a1b43b5655884e760afefdfd3f3910ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b43b5655884e760afefdfd3f3910ea4">&#9670;&nbsp;</a></span>sx_api_router_counter_extended_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_counter_extended_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_counter_id_t&#160;</td>
          <td class="paramname"><em>counter_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_counter_set_extended_t *&#160;</td>
          <td class="paramname"><em>counter_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets a router counter by given type. When using cmd=READ_CLEAR, the counters will be returned and cleared. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ/READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter</td><td>- Router counter ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter_data_p</td><td>- Router counter data values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if counter was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a1c3d7ede0cc2b4a383aacf414c9d84a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3d7ede0cc2b4a383aacf414c9d84a3">&#9670;&nbsp;</a></span>sx_api_router_counter_clear_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_counter_clear_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_counter_id_t&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boolean_t&#160;</td>
          <td class="paramname"><em>all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function clears router counter set of a router counter. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter</td><td>- Router counter ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">all</td><td>- Clear all Router counters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if counter was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a88d28b1cf1ea8606acaecf5c01c31051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d28b1cf1ea8606acaecf5c01c31051">&#9670;&nbsp;</a></span>sx_api_router_mc_route_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_route_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_key_t *&#160;</td>
          <td class="paramname"><em>mc_route_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_attributes_t *&#160;</td>
          <td class="paramname"><em>mc_route_attr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_data_t *&#160;</td>
          <td class="paramname"><em>mc_route_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds/modifies/deletes a multicast route from the MC routing table.</p>
<p>In case action is not SX_ROUTER_ACTION_FORWARD/SX_ROUTER_ACTION_DROP, Trap ID will be set to SX_TRAP_ID_L3_MC_IP_BASE + trap priority.</p>
<p>In case mc_router_attr_p-&gt;rpf_action is SX_ROUTER_RPF_ACTION_TRAP, the caller should configure SX_TRAP_ID_ETH_L3_RPF trap first.</p>
<p>In case the RPF action is SX_ROUTER_RPF_ACTION_TRAP or SX_ROUTER_RPF_ACTION_DROP, the ingress RIF in the key should be the RPF RIF. In case the RPF action is SX_ROUTER_RPF_ACTION_DIRECTIONAL, a valid ingress RIF must be given. egress_rif_cnt and egress_container_id are mutually exclusive and may not be both specified. e.g. if egress_rif_cnt is nonzero then egress_container_id must be SX_MC_CONTAINER_ID_INVALID. The DELETE_ALL command will delete all MC routes that match a given VRID and IP version specified by source_addr.version. If the given IP version is SX_IP_VERSION_NONE, then all MC routes on the given VRID will be deleted, regardless of the IP version. the valid manual priority range is 1 - 32. Router action SX_ROUTER_ACTION_SPAN is not supported on any device. in case RPF actions is SX_ROUTER_RPF_ACTION_TRAP_LIST and SX_ROUTER_RPF_ACTION_DROP_LIST then a valid RPF Group id must be given (that was previously created).</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/EDIT/DELETE/DELETE_ALL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_route_key_p</td><td>- mc route entry key {source IP prefix, group mask, ingress RIF} </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_router_attr_p</td><td>- multicast route attributes (e.g. RPF mode, ttl, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_route_data_p</td><td>- route data (e.g. action, egress RIF list, etc.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no routes are available to create. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a24a37e74c648d6bd3de469df8cbd5b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a37e74c648d6bd3de469df8cbd5b8c">&#9670;&nbsp;</a></span>sx_api_router_mc_route_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_route_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_key_t *&#160;</td>
          <td class="paramname"><em>mc_route_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_mc_route_key_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_mc_route_get_entry_t *&#160;</td>
          <td class="paramname"><em>mc_route_get_entries_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>mc_route_get_entries_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets a multicast route or routes from the MC routing table, based on a given key or criteria. For GET_FIRST and GET_NEXT, the value of mc_route_get_entries_cnt_p must be smaller or equal to SX_API_MC_ROUTE_GET_MAX_COUNT. The ingress RIF is only considered part of the key for routes that have RPF action SX_ROUTER_RPF_ACTION_DIRECTIONAL. Therefore, routes that were configured with any other RPF action, and with an ingress RIF other than the "don't care" RIF, will still be returned when filtering by the "don't care" ingress RIF. In these cases, the configured ingress RIF can be found in the MC route data.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET - Get multicast route entry from DB. COUNT - Get number of MC entries from the DB that match the criteria set by filter_p. GET_FIRST - Get first MC route entries from DB. The maximum number of entries to be returned is defined by mc_route_get_entries_cnt_p. The criteria according to which entries will be returned is defined by filter_p. The last route returned will be in mc_route_key_p, and all routes returned will be in mc_route_get_entries_list_p. GET_NEXT - Get next MC route entries from DB. The maximum number of entries to be returned is defined by mc_route_get_entries_cnt_p. The criteria according to which entries will be returned is defined by filter_p. The first entry returned will be the entry after that given in mc_route_key_p, which should have been received by a previous call to this API with GET_FIRST or GET_NEXT. The last route returned will be in mc_route_key_p, and all routes returned will be in mc_route_get_entries_list_p. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_route_key_p</td><td>- mc route entry key {Source IP Address, group address, ingress rif} </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_p</td><td>- filter according to which MC routes should be returned. Relevant only for GET_FIRST and GET_NEXT commands. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mc_route_get_entries_list_p</td><td>- list of returned MC routes </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mc_route_get_entries_cnt_p</td><td>- as input: number of entries in mc_route_get_entries_list_p as output: number of entries returned in mc_route_get_entries_list_p</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_NOT_FOUND if mc route is not found </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="ab70bf9ca856f55a88e7dd5a4fe5f77fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70bf9ca856f55a88e7dd5a4fe5f77fa">&#9670;&nbsp;</a></span>sx_api_router_mc_route_activity_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_route_activity_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_key_t *&#160;</td>
          <td class="paramname"><em>mc_route_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean_t *&#160;</td>
          <td class="paramname"><em>activity_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function reads and clears multicast route activity. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ\READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_route_key_p</td><td>- mc route entry key {Source IP Address, group address, ingress rif} </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">activity_p</td><td>- Route activity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_NOT_FOUND if mc route is not found </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a209bcda3949dca1c76a5e18aa6705255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209bcda3949dca1c76a5e18aa6705255">&#9670;&nbsp;</a></span>sx_api_router_mc_route_activity_notify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_route_activity_notify </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_activity_notify_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function initiates a notification regarding active mc routes in the system. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ\READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_p</td><td>- activity notifier filter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if parameter is invalid. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if a notification procedure is already running. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a49d704b1d7e401edc59dde5aff4bf376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d704b1d7e401edc59dde5aff4bf376">&#9670;&nbsp;</a></span>sx_api_router_mc_egress_rif_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_egress_rif_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_key_t *&#160;</td>
          <td class="paramname"><em>mc_route_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t *&#160;</td>
          <td class="paramname"><em>egress_rif_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>egress_rif_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds/sets/deletes/deletes-all egress RIFs to/from a previously configured MC route. Only routes configured with egress_rif_cnt and egress_rif_list_p are supported by this function. Routes configured with egress_container_id are not supported.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE/DELETE_ALL/SET SET command replaces the entire list of existing egress RIFs with the given list. DELETE_ALL command deletes all egress router interfaces associated with multicast group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_route_key_p</td><td>- mc route entry key {Source IP Address, group address, ingress rif} </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">egress_rif_list_p</td><td>- Egress Router Interface array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">egress_rif_cnt</td><td>- Egress Router Interface array num.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no more RIFs can be set. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a530c3fdb5083d5c3a8f8e74ee348da69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530c3fdb5083d5c3a8f8e74ee348da69">&#9670;&nbsp;</a></span>sx_api_router_mc_egress_rif_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_egress_rif_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_key_t *&#160;</td>
          <td class="paramname"><em>mc_route_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_interface_t *&#160;</td>
          <td class="paramname"><em>egress_rif_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>egress_rif_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets the list of egress RIFs associated with the given multicast route. When egress_rif_num is 0 or egress_rif_arr == NULL, the function will return the number of egress RIFs, and egress_rif_arr will remain empty. Only routes configured with egress_rif_cnt and egress_rif_list_p are supported by this function. Routes configured with egress_container_id are not.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_route_key_p</td><td>- mc route entry key {Source IP Address, group address, ingress rif} </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">egress_rif_list_p</td><td>- Egress Router Interface array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">egress_rif_cnt_p</td><td>- as input: number of entries in egress_rif_list_p as output: number of egress RIFs returned in egress_rif_list_p</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="ad8dbefb60e445f59551a682a9177faa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8dbefb60e445f59551a682a9177faa4">&#9670;&nbsp;</a></span>sx_api_router_cos_rewrite_pcpdei_enable_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_cos_rewrite_pcpdei_enable_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_cos_pcp_dei_rewrite_e&#160;</td>
          <td class="paramname"><em>rewrite_pcp_dei</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function enables in-router rewriting of PCP, DEI rewriting bits. The configuration is per IP router. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rewrite_pcp_dei</td><td>- enable the option to rewrite PCP and DEI fields at the egress port (preserve from the ingress, disable rewrite, enable rewrite).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a263b0c24b5930c791a6691a473934ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263b0c24b5930c791a6691a473934ee8">&#9670;&nbsp;</a></span>sx_api_router_cos_rewrite_pcpdei_enable_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_cos_rewrite_pcpdei_enable_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_cos_pcp_dei_rewrite_e *&#160;</td>
          <td class="paramname"><em>rewrite_pcp_dei_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function retrieves in-router rewriting of PCP, DEI rewriting bits. The configuration is per IP router. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rewrite_pcp_dei</td><td>- enable the option to rewrite PCP and DEI fields at the egress port (preserve from the ingress, disable rewrite, enable rewrite).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a8d98abb2561504116bda54e5e7a1647c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d98abb2561504116bda54e5e7a1647c">&#9670;&nbsp;</a></span>sx_api_router_cos_prio_update_enable_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_cos_prio_update_enable_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boolean_t&#160;</td>
          <td class="paramname"><em>update_priority_color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function enables in-router updating of switch-priority and color. The updated mapping is defined using sx_api_router_cos_dscp_to_prio_set. The configuration is per IP router. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update_priority_color</td><td>- enable updates the switch priority and color by the DSCP map defined using sx_api_router_cos_dscp_to_prio_set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="aa1bd7e45636b6128e1add0ad579b2f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1bd7e45636b6128e1add0ad579b2f86">&#9670;&nbsp;</a></span>sx_api_router_cos_prio_update_enable_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_cos_prio_update_enable_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean_t *&#160;</td>
          <td class="paramname"><em>update_priority_color_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function retrieves in-router updating of switch-priority and color. The updated mapping is defined using sx_api_router_cos_dscp_to_prio_set. The configuration is per IP router. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">update_priority_color_p</td><td>- enable updates the switch priority and color by the DSCP map described in sx_api_router_cos_dscp_to_prio_set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a3601a683f22a7e13bc89b3f80a4a3c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3601a683f22a7e13bc89b3f80a4a3c0e">&#9670;&nbsp;</a></span>sx_api_router_cos_dscp_to_prio_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_cos_dscp_to_prio_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_cos_dscp_t *&#160;</td>
          <td class="paramname"><em>dscp_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_cos_priority_color_t *&#160;</td>
          <td class="paramname"><em>priority_color_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>element_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the mapping from DSCP to switch-priority and color for in-router rewrite. Supported devices: Spectrum, Spectrum2, Spectrum3. The mapping is used only if enabled in sx_api_router_cos_prio_update_enable_set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dscp</td><td>- a list of DSCP's </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">switch_priority_color</td><td>- a list of switch priorities and color </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element_cnt</td><td>- num of elements in switch priorities and DSCP's lists</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a3dffe9f627debece49b7ed508c12bf0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dffe9f627debece49b7ed508c12bf0b">&#9670;&nbsp;</a></span>sx_api_router_cos_dscp_to_prio_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_cos_dscp_to_prio_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_cos_dscp_t *&#160;</td>
          <td class="paramname"><em>dscp_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_cos_priority_color_t *&#160;</td>
          <td class="paramname"><em>priority_color_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>element_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function retrieves the mapping from DSCP to switch-priority and color for in-router rewrite. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dscp</td><td>- a list of DSCP's </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">switch_priority_color_p</td><td>- a list of switch priorities and color </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element_cnt_p</td><td>- num of elements in switch priorities and DSCP's lists</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd></dl>

</div>
</div>
<a id="abd1c22691400cdcd80424831ff6bc942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1c22691400cdcd80424831ff6bc942">&#9670;&nbsp;</a></span>sx_api_router_ecmp_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_ecmp_id_t *&#160;</td>
          <td class="paramname"><em>ecmp_id_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_next_hop_t *&#160;</td>
          <td class="paramname"><em>next_hop_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>next_hop_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function creates/modifies/destroys an ECMP container, according to cmd.</p>
<p>SX_ACCESS_CMD_CREATE - by providing a next hops list, the command creates an ECMP container. Container content is formed as a subset of the resolved next hops. Returned Next hops weights are adjusted to the proper weights as written on HW. This command returns the containers next hops as written on HW, list count and new container ID. SX_ACCESS_CMD_SET - Modifies the contents of an existing ECMP container, specified by *ecmp_id_p. If *next_hop_cnt_p is zero, SET cmd empties the container. SX_ACCESS_CMD_DESTROY - by providing a container ID, the command removes all next hops from the existing given container, destroying the container as well. The container ID is invalid until reassigned on container creation. This command returns list count 0 Weights will be modified on runtime according to next hops resolution changes. Clearing(set with an empty next hops list), is not allowed in case container is in use by UC route(s).</p>
<p>Note for ECMP containers of types SX_ECMP_CONTAINER_TYPE_NVE_FLOOD and SX_ECMP_CONTAINER_TYPE_NVE_MC:</p><ol type="1">
<li>The max size of ECMP NVE container is determined:<ul>
<li>by sx_tunnel_nve_general_params_t.ecmp_max_size value on Spectrum;</li>
<li>by min{rm_resources_t.tunnel_nve_group_size_flood_max;sx_router_resources_param_t.max_ecmp_block_size} for ECMP NVE FLOOD containers on Spectrum2 and higher;</li>
<li>by min{rm_resources_t.tunnel_nve_group_size_mc_max;sx_router_resources_param_t.max_ecmp_block_size} for ECMP NVE MC containers on Spectrum2 and higher;</li>
</ul>
</li>
<li>ECMP NVE containers can contain next hops only of the type SX_NEXT_HOP_TYPE_TUNNEL_ENCAP.</li>
<li>To create an ECMP container of the type SX_ECMP_CONTAINER_TYPE_NVE_FLOOD or SX_ECMP_CONTAINER_TYPE_NVE_MC, do the following steps: 3.1. Create an empty ECMP container using sx_api_router_ecmp_set; 3.2. Change the type of this ECMP container using sx_api_router_ecmp_attributes_set; 3.3. Set next hopes to this ECMP container using sx_api_router_ecmp_set;</li>
<li>On Spectrum, all ECMP NVE containers have the same size in HW, if an ECMP NVE container has next hops with the total weight less than the configured global size (sx_tunnel_nve_general_params_t.ecmp_max_size), then next hops will be configured to HW using weighted round robin algorithm. For example if the size is configured to be four, and an ECMP NVE container has two following next hops:<ul>
<li>next hop #A with weight of 1;</li>
<li>next hop #B with weight of 2; you will get unbalanced ECMP container. In the HW, this ECMP container will have three next hops with total weight of four: nh #A, nh #B, nh #A.</li>
</ul>
</li>
</ol>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- action to perform: CREATE, DESTROY, SET, </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ecmp_id</td><td>- id of ECMP container </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">next_hop_list_p</td><td>- a given list of next hops </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">next_hop_cnt_p</td><td>- amount of next hops</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if parameter is NULL or exceeds range. </dd>
<dd>
SX_STATUS_UNSUPPORTED if invalid cmd. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no space for ECMP container allocation. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if trying to destroy ECMP an container in use. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ecmp_id not found. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a7c569920c238a3289dc3877a5c10783e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c569920c238a3289dc3877a5c10783e">&#9670;&nbsp;</a></span>sx_api_router_ecmp_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ecmp_id_t&#160;</td>
          <td class="paramname"><em>ecmp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_next_hop_t *&#160;</td>
          <td class="paramname"><em>next_hop_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>next_hop_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function retrieves an ECMP container content, as defined by the user. Note: This function returns next hops for a given ECMP ID even if this ECMP is redirected. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ecmp_id</td><td>- id of an ECMP container </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">next_hop_list_p</td><td>- a given list of next hops </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">next_hop_cnt_p</td><td>- amount of next hops</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if parameter is NULL or exceeds range. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ecmp_id not found. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a866dedd655aa7313be54227fe54ec57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866dedd655aa7313be54227fe54ec57e">&#9670;&nbsp;</a></span>sx_api_router_ecmp_iter_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_iter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ecmp_id_t&#160;</td>
          <td class="paramname"><em>ecmp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ecmp_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_ecmp_id_t *&#160;</td>
          <td class="paramname"><em>ecmp_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ecmp_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns a list of one or more ECMP container identifiers. The following use case scenarios apply with different input parameters X = don't-care</p><ul>
<li>1) cmd = SX_ACCESS_CMD_GET, ecmp_id = X, ecmp_list = X, ecmp_cnt = 0: In this case the API will return the total number of ECMP containers in the Internal db.</li>
<li>2) cmd = SX_ACCESS_CMD_GET, ecmp_id = valid/invalid, ecmp_list = valid, ecmp_cnt = 1: In this case the API will check if the specified ECMP container ID exists. If it does, the ECMP container ID will be returned in the ecmp_list along with a ecmp_cnt of 1. If the key does not exist, an empty list will be returned with ecmp_cnt = 0. A non-NULL ecmp_list pointer must be provided in this case.</li>
<li>3) cmd = SX_ACCESS_CMD_GET, ecmp_id = valid/invalid, ecmp_list = valid, ecmp_cnt &gt; 1: An ecmp_cnt &gt; 1 will be treated as a ecmp_cnt of 1 and the behavior will be same as the earlier GET use cases.</li>
<li>4) cmd = SX_ACCESS_CMD_GET_FIRST/SX_ACCESS_CMD_GETNEXT, ecmp_id = X ecmp_list = NULL, ecmp_cnt = 0: A zero ecmp_cnt and an empty ecmp_list will be returned.</li>
<li>5) cmd = SX_ACCESS_CMD_GET_FIRST, ecmp_id = X, ecmp_list = valid, ecmp_cnt &gt; 0: In this case the API will return the first ecmp_cnt ECMP container IDs starting from the head of the database. The total number of elements fetched will be returned as ecmp_cnt. Note: returned ecmp_cnt may be less than or equal to the requested ecmp_cnt. The key is ignored in this case. A non-NULL ecmp_list pointer must be provided in this case.</li>
<li>6) cmd = SX_ACCESS_CMD_GETNEXT, ecmp_id = valid/invalid, ecmp_list = valid, ecmp_cnt &gt; 0: In this case the API will return the next set of ECMP container IDs starting from the next valid ECMP container ID after the specified ECMP container ID. The total number of elements fetched will be returned as the ecmp_cnt. Note: returned ecmp_cnt may be less than or equal to the requested ecmp_cnt. If no valid next ECMP container ID exists in the db, an empty list will be returned. A non-NULL ecmp_list pointer must be provided in this case.</li>
</ul>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>: SX API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>: GET/GET_FIRST/GET_NEXT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ecmp_id</td><td>: specify an ECMP container ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>: specify a filter parameter (not supported yet) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ecmp_list_p</td><td>: return list of ECMP container IDs </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ecmp_cnt_p</td><td>: [in] number of ECMP container IDs to get : [out] number of ECMP container IDs returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if an unexpected NULL parameter was passed. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ERROR general error. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED - if invalid cmd is passed </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED - if router module is uninitialized </dd>
<dd>
SX_STATUS_CMD_ERROR - if internal RPC mechanism to SDK server fails </dd>
<dd>
SX_STATUS_DB_NOT_INITIALIZED - if internal ECMP DB is not initialized </dd></dl>

</div>
</div>
<a id="a44c2973c659f035cbde4f0a519b1082b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c2973c659f035cbde4f0a519b1082b">&#9670;&nbsp;</a></span>sx_api_router_operational_ecmp_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_operational_ecmp_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ecmp_id_t&#160;</td>
          <td class="paramname"><em>ecmp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_next_hop_t *&#160;</td>
          <td class="paramname"><em>next_hop_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>next_hop_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function retrieves the ECMP container content, as written to HW(only resolved next hops are written to HW). Note: This function will return next hops for a given ECMP ID if this ECMP isn't redirected, if the ECMP is redirected, it will return next hops from the destination ECMP. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ecmp_id</td><td>- id of an ECMP container </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">next_hop_list_p</td><td>- a given list of next hops </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">next_hop_cnt_p</td><td>- amount of next hops</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if parameter is NULL or exceeds range. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ecmp_id not found. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a2aa9c0bda0299d13e275a267c1249fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa9c0bda0299d13e275a267c1249fb8">&#9670;&nbsp;</a></span>sx_api_router_ecmp_counter_bind_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_counter_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ecmp_id_t&#160;</td>
          <td class="paramname"><em>ecmp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_flow_counter_id_t *&#160;</td>
          <td class="paramname"><em>counter_id_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>offset_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>elements_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function binds/unbinds a router counter to a list of next hops for a given container. In case of INVALID_NEXT_HOP_OFFSET counter will be bound to all next hops in given ECMP container. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- BIND/UNBIND. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ecmp_id</td><td>- id of an ECMP container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_id_list_p</td><td>- list of counter IDs to bind to matching offsets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset_list_p</td><td>- list of next hop entries offset in configured next hops list to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elements_cnt</td><td>- amount of next hops offsets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if counter was not added. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if interface is already bound. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a2fa0de25ef37a9cef1652e920c5fc019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa0de25ef37a9cef1652e920c5fc019">&#9670;&nbsp;</a></span>sx_api_router_ecmp_fine_grain_counter_bind_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_fine_grain_counter_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ecmp_id_t&#160;</td>
          <td class="paramname"><em>ecmp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_flow_counter_id_t&#160;</td>
          <td class="paramname"><em>counter_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>offset_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>elements_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function binds/unbinds a router counter to a list of indices in a container active set. This API should be used for containers that are not static containers. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- BIND/UNBIND. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ecmp_id</td><td>- ID of a non static ECMP container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_id</td><td>- ID of a counter to bind to the given offsets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset_list_p</td><td>- list of entry offsets in configured ECMP container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elements_cnt</td><td>- amount of entry offsets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if counter was not added. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if interface is already bound. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a823465cf10115d18b458c33a678cfccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823465cf10115d18b458c33a678cfccf">&#9670;&nbsp;</a></span>sx_api_router_neigh_activity_notify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_neigh_activity_notify </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_neigh_activity_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function initiates a notification regarding active neighbors in the system. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ\READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_p</td><td>- neigh activity notifier filter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if parameter is invalid. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if a notification procedure is already running. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a242f69b150debcf00867d67f8515e8a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242f69b150debcf00867d67f8515e8a6">&#9670;&nbsp;</a></span>sx_api_router_ecmp_attributes_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_attributes_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ecmp_id_t&#160;</td>
          <td class="paramname"><em>ecmp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ecmp_attributes_t *&#160;</td>
          <td class="paramname"><em>attr_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets an ECMP container's attributes. Using this API is not mandatory for ECMP hashing (default value is SX_ECMP_TYPE_STATIC_E) To use this API one should create an empty ECMP container, set the container attributes and add next hops. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ecmp_id</td><td>- an ID of an ECMP container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attr_p</td><td>- ECMP container attributes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_ERROR general error </dd>
<dd>
SX_STATUS_PARAM_ERROR if parameter is NULL or exceeds range. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ecmp_id not found. </dd></dl>

</div>
</div>
<a id="afa58f3a820da481643de557c94a401ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa58f3a820da481643de557c94a401ea">&#9670;&nbsp;</a></span>sx_api_router_ecmp_attributes_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_attributes_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ecmp_id_t&#160;</td>
          <td class="paramname"><em>ecmp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_ecmp_attributes_t *&#160;</td>
          <td class="paramname"><em>attr_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function retrieves an ECMP container's attributes. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ecmp_id</td><td>- id of ECMP container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">attr_p</td><td>- ECMP container attributes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_ERROR general error </dd>
<dd>
SX_STATUS_PARAM_ERROR if parameter is NULL or exceeds range. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ecmp_id not found. </dd></dl>

</div>
</div>
<a id="a1936f4c977dfe4c92e31af4ba9390845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1936f4c977dfe4c92e31af4ba9390845">&#9670;&nbsp;</a></span>sx_api_router_ecmp_clone_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_clone_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ecmp_id_t&#160;</td>
          <td class="paramname"><em>old_ecmp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_ecmp_id_t *&#160;</td>
          <td class="paramname"><em>new_ecmp_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function clones an ECMP container. Note: ECMP redirect doesn't affect the cloning process - newly cloned container won't be redirected even if the original one is redirected. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_ecmp_id</td><td>- Old ID of ECMP container </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_ecmp_id_p</td><td>- New ID of ECMP container pointer return with pointer that contains the new created container ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if parameter is NULL or exceeds range. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no space for ECMP container allocation. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ecmp_id not found. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="aa529787aa5b258a80c567f751dbfe2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa529787aa5b258a80c567f751dbfe2ee">&#9670;&nbsp;</a></span>sx_api_router_mc_rpf_group_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_rpf_group_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_rpf_group_id_t *&#160;</td>
          <td class="paramname"><em>rpf_group_id_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_vinterface_t *&#160;</td>
          <td class="paramname"><em>rpf_vif_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rpf_vif_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Manipulate a multicast router Reverse-Path Forwarding group Command CREATE creates a new RPF group which contains the specified list of ingress RIFs in rpf_rif_list_p, and returns its new group ID in rpf_group_id_p. Command SET replaces the contents of an existing RPF group specified by rpf_group_id_p, with the specified list of ingress RIFs in rpf_rif_list_p. Command DESTROY deletes the existing RPF group specified by rpf_group_id_p Command DELETE_ALL deletes all existing RPF groups. Notes: An RPF group in use by a multicast route cannot be destroyed An RPF group may contain only ingress RIFs which belong to the same virtual router An RPF group must contain at least one ingress RIF</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE/SET/DESTROY/DELETE_ALL. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rpf_group_id_p</td><td>- Specifies or returns the group ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rpf_rif_list_p</td><td>- Specifies the list of ingress RIFs in a group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rpf_rif_cnt</td><td>- Specifies the amount of ingress RIFs in rpf_rif_list_p</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if specified group ID does not exist. </dd>
<dd>
SX_STATUS_NO_RESOURCES if there are no resources for the operation. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if group is in use and cannot be destroyed. </dd></dl>

</div>
</div>
<a id="ae922af870268cc2ccf178169027ac093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae922af870268cc2ccf178169027ac093">&#9670;&nbsp;</a></span>sx_api_router_mc_rpf_group_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_rpf_group_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_rpf_group_id_t *&#160;</td>
          <td class="paramname"><em>rpf_group_id_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_vinterface_t *&#160;</td>
          <td class="paramname"><em>rpf_vif_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rpf_vif_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve information about a multicast router Reverse-Path Forwarding group Command GET retrieves information about an RPF group specified by rpf_group_id_p Command GETFIRST retrieves the first existing RPF group, its ID and contents Command GETNEXT retrieves the next existing RPF group, its ID and contents Notes: In order to enumerate all existing RPF groups, a client application may call GETFIRST once, and then repeatedly call GETNEXT until all groups are retrieved. If *rpf_rif_cnt_p is 0, then rpf_rif_list_p may be NULL, and only the amount of RIFs is returned without the list of RIFs.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET/GETFIRST/GETNEXT </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rpf_group_id_p</td><td>- Specifies a previous group ID or returns a group ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rpf_rif_list_p</td><td>- Returns a list of ingress RIFs in the group </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rpf_rif_cnt</td><td>- Specifies the size of rpf_rif_list_p, and returns the amount of ingress RIFs in rpf_rif_list_p</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if specified group ID does not exist, or no more groups. </dd></dl>

</div>
</div>
<a id="a6a4327a03b23e683f531b359fa569ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4327a03b23e683f531b359fa569ecf">&#9670;&nbsp;</a></span>sx_api_router_mc_route_counter_bind_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_route_counter_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_key_t *&#160;</td>
          <td class="paramname"><em>mc_route_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_flow_counter_id_t&#160;</td>
          <td class="paramname"><em>counter_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binds or un-binds a flow counter to an existing multicast route Note: A route may be created via a call to <a class="el" href="sx__api__router_8h.html#a88d28b1cf1ea8606acaecf5c01c31051">sx_api_router_mc_route_set()</a> A flow counter may be created via a call to <a class="el" href="sx__api__flow__counter_8h.html#a9d043e95b58d1d326128c643c0952802">sx_api_flow_counter_set()</a> Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- BIND/UNBIND </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_route_key_p</td><td>- MC route key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_id</td><td>- A flow counter identifier. Applicable only for command BIND</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_PARAM_NULL if any input parameter is null. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if the specified route or flow counter was not found. </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_BOUND if mc route already bounded. </dd>
<dd>
SX_STATUS_ENTRY_NOT_BOUND if counter was not bound. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a450a42c80363d8802247f85c77fae63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450a42c80363d8802247f85c77fae63d">&#9670;&nbsp;</a></span>sx_api_router_mc_route_counter_bind_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_route_counter_bind_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_key_t *&#160;</td>
          <td class="paramname"><em>mc_route_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_flow_counter_id_t *&#160;</td>
          <td class="paramname"><em>counter_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the flow counter currently bound to a specified multicast route Notes: A flow counter may be bound to a route via a call to <a class="el" href="sx__api__router_8h.html#a6a4327a03b23e683f531b359fa569ecf">sx_api_router_mc_route_counter_bind_set()</a> If no counter is bound to the specified route, this function returns SUCCESS, and sets *counter_id_p to SX_FLOW_COUNTER_ID_INVALID Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_route_key_p</td><td>- MC route key </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter_id_p</td><td>- Returns the flow counter ID bound to the specified route</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_PARAM_NULL if any input parameter is null. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if the specified route was not found. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="aed7c89711216cab09b505dc134c03fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed7c89711216cab09b505dc134c03fd3">&#9670;&nbsp;</a></span>sx_api_router_ecmp_redirect_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_redirect_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ecmp_id_t&#160;</td>
          <td class="paramname"><em>ecmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ecmp_id_t&#160;</td>
          <td class="paramname"><em>redirect_ecmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API CREATEs/DESTROYs redirection between an ECMP(“ecmp”) and a destination ECMP(“redirect_ecmp”).</p>
<p>Note: Only ECMP NVE containers can be redirected; ECMP container “ecmp” can be redirected to an ECMP container “redirect_ecmp” only if:</p><ol type="1">
<li>ECMP container “redirect_ecmp” is not in use (the reference counter of ECMP container is equal 0): 1.1 ex.: there are no FDB entries that point to “redirect_ecmp”;</li>
<li>“redirect_ecmp” is not redirected to any other ECMP and no other container is already redirected to “redirect_ecmp”. Once ECMP container “redirect_ecmp” becomes the master, the user cannot create objects that point to the container “redirect_ecmp” directly. ECMP container “redirect_ecmp” cannot be destroyed until redirection stops. ECMP container “ecmp” cannot be destroyed until redirection stops. Only 1:1 redirection is supported:</li>
</ol>
<ol type="1">
<li>Redirection chains are not supported: “A” -&gt; “B” -&gt; “C”;</li>
<li>N:1 redirection is not supported: “A” -&gt; “C” | “B” -&gt; “C”;</li>
</ol>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE/DESTROY </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ecmp</td><td>- ECMP ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">redirect_ecmp</td><td>- ECMP ID which ecmp now points to. Ignored in DESTROY command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd></dl>

</div>
</div>
<a id="ac706ced1172271936ca0ec91f1f1fd13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac706ced1172271936ca0ec91f1f1fd13">&#9670;&nbsp;</a></span>sx_api_router_ecmp_redirect_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_redirect_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ecmp_id_t&#160;</td>
          <td class="paramname"><em>ecmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean_t *&#160;</td>
          <td class="paramname"><em>is_redirected_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_ecmp_id_t *&#160;</td>
          <td class="paramname"><em>redirected_ecmp_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API returns information whether given ECMP is redirected. If given ECMP is redirected, the redirected ECMP ID is returned.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ecmp</td><td>- ECMP ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_redirected_p</td><td>- is ECMP_port redirected. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">redirected_ecmp_p</td><td>- the ECMP ID to point to when the ECMP is redirected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd></dl>

</div>
</div>
<a id="a5b5868a7290cad14c7af06cb86fb48b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5868a7290cad14c7af06cb86fb48b6">&#9670;&nbsp;</a></span>sx_api_router_req_completion_info_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_req_completion_info_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_req_completion_info_get_entry_t *&#160;</td>
          <td class="paramname"><em>completion_info_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API gets the completion info for the last successfully configured route in Hardware. The completion Info will contain the user cookie provided when the route was configured. Note: This API is relevant if the Router has been initialized in Async mode only. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">completion_info_p</td><td>– Completion Info Parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 30 2020 12:08:33 for Mellanox SwitchX SDK API Guide by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
