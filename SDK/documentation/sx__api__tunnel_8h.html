<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mellanox SwitchX SDK API Guide: sdk/sx_api_tunnel.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mellanox SwitchX SDK API Guide
   &#160;<span id="projectnumber">4.4.2044-042</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_243a4ba6b4f893d71afbb5a3e90552fa.html">sdk</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sx_api_tunnel.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="sx__api__tunnel_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a40bc19e566d33dc03cf2e672cb18a55d"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#a40bc19e566d33dc03cf2e672cb18a55d">sx_api_tunnel_log_verbosity_level_set</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)</td></tr>
<tr class="separator:a40bc19e566d33dc03cf2e672cb18a55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa95d22b8e1b6eaa1322e49eac53a84"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#acfa95d22b8e1b6eaa1322e49eac53a84">sx_api_tunnel_log_verbosity_level_get</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)</td></tr>
<tr class="separator:acfa95d22b8e1b6eaa1322e49eac53a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ec5c4b2f9b81ec479dad1b50d9ba52"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#aa7ec5c4b2f9b81ec479dad1b50d9ba52">sx_api_tunnel_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_tunnel_attribute_t *tunnel_attr_p, sx_tunnel_id_t *tunnel_id_p)</td></tr>
<tr class="separator:aa7ec5c4b2f9b81ec479dad1b50d9ba52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22113f980b5750d68d351869bd87588"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#ac22113f980b5750d68d351869bd87588">sx_api_tunnel_get</a> (const sx_api_handle_t handle, const sx_tunnel_id_t tunnel_id, sx_tunnel_attribute_t *tunnel_attr_p)</td></tr>
<tr class="separator:ac22113f980b5750d68d351869bd87588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9ad0f9d5aba9b3d67571f3d32f5acd"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#a5a9ad0f9d5aba9b3d67571f3d32f5acd">sx_api_tunnel_counter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_tunnel_id_t tunnel_id, sx_tunnel_counter_t *counter)</td></tr>
<tr class="separator:a5a9ad0f9d5aba9b3d67571f3d32f5acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16b2ae1f5bf4f1475c69302b2eb42e8"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#af16b2ae1f5bf4f1475c69302b2eb42e8">sx_api_tunnel_decap_rules_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_tunnel_decap_entry_key_t *decap_key_p, const sx_tunnel_decap_entry_data_t *decap_data_p)</td></tr>
<tr class="separator:af16b2ae1f5bf4f1475c69302b2eb42e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89448d7a5bf4dfdce358d149fbd5094a"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#a89448d7a5bf4dfdce358d149fbd5094a">sx_api_tunnel_decap_rules_get</a> (const sx_api_handle_t handle, const sx_tunnel_decap_entry_key_t *decap_key_p, sx_tunnel_decap_entry_data_t *decap_data_p)</td></tr>
<tr class="separator:a89448d7a5bf4dfdce358d149fbd5094a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ad038ffde3ed3d010d3ac13791c030"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#a19ad038ffde3ed3d010d3ac13791c030">sx_api_tunnel_init_set</a> (const sx_api_handle_t handle, sx_tunnel_general_params_t *params_p)</td></tr>
<tr class="separator:a19ad038ffde3ed3d010d3ac13791c030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5441bcc9b92faf2210b9245091e9d1"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#a8a5441bcc9b92faf2210b9245091e9d1">sx_api_tunnel_deinit_set</a> (const sx_api_handle_t handle)</td></tr>
<tr class="separator:a8a5441bcc9b92faf2210b9245091e9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0289ce12b688e179afd12b033eb310"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#a1b0289ce12b688e179afd12b033eb310">sx_api_tunnel_map_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_tunnel_id_t tunnel_id, const sx_tunnel_map_entry_t *map_entries_p, const uint32_t map_entries_cnt)</td></tr>
<tr class="separator:a1b0289ce12b688e179afd12b033eb310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6753f86e8ddfdb89212f2396421d1b"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#afa6753f86e8ddfdb89212f2396421d1b">sx_api_tunnel_map_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_tunnel_id_t tunnel_id, sx_tunnel_map_entry_t map_entry_key, sx_tunnel_map_entry_t *map_entries_p, uint32_t *map_entries_cnt_p)</td></tr>
<tr class="separator:afa6753f86e8ddfdb89212f2396421d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0850ddee0e9d5de66c019d34c58298"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#afa0850ddee0e9d5de66c019d34c58298">sx_api_tunnel_ttl_set</a> (const sx_api_handle_t handle, const sx_tunnel_id_t tunnel_id, const sx_tunnel_ttl_data_t *ttl_data_p)</td></tr>
<tr class="separator:afa0850ddee0e9d5de66c019d34c58298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051e78da067e72db6d6bd0d0354a164e"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#a051e78da067e72db6d6bd0d0354a164e">sx_api_tunnel_ttl_get</a> (const sx_api_handle_t handle, const sx_tunnel_id_t tunnel_id, sx_tunnel_ttl_data_t *ttl_data_p)</td></tr>
<tr class="separator:a051e78da067e72db6d6bd0d0354a164e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacaed82de539dde10f0f224c8481131"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#adacaed82de539dde10f0f224c8481131">sx_api_tunnel_hash_set</a> (const sx_api_handle_t handle, const sx_tunnel_id_t tunnel_id, const sx_tunnel_hash_data_t *hash_data_p)</td></tr>
<tr class="separator:adacaed82de539dde10f0f224c8481131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4913cbbdda820ade6c31286205243ef3"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#a4913cbbdda820ade6c31286205243ef3">sx_api_tunnel_hash_get</a> (const sx_api_handle_t handle, const sx_tunnel_id_t tunnel_id, sx_tunnel_hash_data_t *hash_data_p)</td></tr>
<tr class="separator:a4913cbbdda820ade6c31286205243ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8282a313296ef7e26c11baaa74f5e09e"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#a8282a313296ef7e26c11baaa74f5e09e">sx_api_tunnel_cos_set</a> (const sx_api_handle_t handle, const sx_tunnel_id_t tunnel_id, const sx_tunnel_cos_data_t *cos_data_p)</td></tr>
<tr class="separator:a8282a313296ef7e26c11baaa74f5e09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ccc19db14cb9bb25d7c573942e4a80"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#af8ccc19db14cb9bb25d7c573942e4a80">sx_api_tunnel_cos_get</a> (const sx_api_handle_t handle, const sx_tunnel_id_t tunnel_id, sx_tunnel_cos_data_t *cos_data_p)</td></tr>
<tr class="separator:af8ccc19db14cb9bb25d7c573942e4a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a57594ec83a22b4be1a5571d9a8266"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#a78a57594ec83a22b4be1a5571d9a8266">sx_api_tunnel_iter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_tunnel_id_t tunnel_id, const sx_tunnel_filter_t *filter_p, sx_tunnel_id_t *tunnel_id_list_p, uint32_t *tunnel_id_cnt_p)</td></tr>
<tr class="separator:a78a57594ec83a22b4be1a5571d9a8266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e88674b4e8648261dd286fff2ac20b"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__tunnel_8h.html#ad5e88674b4e8648261dd286fff2ac20b">sx_api_tunnel_decap_rule_iter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_tunnel_decap_entry_key_t *decap_key_p, const sx_tunnel_decap_entry_filter_t *decap_filter_p, sx_tunnel_decap_entry_key_t *decap_key_list_p, uint32_t *decap_key_cnt_p)</td></tr>
<tr class="separator:ad5e88674b4e8648261dd286fff2ac20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a40bc19e566d33dc03cf2e672cb18a55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40bc19e566d33dc03cf2e672cb18a55d">&#9670;&nbsp;</a></span>sx_api_tunnel_log_verbosity_level_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_log_verbosity_level_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>module_verbosity_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>api_verbosity_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API sets the log verbosity level of TUNNEL MODULE. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- set verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module_verbosity_level</td><td>- TUNNEL module verbosity level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">api_verbosity_level</td><td>- TUNNEL API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE when parameter exceeds range. </dd></dl>

</div>
</div>
<a id="acfa95d22b8e1b6eaa1322e49eac53a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa95d22b8e1b6eaa1322e49eac53a84">&#9670;&nbsp;</a></span>sx_api_tunnel_log_verbosity_level_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_log_verbosity_level_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>module_verbosity_level_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>api_verbosity_level_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API gets the log verbosity level of TUNNEL MODULE. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- get verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">module_verbosity_level_p</td><td>- TUNNEL module verbosity level </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">api_verbosity_level_p</td><td>- TUNNEL API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE when parameter exceeds range. </dd></dl>

</div>
</div>
<a id="aa7ec5c4b2f9b81ec479dad1b50d9ba52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ec5c4b2f9b81ec479dad1b50d9ba52">&#9670;&nbsp;</a></span>sx_api_tunnel_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_attribute_t *&#160;</td>
          <td class="paramname"><em>tunnel_attr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_tunnel_id_t *&#160;</td>
          <td class="paramname"><em>tunnel_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to create/edit/destroy tunnels.</p>
<p>When destroying a tunnel, tunnel_attr_p is ignored. By default tunnel is created with TTL 255. On Spectrum2, Spectrum3,the SDK user can select the port(ingress or egress) that is used to determine packet ethertype. By default the packet ethertype is taken from ingress port. To change the default behavior, SDK user should create VxLAN tunnel with ethertype SX_ETHERTYPE_FROM_EGRESS_PORT.</p>
<p>Lazy delete feature is supported for VxLAN tunnels. If the Lazy delete feature is disabled and the reference counter of tunnel is 0, then the API call with DELETE command deletes the tunnel, otherwise the SDK returns SX_STATUS_RESOURCE_IN_USE.</p>
<p>If the Lazy delete feature is enabled and the reference counter of a tunnel is not 0, the API call with command DELETE marks a tunnel as deleted, and the SDK returns SX_STATUS_SUCCESS. Once the reference counter of a tunnel becomes 0, SDK will delete the tunnel and will generate a notification with the trap id(SX_TRAP_ID_OBJECT_DELETED_EVENT) and the id of tunnel that was deleted.</p>
<p>Given below is the list of objects that increases the reference counter of a NVE tunnel:</p><ol type="1">
<li>each tunnel map entry;</li>
<li>each MC RPF VIF of type SX_ROUTER_VINTERFACE_TYPE_VXLAN;</li>
<li>each ECMP next hop of the type SX_NEXT_HOP_TYPE_TUNNEL_ENCAP;</li>
<li>each MC next hop of the type SX_MC_NEXT_HOP_TYPE_TUNNEL_ENCAP_IP;</li>
<li>each ACL rule with an action of the type SX_FLEX_ACL_ACTION_TUNNEL_DECAP;</li>
<li>each ACL rule with an action of the type SX_FLEX_ACL_ACTION_NVE_TUNNEL_ENCAP;</li>
</ol>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE / DESTROY / EDIT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tunnel_attr_p</td><td>- pointer to tunnel attributes structure. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tunnel_id_p</td><td>- Tunnel ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any of the input parameters is invalid </dd>
<dd>
SX_STATUS_UNSUPPORTED if the api is not supported for this device </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if the command is not supported by the api </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if any of the input parameters doesn't exist </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="ac22113f980b5750d68d351869bd87588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac22113f980b5750d68d351869bd87588">&#9670;&nbsp;</a></span>sx_api_tunnel_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_id_t&#160;</td>
          <td class="paramname"><em>tunnel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_tunnel_attribute_t *&#160;</td>
          <td class="paramname"><em>tunnel_attr_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API gets the tunnel configuration. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tunnel_id</td><td>- Tunnel ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tunnel_attr_p</td><td>- pointer to tunnel attributes structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_UNSUPPORTED if api is not supported for this device </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a5a9ad0f9d5aba9b3d67571f3d32f5acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9ad0f9d5aba9b3d67571f3d32f5acd">&#9670;&nbsp;</a></span>sx_api_tunnel_counter_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_counter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_id_t&#160;</td>
          <td class="paramname"><em>tunnel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_tunnel_counter_t *&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API get/clear tunnel counters. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ / READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tunnel_id</td><td>- Tunnel ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter</td><td>- pointer to tunnel counters structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_UNSUPPORTED if api is not supported for this device </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="af16b2ae1f5bf4f1475c69302b2eb42e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16b2ae1f5bf4f1475c69302b2eb42e8">&#9670;&nbsp;</a></span>sx_api_tunnel_decap_rules_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_decap_rules_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_decap_entry_key_t *&#160;</td>
          <td class="paramname"><em>decap_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_decap_entry_data_t *&#160;</td>
          <td class="paramname"><em>decap_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to manage rules in the tunnel decap table. The decap table is used to terminate encapsulated packets.</p>
<p>The decap key provides packet matching mechanism and each key is mapped to one tunnel.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE / DESTROY / EDIT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">decap_key_p</td><td>- decap key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">decap_data_p</td><td>- decap data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_UNSUPPORTED if api is not supported for this device. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if any input parameter doesn't exist </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS if key already used for another tunnel. </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is not initialized </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter exceeds valid range </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a89448d7a5bf4dfdce358d149fbd5094a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89448d7a5bf4dfdce358d149fbd5094a">&#9670;&nbsp;</a></span>sx_api_tunnel_decap_rules_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_decap_rules_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_decap_entry_key_t *&#160;</td>
          <td class="paramname"><em>decap_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_tunnel_decap_entry_data_t *&#160;</td>
          <td class="paramname"><em>decap_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to get decap rules from decap table.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">decap_key_p</td><td>- Key to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">decap_data_p</td><td>- Data associated with key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_UNSUPPORTED if api is not supported for this device </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if key doesn't exists. </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a19ad038ffde3ed3d010d3ac13791c030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ad038ffde3ed3d010d3ac13791c030">&#9670;&nbsp;</a></span>sx_api_tunnel_init_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_init_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_tunnel_general_params_t *&#160;</td>
          <td class="paramname"><em>params_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to initialize tunneling module. Please note that the correct parsing depth should be set using sx_api_port_parsing_depth_set API for tunneling usage scenarios.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params_p</td><td>- pointer to general params structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_NO_RESOURCES if sufficient resources are not available for tunneling. </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a8a5441bcc9b92faf2210b9245091e9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5441bcc9b92faf2210b9245091e9d1">&#9670;&nbsp;</a></span>sx_api_tunnel_deinit_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_deinit_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to de-initialize the tunneling module. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a1b0289ce12b688e179afd12b033eb310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0289ce12b688e179afd12b033eb310">&#9670;&nbsp;</a></span>sx_api_tunnel_map_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_map_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_id_t&#160;</td>
          <td class="paramname"><em>tunnel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_map_entry_t *&#160;</td>
          <td class="paramname"><em>map_entries_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>map_entries_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to manage the mapping between tunnel and bridge/VLAN. With the DELETE_ALL command, the map_entries_p parameter is ignored.</p>
<p>Lazy delete feature is supported for VxLAN tunnel mappings. If Lazy delete feature is disabled and the reference counter of the tunnel mapping is 0, then the API call with command DELETE deletes a tunnel mapping, otherwise the SDK returns SX_STATUS_RESOURCE_IN_USE.</p>
<p>If the Lazy delete feature is enabled and the reference counter of the tunnel mapping is not 0, then the API call with command DELETE marks a tunnel mapping as deleted, and SDK returns SX_STATUS_SUCCESS. Once the reference counter of the tunnel mapping becomes 0, SDK will delete the tunnel mapping, unbind DECAP, ENCAP UC and ENCAP MC flow counters if they are bound and will generate a notification with the trap id(SX_TRAP_ID_OBJECT_DELETED_EVENT) and the copy of tunnel mapping that was deleted. NOS should monitor delete notification events in order to delete the counter resource. If the user tries to re-create a tunnel map entry before a notification is received, then the SDK returns error SX_STATUS_RESOURCE_IN_USE.</p>
<p>Given below is the list of objects that increases the reference counter of a tunnel map entry:</p><ol type="1">
<li>a static tunnel UC FDB entry;</li>
<li>a MC FDB entry (if MC container has a tunnel next hop);</li>
<li>each tunnel flood vector that was bound to a FID with sx_api_fdb_flood_set;</li>
<li>each ACL rule with an action of the type SX_FLEX_ACL_ACTION_NVE_MC_TUNNEL_ENCAP (if MC container has a tunnel next hop);</li>
</ol>
<p>The map_entries_cnt parameter is limited by TUNNEL_MAP_ENTRIES_SET_MAX_NUM.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD / DELETE / DELETE_ALL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tunnel_id</td><td>- Tunnel ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_entries_p</td><td>- Array of map entries </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_entries_cnt</td><td>- amount of entries in map_entries_p</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if tunnel doesn't exist. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS if tunnel and bridge/VLAN already bound. </dd>
<dd>
SX_STATUS_UNSUPPORTED if api is not supported for this device. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if cmd is unsupported in this API. </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if try to delete more maps than configured for the tunnel. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if the user tries to re-create a tunnel map entry that is marked as deleted. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="afa6753f86e8ddfdb89212f2396421d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6753f86e8ddfdb89212f2396421d1b">&#9670;&nbsp;</a></span>sx_api_tunnel_map_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_map_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_id_t&#160;</td>
          <td class="paramname"><em>tunnel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_tunnel_map_entry_t&#160;</td>
          <td class="paramname"><em>map_entry_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_tunnel_map_entry_t *&#160;</td>
          <td class="paramname"><em>map_entries_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>map_entries_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API gets the mapping information between tunnel and bridge/VLAN. This function supports the below commands in the order mentioned below. 1) cmd SX_ACCESS_CMD_GET_FIRST, get a list of first n&lt;=1000 map entries of specified tunnel id.</p>
<p>2) cmd SX_ACCESS_CMD_GETNEXT, get a list of n&lt;=1000 next map entries whose value larger than the given map_entry_key of specified tunnel id.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET_FIRST/ GET_NEXT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tunnel_id</td><td>- Tunnel ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_entry_key</td><td>- map entry, as a key to get next entries </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">map_entries_p</td><td>- Array of map entries </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">map_entries_cnt_p</td><td>- amount of entries in map_entries_p</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if neighbor was not added. </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="afa0850ddee0e9d5de66c019d34c58298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0850ddee0e9d5de66c019d34c58298">&#9670;&nbsp;</a></span>sx_api_tunnel_ttl_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_ttl_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_id_t&#160;</td>
          <td class="paramname"><em>tunnel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_ttl_data_t *&#160;</td>
          <td class="paramname"><em>ttl_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to set the tunnel TTL parameters.</p>
<p>Note for Spectrum:</p><ol type="1">
<li>TTL behavior and values are shared between all tunnels of same type.</li>
<li>IPinIP tunnels support TTL_CMD_SET and TTL_CMD_COPY in the encap direction, default value is TTL_CMD_COPY.</li>
<li>NVE tunnels support TTL_CMD_SET in the encap direction, default TTL value is 255.</li>
</ol>
<p>Note for Spectrum2 and newer ASICs:</p><ol type="1">
<li>IPinIP tunnels support only TTL_CMD_SET &amp; TTL_CMD_COPY commands</li>
<li>IPinIP tunnels only support configuring TTL command in encap direction</li>
<li>NVE tunnels support TTL_CMD_SET, TTL_CMD_COPY in Encap direction.</li>
<li>NVE tunnels support TTL_CMD_PRESERVE_E, TTL_CMD_COPY, TTL_CMD_MINIMUM in decap direction. Default is PRESERVE.</li>
<li>For Symmetric tunnels, the TTL behavior must be set separately for encap and decap directions.</li>
</ol>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tunnel_id</td><td>- Tunnel ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ttl_data_p</td><td>- pointer to tunnel ttl data structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_UNSUPPORTED if api is not supported for this device </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a051e78da067e72db6d6bd0d0354a164e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051e78da067e72db6d6bd0d0354a164e">&#9670;&nbsp;</a></span>sx_api_tunnel_ttl_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_ttl_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_id_t&#160;</td>
          <td class="paramname"><em>tunnel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_tunnel_ttl_data_t *&#160;</td>
          <td class="paramname"><em>ttl_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to get the tunnel TTL parameters.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tunnel_id</td><td>- Tunnel ID </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ttl_data_p</td><td>- pointer to tunnel ttl data structure, set direction field for which you want get config.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_UNSUPPORTED if api is not supported for this device </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="adacaed82de539dde10f0f224c8481131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adacaed82de539dde10f0f224c8481131">&#9670;&nbsp;</a></span>sx_api_tunnel_hash_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_hash_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_id_t&#160;</td>
          <td class="paramname"><em>tunnel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_hash_data_t *&#160;</td>
          <td class="paramname"><em>hash_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to set the tunnel hash parameters.</p>
<p>Note for Spectrum:</p><ol type="1">
<li>Hash parameters are shared between all tunnels of the same type.</li>
<li>IPinIP tunnels support setting an IPV6_FLOW_LABEL. Default value is 0.</li>
<li>NVE tunnels support setting a UDP_SPORT. Default value is 0.</li>
</ol>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tunnel_id</td><td>- Tunnel ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_data_p</td><td>- pointer to tunnel hash data structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_UNSUPPORTED if api is not supported for this device </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a4913cbbdda820ade6c31286205243ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4913cbbdda820ade6c31286205243ef3">&#9670;&nbsp;</a></span>sx_api_tunnel_hash_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_hash_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_id_t&#160;</td>
          <td class="paramname"><em>tunnel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_tunnel_hash_data_t *&#160;</td>
          <td class="paramname"><em>hash_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to get the tunnel hash parameters.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tunnel_id</td><td>- Tunnel ID </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hash_data_p</td><td>- pointer to tunnel hash data structure, hash_field_type should be set for retrieving the correct config.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_UNSUPPORTED if api is not supported for this device </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a8282a313296ef7e26c11baaa74f5e09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8282a313296ef7e26c11baaa74f5e09e">&#9670;&nbsp;</a></span>sx_api_tunnel_cos_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_cos_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_id_t&#160;</td>
          <td class="paramname"><em>tunnel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_cos_data_t *&#160;</td>
          <td class="paramname"><em>cos_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to set the CoS attributes of tunnel. CoS behaviour applies to all tunnels of a given type. Changes applied to one tunnel will change the CoS behaviour of all tunnels of same type.</p>
<p>The API configures QoS parameters for encapsulation and decapsulation flow separately based on value in cos_data_p-&gt;param_type.</p>
<p>Given below are the parameters that can be configured with this API:</p>
<ol type="1">
<li>cos_data_p-&gt;update_priority_color - Packet switch priority and color when it is not preserved.</li>
<li>cos_data_p-&gt;prio_color - New switch priority and color for the packet when cos_data_p-&gt;update_priority_color is set to TRUE.</li>
<li>cos_data_p-&gt;dsc_rewrite - Action for DSCP rewrite i.e disabled, enabled or preserved to a dscp value that was set on packet ingress port. cos_data_p-&gt;dscp_action - If DSCP rewrite is disabled then DSCP value is dependent on dscp_action.<ul>
<li>the DSCP value on encap can be copied from inner header or set from cos_data_p-&gt;dscp_value</li>
<li>the DSCP value on decap can be copied from outer or preserved When dscp_action is copy and if there is no IP header, then the value from cos_data_p-&gt;dscp_value is used.</li>
</ul>
</li>
<li>ECN mapping on encapsulation or decapsulation</li>
</ol>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tunnel</td><td>id - Tunnel ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cos_data_p</td><td>- Pointer to CoS data structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_UNSUPPORTED if api is not supported for this device or tunnel type/direction. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if tunnel doesn't exists. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="af8ccc19db14cb9bb25d7c573942e4a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ccc19db14cb9bb25d7c573942e4a80">&#9670;&nbsp;</a></span>sx_api_tunnel_cos_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_cos_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_id_t&#160;</td>
          <td class="paramname"><em>tunnel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_tunnel_cos_data_t *&#160;</td>
          <td class="paramname"><em>cos_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to retrieve CoS data. CoS data retrieval for ENCAP or DECAP direction can be controlled by cos_data_p-&gt;param_type. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tunnel</td><td>id - Tunnel ID. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>cos_data_p - Pointer to CoS data structure - by CoS param type (ENCAP/DECAP).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_UNSUPPORTED if api is not supported for this device or tunnel type/direction </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if tunnel doesn't exists. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a78a57594ec83a22b4be1a5571d9a8266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a57594ec83a22b4be1a5571d9a8266">&#9670;&nbsp;</a></span>sx_api_tunnel_iter_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_iter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_id_t&#160;</td>
          <td class="paramname"><em>tunnel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_tunnel_id_t *&#160;</td>
          <td class="paramname"><em>tunnel_id_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>tunnel_id_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API retrieves a list of one or more Tunnel IDs. The following use case scenarios apply with different input parameters X = don't-care</p><ul>
<li>1) cmd = SX_ACCESS_CMD_GET, tunnel_id = X, filter = valid/invalid, tunnel_id_list = X, tunnel_id_cnt = 0: In this case the API will return the total number of tunnel IDs filtered by the filter parameter if present.</li>
<li>2) cmd = SX_ACCESS_CMD_GET, tunnel_id = valid/invalid, filter = valid/invalid, tunnel_id_list = valid, tunnel_id_cnt = 1: In this case the API will check if the specified tunnel_id exists AND it matches the filter if present. If it does, the tunnel ID will be returned in the tunnel_id_list along with a tunnel_id_cnt of 1. If the tunnel ID does not exist, an empty list will be returned with tunnel_id_cnt = 0. A non-NULL tunnel_id_list pointer must be provided in this case.</li>
<li>3) cmd = SX_ACCESS_CMD_GET, tunnel_id = valid/invalid, filter = valid/invalid, tunnel_id_list = valid, tunnel_id_cnt &gt; 1: A tunnel_id_cnt &gt; 1 will be treated as a tunnel_id_cnt of 1 and the behavior will be same as the previous GET use cases.</li>
<li>4) cmd = SX_ACCESS_CMD_GET_FIRST/SX_ACCESS_CMD_GETNEXT, tunnel_id = X, filter = X, tunnel_id_list = NULL, tunnel_id_cnt = 0: A zero tunnel_id_cnt and an empty tunnel_id_list will be returned.</li>
<li>5) cmd = SX_ACCESS_CMD_GET_FIRST, tunnel_id = X, tunnel_id_list = valid, filter = valid/invalid, tunnel_id_cnt &gt; 0: In this case the API will return the first tunnel_id_cnt tunnel IDs starting from the head of the database AND match the filter if present. The total number of elements fetched will be returned as tunnel_id_cnt. The input tunnel ID is ignored in this case. A non-NULL tunnel_id_list pointer must be provided in this case.</li>
<li>6) cmd = SX_ACCESS_CMD_GETNEXT, tunnel_id = valid/invalid, filter = valid/invalid, tunnel_id_list = valid, tunnel_id_cnt &gt; 0: In this case the API will return the next set of tunnel IDs which matches the filter if present starting from the next tunnel ID after the specified tunnel ID. The total number of elements fetched will be returned as the tunnel_id_cnt. If no valid next tunnel ID exists in the db, an empty list will be returned. A non-NULL tunnel_id_list pointer must be provided in this case.</li>
</ul>
<p>Two type of filter can be used, 1) sx_tunnel_type_e: it exactly match the type defined for the tunnels 2) sx_tunnel_direction_e: if tunnel direction is SX_TUNNEL_DIRECTION_SYMMETRIC, it will match any direction(ENCAP/DECAP/SYMMETRIC) of filter, otherwise, it will only match the same direction of filter.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET/GET_FIRST/GET_NEXT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tunnel_id</td><td>- tunnel ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_p</td><td>- specify a filter parameter </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tunnel_id_list_p</td><td>- return list of tunnel IDs </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tunnel_id_cnt_p</td><td>- [in] number of tunnel IDs to get<ul>
<li>[out] number of tunnel IDs returned</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED for tunnel module uninitialized </dd></dl>

</div>
</div>
<a id="ad5e88674b4e8648261dd286fff2ac20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e88674b4e8648261dd286fff2ac20b">&#9670;&nbsp;</a></span>sx_api_tunnel_decap_rule_iter_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_tunnel_decap_rule_iter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_decap_entry_key_t *&#160;</td>
          <td class="paramname"><em>decap_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_tunnel_decap_entry_filter_t *&#160;</td>
          <td class="paramname"><em>decap_filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_tunnel_decap_entry_key_t *&#160;</td>
          <td class="paramname"><em>decap_key_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>decap_key_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to retrieve the count or a list of one or more Tunnel Decap Rules The rules are essentially the Keys that the rules match on. The rule's attributes(actions) can then be read using the sx_api_tunnel_decap_rules_get API for each key. Using the filter param, the return list can be refined. The following filters are supported 1) sx_tunnel_type_e: only return the keys that match the tunnel type 2) sx_tunnel_id: only return the keys that match the tunnel id</p>
<p>The following use case scenarios apply with different input parameters X = don't-care</p><ul>
<li>1) cmd = SX_ACCESS_CMD_GET, key = X, Filter = X, decap_key_list = X, Count=0: In this case the API will return the total number of Decap rules in the Internal db</li>
<li>2) cmd = SX_ACCESS_CMD_GET, key = valid/invalid, Filter = X, decap_key_list = Valid, Count = 1: In this case the API will check if the specified key exists. if it does the key will be returned in the decap_key_list along with a count of 1. If the key does not exist an empty list will be returned with count = 0</li>
<li>3) cmd = SX_ACCESS_CMD_GET, key = valid, Filter = Valid, decap_key_list is Valid, Count=1: In this case the API will check if the specified key exists. if it does exist then, it will check it against the filter parameter. If the filter matches, then the key will be returned in the decap_key_list along with a count of 1. If the key does not exist or the filter does not match an empty list will be returned with count = 0</li>
<li>4) cmd = SX_ACCESS_CMD_GET, key = valid, Filter = Valid/invalid, decap_key_list is Valid, Count &gt; 1: A count &gt;1 will be treated as a count of 1 and the behavior will be same as earlier GET use cases.</li>
<li>5) cmd = SX_ACCESS_CMD_GET_FIRST/SX_ACCESS_CMD_GETNEXT, key = X, Filter = X, decap_key_list = Null, Count =0: For either SX_ACCESS_CMD_GET_FIRST/SX_ACCESS_CMD_GETNEXT a zero count will return an empty list.</li>
<li>6) cmd = SX_ACCESS_CMD_GET_FIRST, key = X, Filter = valid/invalid, decap_key_list = Valid, Count &gt; 0: In this case the API will return the first count decap key entries starting from the head of the database. The total elements fetched will be returned as the return count. Note: return count may be less than or equal to the requested count. The key is dont-care. If a filter is specified only those decap key entries that match the filter will be returned. A non-Null return decap_key_list pointer must be provided.</li>
<li>7) cmd = SX_ACCESS_CMD_GETNEXT, key = valid/invalid, Filter = valid/invalid, decap_key_list = Valid, Count &gt; 0: In this case the API will return the next set of decap key entries starting from the next valid decap key entry after the specified key. The total elements fetched will be returned as the return count. If a filter is specified, then only those decap key entries that match the filter will be returned. Note: return count may be less than or equal to the requested count. If no valid next decap key entry exists in the db (key = end of list, or invalid key specified, or key too large), an empty list will be returned.</li>
</ul>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>: SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>: GET/GET_FIRST/GET_NEXT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">decap_key_p</td><td>: specify a Tunnel decap entry key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">decap_filter_p</td><td>: specify a filter parameter </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">decap_key_list_p</td><td>: return list of decap key entries </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">decap_key_cnt_p</td><td>: [in] number of decap keys to read : [out] number of decap keys returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if an unsupported command is passed </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if key doesn't exists. </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED when tunnel module is uninitialized </dd>
<dd>
SX_STATUS_DB_NOT_INITIALIZED if the database was not initialized </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 30 2020 12:08:33 for Mellanox SwitchX SDK API Guide by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
