<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mellanox SwitchX SDK API Guide: sdk/sx_api_bridge.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mellanox SwitchX SDK API Guide
   &#160;<span id="projectnumber">4.4.2044-042</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_243a4ba6b4f893d71afbb5a3e90552fa.html">sdk</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sx_api_bridge.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="sx__api__bridge_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8335bd578d3a91f0346dfa9d1fa9b096"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#a8335bd578d3a91f0346dfa9d1fa9b096">sx_api_bridge_log_verbosity_level_set</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)</td></tr>
<tr class="separator:a8335bd578d3a91f0346dfa9d1fa9b096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9522f3f7337df4a6957c2026b2bd0cfd"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#a9522f3f7337df4a6957c2026b2bd0cfd">sx_api_bridge_log_verbosity_level_get</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)</td></tr>
<tr class="separator:a9522f3f7337df4a6957c2026b2bd0cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a8f3e22c4d6a53b5432edfbfab4a1e"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#a64a8f3e22c4d6a53b5432edfbfab4a1e">sx_api_bridge_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_bridge_id_t *bridge_id_p)</td></tr>
<tr class="separator:a64a8f3e22c4d6a53b5432edfbfab4a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1026fba3045a898ad1cc535dc9ccd7"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#a7c1026fba3045a898ad1cc535dc9ccd7">sx_api_bridge_iter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_bridge_id_t bridge_id, const sx_bridge_filter_t *filter_p, sx_bridge_id_t *bridge_id_list_p, uint32_t *bridge_id_cnt_p)</td></tr>
<tr class="separator:a7c1026fba3045a898ad1cc535dc9ccd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab637b1b2d02c5c3807ff90e0dc0b7a26"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#ab637b1b2d02c5c3807ff90e0dc0b7a26">sx_api_bridge_vport_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_bridge_id_t bridge_id, const sx_port_log_id_t log_port)</td></tr>
<tr class="separator:ab637b1b2d02c5c3807ff90e0dc0b7a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32abb8ce6eee61fba5bab2e286c01b46"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#a32abb8ce6eee61fba5bab2e286c01b46">sx_api_bridge_vport_get</a> (const sx_api_handle_t handle, const sx_bridge_id_t bridge_id, sx_port_log_id_t *bridge_vport_list_p, uint32_t *bridge_vport_cnt_p)</td></tr>
<tr class="separator:a32abb8ce6eee61fba5bab2e286c01b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6423c09af9b60ded6ba5f89e763bb109"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#a6423c09af9b60ded6ba5f89e763bb109">sx_api_bridge_vport_multi_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_bridge_id_t *bridge_id_list, const sx_port_log_id_t *log_port_list, uint32_t list_cnt)</td></tr>
<tr class="separator:a6423c09af9b60ded6ba5f89e763bb109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f600518fa4f5d6c059ae146e64cfeca"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#a2f600518fa4f5d6c059ae146e64cfeca">sx_api_bridge_counter_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_bridge_id_t bridge_id, const sx_flow_counter_id_t flow_counter_id)</td></tr>
<tr class="separator:a2f600518fa4f5d6c059ae146e64cfeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2091d5b177d960b08d682df06e430d41"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#a2091d5b177d960b08d682df06e430d41">sx_api_bridge_counter_bind_get</a> (const sx_api_handle_t handle, const sx_bridge_id_t bridge_id, sx_flow_counter_id_t *flow_counter_id_p)</td></tr>
<tr class="separator:a2091d5b177d960b08d682df06e430d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527d1bfb48e9c09614952586b21f693a"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#a527d1bfb48e9c09614952586b21f693a">sx_api_bridge_mirror_set</a> (const sx_api_handle_t handle, const sx_bridge_id_t bridge_id, const sx_mirror_direction_t mirror_direction, const sx_mirror_mode_t mirror_mode)</td></tr>
<tr class="separator:a527d1bfb48e9c09614952586b21f693a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8368b2b6f15e81f9f7bdffbb68f750ad"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#a8368b2b6f15e81f9f7bdffbb68f750ad">sx_api_bridge_mirror_get</a> (const sx_api_handle_t handle, const sx_bridge_id_t bridge_id, const sx_mirror_direction_t mirror_direction, sx_mirror_mode_t *mirror_mode_p)</td></tr>
<tr class="separator:a8368b2b6f15e81f9f7bdffbb68f750ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792aa5f36a6706e856cfb0e6749d4c9d"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#a792aa5f36a6706e856cfb0e6749d4c9d">sx_api_bridge_tunnel_counter_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_bridge_id_t bridge_id, const sx_bridge_tunnel_counter_attr_t *counter_attr_p, const sx_flow_counter_id_t counter_id)</td></tr>
<tr class="separator:a792aa5f36a6706e856cfb0e6749d4c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49baad20f4706d59a2a8700b32be549"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__bridge_8h.html#ae49baad20f4706d59a2a8700b32be549">sx_api_bridge_tunnel_counter_bind_get</a> (const sx_api_handle_t handle, const sx_bridge_id_t bridge_id, const sx_bridge_tunnel_counter_attr_t *counter_attr_p, sx_flow_counter_id_t *counter_id_p)</td></tr>
<tr class="separator:ae49baad20f4706d59a2a8700b32be549"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8335bd578d3a91f0346dfa9d1fa9b096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8335bd578d3a91f0346dfa9d1fa9b096">&#9670;&nbsp;</a></span>sx_api_bridge_log_verbosity_level_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_log_verbosity_level_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>module_verbosity_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>api_verbosity_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API sets the log verbosity level of BRIDGE MODULE. Supported devices: Spectrum , Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- set verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module_verbosity_level</td><td>- BRIDGE module verbosity level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">api_verbosity_level</td><td>- BRIDGE API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a9522f3f7337df4a6957c2026b2bd0cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9522f3f7337df4a6957c2026b2bd0cfd">&#9670;&nbsp;</a></span>sx_api_bridge_log_verbosity_level_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_log_verbosity_level_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>module_verbosity_level_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>api_verbosity_level_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API gets the log verbosity level of BRIDGE MODULE. Supported devices: Spectrum , Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- get verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">module_verbosity_level_p</td><td>- BRIDGE module verbosity level </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">api_verbosity_level_p</td><td>- BRIDGE API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a64a8f3e22c4d6a53b5432edfbfab4a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a8f3e22c4d6a53b5432edfbfab4a1e">&#9670;&nbsp;</a></span>sx_api_bridge_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_bridge_id_t *&#160;</td>
          <td class="paramname"><em>bridge_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to create/destroy a bridge. This function is supported in 802.1D mode only. Supported devices: Spectrum , Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE/DESTROY </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bridge_id_p</td><td>- a bridge_id. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c1026fba3045a898ad1cc535dc9ccd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1026fba3045a898ad1cc535dc9ccd7">&#9670;&nbsp;</a></span>sx_api_bridge_iter_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_iter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_id_t&#160;</td>
          <td class="paramname"><em>bridge_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_bridge_id_t *&#160;</td>
          <td class="paramname"><em>bridge_id_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>bridge_id_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function retrieves a list of one or more Bridge IDs. This function is not supported in 802.1Q mode. The following use case scenarios apply with different input parameters X = don't-care</p><ul>
<li>1) cmd = SX_ACCESS_CMD_GET, bridge_id = X, bridge_id_list = X, bridge_id_cnt = 0: In this case the API will return the total number of bridge IDs in the internal DB.</li>
<li>2) cmd = SX_ACCESS_CMD_GET, bridge_id = valid/invalid, bridge_id_list = valid, bridge_id_cnt = 1: In this case the API will check if the specified bridge_id exists. If it does, the bridge ID will be returned in the bridge_id_list along with a bridge_id_cnt of 1. If the bridge ID does not exist, an empty list will be returned with bridge_id_cnt = 0. A non-NULL bridge_id_list pointer must be provided in this case.</li>
<li>3) cmd = SX_ACCESS_CMD_GET, bridge_id = valid/invalid, bridge_id_list = valid, bridge_id_cnt &gt; 1: A bridge_id_cnt &gt; 1 will be treated as a bridge_id_cnt of 1 and the behavior will be same as the earlier GET use cases.</li>
<li>4) cmd = SX_ACCESS_CMD_GET_FIRST/SX_ACCESS_CMD_GETNEXT, bridge_id = X, bridge_id_list = NULL, bridge_id_cnt = 0: A zero bridge_id_cnt and an empty bridge_id_list will be returned.</li>
<li>5) cmd = SX_ACCESS_CMD_GET_FIRST, bridge_id = X, bridge_id_list = valid, bridge_id_cnt &gt; 0: In this case the API will return the first bridge_id_cnt bridge IDs starting from the head of the database. The total number of elements fetched will be returned as bridge_id_cnt. Note: returned bridge_id_cnt may be less than or equal to the requested bridge_id_cnt. The input bridge ID is ignored in this case. A non-NULL bridge_id_list pointer must be provided in this case.</li>
<li>6) cmd = SX_ACCESS_CMD_GETNEXT, bridge_id = valid/invalid, bridge_id_list = valid, bridge_id_cnt &gt; 0: In this case the API will return the next set of bridge IDs starting from the next bridge ID after the specified bridge ID. The total number of elements fetched will be returned as the bridge_id_cnt. Note: returned bridge_id_cnt may be less than or equal to the requested bridge_id_cnt. If no valid next bridge ID exists in the db, an empty list will be returned. A non-NULL bridge_id_list pointer must be provided in this case.</li>
</ul>
<p>Supported devices: Spectrum , Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET/GET_FIRST/GET_NEXT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bridge_id</td><td>- bridge ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_p</td><td>- specify a filter parameter (not supported yet) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bridge_id_list_p</td><td>- return list of bridge IDs </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bridge_id_cnt_p</td><td>- [in] number of bridge IDs to get<ul>
<li>[out] number of bridge IDs returned</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="ab637b1b2d02c5c3807ff90e0dc0b7a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab637b1b2d02c5c3807ff90e0dc0b7a26">&#9670;&nbsp;</a></span>sx_api_bridge_vport_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_vport_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_id_t&#160;</td>
          <td class="paramname"><em>bridge_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Supported devices: Spectrum, Spectrum2, Spectrum3. This function is used to add/del a virtual port to/from a bridge.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE/DELETE_ALL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bridge_id</td><td>- bridge_id. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical virtual port ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if bridge not found in DB </dd>
<dd>
SX_STATUS_ERROR if unexpected behaviour occurs </dd></dl>

</div>
</div>
<a id="a32abb8ce6eee61fba5bab2e286c01b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32abb8ce6eee61fba5bab2e286c01b46">&#9670;&nbsp;</a></span>sx_api_bridge_vport_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_vport_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_id_t&#160;</td>
          <td class="paramname"><em>bridge_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>bridge_vport_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>bridge_vport_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Supported devices: Spectrum, Spectrum2, Spectrum3. This function is used to get a list of all virtual ports associated with a bridge. When bridge_vport_cnt_p == 0, the number of existing entries will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bridge_id</td><td>- bridge_id. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bridge_vport_list_p</td><td>- a pointer to a sx_port_log_id_t list. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>bridge_vport_cnt_p - size of the bridge_vport_list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if bridge not found in DB </dd>
<dd>
SX_STATUS_ERROR if unexpected behaviour occurs </dd></dl>

</div>
</div>
<a id="a6423c09af9b60ded6ba5f89e763bb109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6423c09af9b60ded6ba5f89e763bb109">&#9670;&nbsp;</a></span>sx_api_bridge_vport_multi_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_vport_multi_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_id_t *&#160;</td>
          <td class="paramname"><em>bridge_id_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>log_port_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>list_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Supported devices: Spectrum, Spectrum2, Spectrum3. This function is used to add/del a virtual ports from list to corresponding bridge from list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE/DELETE_ALL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bridge_id_list</td><td>- bridge_id list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port_list</td><td>- logical virtual port ID list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">list_cnt</td><td>- list counter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if bridge not found in DB </dd>
<dd>
SX_STATUS_ERROR if unexpected behaviour occurs </dd></dl>

</div>
</div>
<a id="a2f600518fa4f5d6c059ae146e64cfeca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f600518fa4f5d6c059ae146e64cfeca">&#9670;&nbsp;</a></span>sx_api_bridge_counter_bind_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_counter_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_id_t&#160;</td>
          <td class="paramname"><em>bridge_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_flow_counter_id_t&#160;</td>
          <td class="paramname"><em>flow_counter_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Supported devices: Spectrum, Spectrum2, Spectrum3. This function is used to bind/unbind a flow counter to a bridge.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- BIND/UNBIND </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bridge_id</td><td>- bridge_id. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flow_counter_id</td><td>- flow counter id to bind</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if bridge is not found in DB </dd>
<dd>
SX_STATUS_ERROR if unexpected behaviour occurs </dd></dl>

</div>
</div>
<a id="a2091d5b177d960b08d682df06e430d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2091d5b177d960b08d682df06e430d41">&#9670;&nbsp;</a></span>sx_api_bridge_counter_bind_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_counter_bind_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_id_t&#160;</td>
          <td class="paramname"><em>bridge_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_flow_counter_id_t *&#160;</td>
          <td class="paramname"><em>flow_counter_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Supported devices: Spectrum, Spectrum2, Spectrum3. This function is used to get the flow counter bound to the bridge. If there is no counter bound to the bridge, the API will return SX_STATUS_ENTRY_NOT_FOUND and flow_counter_id_p will be set to SX_FLOW_COUNTER_ID_INVALID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bridge_id</td><td>- bridge_id. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flow_counter_id_p</td><td>- bound counter id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if bridge is not found in DB or no counter is bound </dd>
<dd>
SX_STATUS_ERROR if unexpected behaviour occurs </dd></dl>

</div>
</div>
<a id="a527d1bfb48e9c09614952586b21f693a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527d1bfb48e9c09614952586b21f693a">&#9670;&nbsp;</a></span>sx_api_bridge_mirror_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_mirror_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_id_t&#160;</td>
          <td class="paramname"><em>bridge_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mirror_direction_t&#160;</td>
          <td class="paramname"><em>mirror_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mirror_mode_t&#160;</td>
          <td class="paramname"><em>mirror_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>This API is deprecated and will be removed in the future. Supported devices: Spectrum, Spectrum2, Spectrum3. This function sets the mirroring mode for a bridge. Currently only ingress direction is supported.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bridge_id</td><td>- mirror bridge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mirror_direction</td><td>- ingress\egress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mirror_mode</td><td>- enabled\disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if bridge not found in DB </dd>
<dd>
SX_STATUS_ERROR if unexpected behavior occurs </dd></dl>

</div>
</div>
<a id="a8368b2b6f15e81f9f7bdffbb68f750ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8368b2b6f15e81f9f7bdffbb68f750ad">&#9670;&nbsp;</a></span>sx_api_bridge_mirror_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_mirror_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_id_t&#160;</td>
          <td class="paramname"><em>bridge_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mirror_direction_t&#160;</td>
          <td class="paramname"><em>mirror_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_mirror_mode_t *&#160;</td>
          <td class="paramname"><em>mirror_mode_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>This API is deprecated and will be removed in the future. Supported devices: Spectrum, Spectrum2, Spectrum3. This function gets the mirroring mode of a bridge by direction and bridge ID Currently only ingress direction is supported.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bridge_id</td><td>- mirror bridge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mirror_direction</td><td>- ingress/egress </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mirror_mode_p</td><td>- the returned mirroring mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if bridge is not found in DB </dd>
<dd>
SX_STATUS_ERROR if unexpected behaviour occurs </dd></dl>

</div>
</div>
<a id="a792aa5f36a6706e856cfb0e6749d4c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a792aa5f36a6706e856cfb0e6749d4c9d">&#9670;&nbsp;</a></span>sx_api_bridge_tunnel_counter_bind_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_tunnel_counter_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_id_t&#160;</td>
          <td class="paramname"><em>bridge_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_tunnel_counter_attr_t *&#160;</td>
          <td class="paramname"><em>counter_attr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_flow_counter_id_t&#160;</td>
          <td class="paramname"><em>counter_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API binds/un-binds a counter to/from a tunnel mapped to the bridge</p>
<p>For ENCAP_UC and ENCAP_MC counters this operation can be performed only when FDB doesn't contain any entries for tunnel in fid. When Lazy Delete mode is enabled, flow counters will be automatically unbounded once the deletion of related VNI mapping is completed and VNI mapping delete notification is sent. Counters can be bound only if the bridge/VLAN to tunnel mapping is configured.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SX_ACCESS_CMD_BIND/SX_ACCESS_CMD_UNBIND. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bridge_id</td><td>- bridge_id/vlan_id on which tunnel mapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attr_p</td><td>- counter attributes (type, tunnel_id) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_d</td><td>- flow counter ID which will be bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if cmd is unsupported in this API. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if tunnel or tunnel mapping does not exist. </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_BOUND if counter already bound. </dd>
<dd>
SX_STATUS_ENTRY_NOT_BOUND if specified counter is not bound. </dd></dl>

</div>
</div>
<a id="ae49baad20f4706d59a2a8700b32be549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49baad20f4706d59a2a8700b32be549">&#9670;&nbsp;</a></span>sx_api_bridge_tunnel_counter_bind_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_bridge_tunnel_counter_bind_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_id_t&#160;</td>
          <td class="paramname"><em>bridge_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_bridge_tunnel_counter_attr_t *&#160;</td>
          <td class="paramname"><em>counter_attr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_flow_counter_id_t *&#160;</td>
          <td class="paramname"><em>counter_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<p>This API gets flow counter for tunnel mapped to the bridge</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bridge_id</td><td>- bridge_id/vlan_id on which tunnel mapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attr_p</td><td>- counter attributes (type, tunnel_id) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter_id_p</td><td>- pointer to flow counter ID. Returns bound counter_id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if tunnel isn't exists or mapping is not found. </dd>
<dd>
SX_STATUS_ENTRY_NOT_BOUND if counter isn't bound. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 30 2020 12:08:33 for Mellanox SwitchX SDK API Guide by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
