<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mellanox SwitchX SDK API Guide: sdk/sx_api_acl.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mellanox SwitchX SDK API Guide
   &#160;<span id="projectnumber">4.4.2044-042</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_243a4ba6b4f893d71afbb5a3e90552fa.html">sdk</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sx_api_acl.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="sx__api__acl_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aadfc89bd1ed719720aef093a6d27aef0"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#aadfc89bd1ed719720aef093a6d27aef0">sx_api_acl_log_verbosity_level_set</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)</td></tr>
<tr class="separator:aadfc89bd1ed719720aef093a6d27aef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b19d38aaad622638cc25ffc1e861e53"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a1b19d38aaad622638cc25ffc1e861e53">sx_api_acl_log_verbosity_level_get</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)</td></tr>
<tr class="separator:a1b19d38aaad622638cc25ffc1e861e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeff59071f650e6e79d3d84a2466aef1"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#abeff59071f650e6e79d3d84a2466aef1">sx_api_acl_region_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_key_type_t key_type, const sx_acl_action_type_t action_type, const sx_acl_size_t region_size, sx_acl_region_id_t *region_id_p)</td></tr>
<tr class="separator:abeff59071f650e6e79d3d84a2466aef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b49b3d09fd3e0e105abe4927a5c602d"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a6b49b3d09fd3e0e105abe4927a5c602d">sx_api_acl_region_get</a> (const sx_api_handle_t handle, const sx_acl_region_id_t region_id, sx_acl_key_type_t *key_type_p, sx_acl_action_type_t *action_type_p, sx_acl_size_t *region_size_p)</td></tr>
<tr class="separator:a6b49b3d09fd3e0e105abe4927a5c602d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3eac6c48940390d6b9fbd8e4c9326c"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a3d3eac6c48940390d6b9fbd8e4c9326c">sx_api_acl_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_type_t acl_type, const sx_acl_direction_t acl_direction, const sx_acl_region_group_t *acl_region_group_p, sx_acl_id_t *acl_id_p)</td></tr>
<tr class="separator:a3d3eac6c48940390d6b9fbd8e4c9326c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21db595169c45f866832b88844cb9f1f"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a21db595169c45f866832b88844cb9f1f">sx_api_acl_get</a> (const sx_api_handle_t handle, const sx_acl_id_t acl_id, sx_acl_type_t *acl_type_p, sx_acl_direction_t *acl_direction_p, sx_acl_region_group_t *acl_region_group_p)</td></tr>
<tr class="separator:a21db595169c45f866832b88844cb9f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb22b1a6ad356f324550aea2c94d93b"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#aefb22b1a6ad356f324550aea2c94d93b">sx_api_acl_iter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_id_t acl_id_key, const sx_acl_filter_t *acl_filter_p, sx_acl_id_t *acl_id_list_p, uint32_t *acl_id_cnt_p)</td></tr>
<tr class="separator:aefb22b1a6ad356f324550aea2c94d93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4067494175b80b6cc7ea878fa47b4857"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a4067494175b80b6cc7ea878fa47b4857">sx_api_acl_attributes_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_id_t acl_id, const sx_acl_attributes_t acl_attributes)</td></tr>
<tr class="separator:a4067494175b80b6cc7ea878fa47b4857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21919706a7abb3c770bd32182fad035"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#ab21919706a7abb3c770bd32182fad035">sx_api_acl_attributes_get</a> (const sx_api_handle_t handle, const sx_acl_id_t acl_id, const sx_acl_attributes_t *acl_attributes_p)</td></tr>
<tr class="separator:ab21919706a7abb3c770bd32182fad035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2813aef5ed638a95b7aec567f96f65"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a2a2813aef5ed638a95b7aec567f96f65">sx_api_acl_global_attributes_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_global_attributes_t global_acl_attributes)</td></tr>
<tr class="separator:a2a2813aef5ed638a95b7aec567f96f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2379f80cae370b31fc6a90be86c7ee2"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#ac2379f80cae370b31fc6a90be86c7ee2">sx_api_acl_global_attributes_get</a> (const sx_api_handle_t handle, const sx_acl_global_attributes_t *global_acl_attributes_p)</td></tr>
<tr class="separator:ac2379f80cae370b31fc6a90be86c7ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc922fb9cf64214d703db802ca91bf32"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#acc922fb9cf64214d703db802ca91bf32">sx_api_acl_group_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_direction_t acl_direction, const sx_acl_id_t *acl_id_list_p, const uint32_t acl_id_cnt, sx_acl_id_t *group_id_p)</td></tr>
<tr class="separator:acc922fb9cf64214d703db802ca91bf32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ecf2ea6914f57c8b24fc288b6aec40"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#ab7ecf2ea6914f57c8b24fc288b6aec40">sx_api_acl_group_get</a> (const sx_api_handle_t handle, const sx_acl_id_t group_id, sx_acl_direction_t *acl_direction_p, sx_acl_id_t *acl_id_list_p, uint32_t *acl_id_cnt_p)</td></tr>
<tr class="separator:ab7ecf2ea6914f57c8b24fc288b6aec40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82c545a8e0bb101aa5c8aa398c109b3"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#ae82c545a8e0bb101aa5c8aa398c109b3">sx_api_acl_group_iter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_id_t group_id_key, const sx_acl_filter_t *acl_filter_p, sx_acl_id_t *acl_id_list_p, uint32_t *acl_id_cnt_p)</td></tr>
<tr class="separator:ae82c545a8e0bb101aa5c8aa398c109b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9bc8fab1341d5a0ac492fae0e918af"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a9f9bc8fab1341d5a0ac492fae0e918af">sx_api_acl_group_attributes_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_id_t acl_group_id, const sx_acl_group_attributes_t *acl_group_attr_p)</td></tr>
<tr class="separator:a9f9bc8fab1341d5a0ac492fae0e918af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39aa648b81eb847a72fa90b9d30acf02"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a39aa648b81eb847a72fa90b9d30acf02">sx_api_acl_group_attributes_get</a> (const sx_api_handle_t handle, const sx_acl_id_t group_id, const sx_acl_group_attributes_t *acl_group_attr_p)</td></tr>
<tr class="separator:a39aa648b81eb847a72fa90b9d30acf02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f1841f9e865b353f5dc6742212b4a0"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#af7f1841f9e865b353f5dc6742212b4a0">sx_api_acl_policy_based_switching_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_acl_pbs_entry_t *pbs_entry_p, sx_acl_pbs_id_t *pbs_id_p)</td></tr>
<tr class="separator:af7f1841f9e865b353f5dc6742212b4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3627a7131f363300617de31f7edc3b"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a1d3627a7131f363300617de31f7edc3b">sx_api_acl_policy_based_switching_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_acl_pbs_id_t pbs_id, sx_acl_pbs_entry_t *pbs_entry_p)</td></tr>
<tr class="separator:a1d3627a7131f363300617de31f7edc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1395c6e1613b712e9854f4e982ff8a62"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a1395c6e1613b712e9854f4e982ff8a62">sx_api_acl_l4_port_range_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_port_range_entry_t *l4_port_range_p, sx_acl_port_range_id_t *range_id_p)</td></tr>
<tr class="separator:a1395c6e1613b712e9854f4e982ff8a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c17eb4b9b274fddb09c13f1514c289"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#ad1c17eb4b9b274fddb09c13f1514c289">sx_api_acl_l4_port_range_get</a> (const sx_api_handle_t handle, const sx_acl_port_range_id_t range_id, sx_acl_port_range_entry_t *l4_port_range_p)</td></tr>
<tr class="separator:ad1c17eb4b9b274fddb09c13f1514c289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb16aaa28349e293f8d768c91f1ebbc7"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#abb16aaa28349e293f8d768c91f1ebbc7">sx_api_acl_l4_port_range_iter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_port_range_id_t range_id_key, const sx_acl_port_range_filter_t *range_id_filter_p, sx_acl_port_range_id_t *range_id_list_p, uint32_t *range_id_cnt_p)</td></tr>
<tr class="separator:abb16aaa28349e293f8d768c91f1ebbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2700b896f2d6045890fd567e2ddf5fa7"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a2700b896f2d6045890fd567e2ddf5fa7">sx_api_acl_range_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_range_entry_t *range_entry_p, sx_acl_port_range_id_t *range_id_p)</td></tr>
<tr class="separator:a2700b896f2d6045890fd567e2ddf5fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef4198e307f8593b7d693f363297678"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a4ef4198e307f8593b7d693f363297678">sx_api_acl_range_get</a> (const sx_api_handle_t handle, const sx_acl_port_range_id_t range_id, sx_acl_range_entry_t *range_entry_p)</td></tr>
<tr class="separator:a4ef4198e307f8593b7d693f363297678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85de9c7f09f1494b0af588835ba5febb"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a85de9c7f09f1494b0af588835ba5febb">sx_api_acl_rules_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_region_id_t region_id, const sx_acl_rule_t *rules_list_p, const uint32_t rules_cnt)</td></tr>
<tr class="separator:a85de9c7f09f1494b0af588835ba5febb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a71f177218829d87debe98d4c399238"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a8a71f177218829d87debe98d4c399238">sx_api_acl_rules_get</a> (const sx_api_handle_t handle, const sx_acl_region_id_t region_id, const sx_acl_rule_offset_t start_offset, sx_acl_rule_t *rules_list_p, uint32_t *rules_cnt_p)</td></tr>
<tr class="separator:a8a71f177218829d87debe98d4c399238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2d4dde1a42506c57445dedaa2934d7"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#aae2d4dde1a42506c57445dedaa2934d7">sx_api_acl_rule_activity_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_region_id_t region_id, const sx_acl_rule_offset_t rule_offset, boolean_t *activity_p)</td></tr>
<tr class="separator:aae2d4dde1a42506c57445dedaa2934d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022e95843912425808dcbb26058e6c5f"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a022e95843912425808dcbb26058e6c5f">sx_api_acl_rule_block_move_set</a> (const sx_api_handle_t handle, const sx_acl_region_id_t region_id, const sx_acl_rule_offset_t block_start, const sx_acl_size_t block_size, const sx_acl_rule_offset_t new_block_start)</td></tr>
<tr class="separator:a022e95843912425808dcbb26058e6c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92286cc3f4baf42e3f97ad25c380ffb6"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a92286cc3f4baf42e3f97ad25c380ffb6">sx_api_acl_port_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_acl_id_t acl_id)</td></tr>
<tr class="separator:a92286cc3f4baf42e3f97ad25c380ffb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9543188e428bed340f419ed050a47277"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a9543188e428bed340f419ed050a47277">sx_api_acl_port_bind_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_acl_direction_t acl_direction, sx_acl_id_t *acl_id_p)</td></tr>
<tr class="separator:a9543188e428bed340f419ed050a47277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e4fd8599f3ba687cad34feb6b27d18"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a45e4fd8599f3ba687cad34feb6b27d18">sx_api_acl_port_bindings_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_acl_direction_t acl_direction, sx_acl_id_t *acl_id_p, uint32_t *acl_cnt_p)</td></tr>
<tr class="separator:a45e4fd8599f3ba687cad34feb6b27d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfe4cc96f0de7b65e2a46603fc1b78a"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a6cfe4cc96f0de7b65e2a46603fc1b78a">sx_api_acl_vlan_group_map_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_id_t swid, const sx_vlan_id_t *vlan_list_p, const uint32_t vlan_cnt, sx_acl_vlan_group_t *group_id_p)</td></tr>
<tr class="separator:a6cfe4cc96f0de7b65e2a46603fc1b78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2943e03e105609c89d70865940ddf9c4"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a2943e03e105609c89d70865940ddf9c4">sx_api_acl_vlan_group_map_get</a> (const sx_api_handle_t handle, const sx_swid_id_t swid, const sx_acl_vlan_group_t group_id, sx_vlan_id_t *vlan_list_p, uint32_t *vlan_cnt_p)</td></tr>
<tr class="separator:a2943e03e105609c89d70865940ddf9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5727bed5f37c11a2691483d3f368c9"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a3f5727bed5f37c11a2691483d3f368c9">sx_api_acl_vlan_group_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_vlan_group_t vlan_group, const sx_acl_id_t acl_id)</td></tr>
<tr class="separator:a3f5727bed5f37c11a2691483d3f368c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91d548d2e1386edee4e5e4fd6c0813a"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#ab91d548d2e1386edee4e5e4fd6c0813a">sx_api_acl_vlan_group_bind_get</a> (const sx_api_handle_t handle, const sx_acl_vlan_group_t vlan_group, const sx_acl_direction_t acl_direction, sx_acl_id_t *acl_id_p)</td></tr>
<tr class="separator:ab91d548d2e1386edee4e5e4fd6c0813a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054337bbc5264f55e6d21c126db7a053"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a054337bbc5264f55e6d21c126db7a053">sx_api_acl_vlan_group_bindings_get</a> (const sx_api_handle_t handle, const sx_acl_vlan_group_t vlan_group, const sx_acl_direction_t acl_direction, sx_acl_id_t *acl_id_p, uint32_t *acl_cnt_p)</td></tr>
<tr class="separator:a054337bbc5264f55e6d21c126db7a053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba4b8d2a4b0e13541c5d2dc33caead5"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#aaba4b8d2a4b0e13541c5d2dc33caead5">sx_api_acl_flex_key_attr_get</a> (const sx_api_handle_t handle, const sx_acl_key_type_t key_handle, sx_acl_flex_key_attr_t *key_attr_p)</td></tr>
<tr class="separator:aaba4b8d2a4b0e13541c5d2dc33caead5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d6ceeb4c13e21075e9e25eb631976b"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a77d6ceeb4c13e21075e9e25eb631976b">sx_api_acl_flex_key_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_key_t *key_list_p, const uint32_t key_count, sx_acl_key_type_t *key_handle_p)</td></tr>
<tr class="separator:a77d6ceeb4c13e21075e9e25eb631976b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92b255d5ce7a24c8527cd55f61d8da1"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#af92b255d5ce7a24c8527cd55f61d8da1">sx_api_acl_flex_key_get</a> (const sx_api_handle_t handle, const sx_acl_key_type_t key_handle, sx_acl_key_t *key_list_p, uint32_t *key_count_p)</td></tr>
<tr class="separator:af92b255d5ce7a24c8527cd55f61d8da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf34d5037f1494d0c146ada9f407840"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#acbf34d5037f1494d0c146ada9f407840">sx_api_acl_flex_rules_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_region_id_t region_id, sx_acl_rule_offset_t *offsets_list_p, const sx_flex_acl_flex_rule_t *rules_list_p, const uint32_t rules_cnt)</td></tr>
<tr class="separator:acbf34d5037f1494d0c146ada9f407840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7820db61cf02508199106ad6b52562af"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a7820db61cf02508199106ad6b52562af">sx_api_acl_flex_rules_get</a> (const sx_api_handle_t handle, const sx_acl_region_id_t region_id, sx_acl_rule_offset_t *offsets_list_p, sx_flex_acl_flex_rule_t *rules_list_p, uint32_t *rules_cnt_p)</td></tr>
<tr class="separator:a7820db61cf02508199106ad6b52562af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5affcc85683c3ceca56d5b2bfdc81a95"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a5affcc85683c3ceca56d5b2bfdc81a95">sx_api_acl_rif_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_rif_id_t rif_id, const sx_acl_id_t acl_id)</td></tr>
<tr class="separator:a5affcc85683c3ceca56d5b2bfdc81a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82890bcca35387bcad58a4cc8be18c4d"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a82890bcca35387bcad58a4cc8be18c4d">sx_api_acl_rif_bind_get</a> (const sx_api_handle_t handle, const sx_rif_id_t rif_id, const sx_acl_direction_t acl_direction, sx_acl_id_t *acl_id_p)</td></tr>
<tr class="separator:a82890bcca35387bcad58a4cc8be18c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80f84cc17dc40e4eab5181a2af25403"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#af80f84cc17dc40e4eab5181a2af25403">sx_api_acl_rif_bindings_get</a> (const sx_api_handle_t handle, const sx_rif_id_t rif_id, const sx_acl_direction_t acl_direction, sx_acl_id_t *acl_id_p, uint32_t *acl_cnt_p)</td></tr>
<tr class="separator:af80f84cc17dc40e4eab5181a2af25403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d75e017d9af517108026cd99b68ece9"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a8d75e017d9af517108026cd99b68ece9">sx_api_acl_group_bind_set</a> (sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_acl_id_t group_id, sx_acl_id_t next_group_id)</td></tr>
<tr class="separator:a8d75e017d9af517108026cd99b68ece9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece9f1a820e5fe724e91b5ae46eac747"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#aece9f1a820e5fe724e91b5ae46eac747">sx_api_acl_group_bind_get</a> (sx_api_handle_t handle, sx_acl_id_t group_id, sx_acl_id_t *group_id_p)</td></tr>
<tr class="separator:aece9f1a820e5fe724e91b5ae46eac747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f2477244a41031b345572131287a04"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#ab8f2477244a41031b345572131287a04">sx_api_acl_port_list_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_acl_port_list_entry_t *port_list_p, const uint32_t port_list_cnt, sx_acl_port_list_id_t *port_list_id_p)</td></tr>
<tr class="separator:ab8f2477244a41031b345572131287a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f73a62d89a23869e37faf3fa8933a60"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a1f73a62d89a23869e37faf3fa8933a60">sx_api_acl_port_list_get</a> (const sx_api_handle_t handle, const sx_acl_port_list_id_t port_list_id, sx_acl_port_list_entry_t *port_list_p, uint32_t *port_list_cnt_p)</td></tr>
<tr class="separator:a1f73a62d89a23869e37faf3fa8933a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93629cae18b47ab7681567547431c5c"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#ab93629cae18b47ab7681567547431c5c">sx_api_acl_region_hw_size_get</a> (const sx_api_handle_t handle, const sx_acl_region_id_t region_id, sx_acl_size_t *region_size_p)</td></tr>
<tr class="separator:ab93629cae18b47ab7681567547431c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2876e1a90b618f87a0eecadba8d2210d"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a2876e1a90b618f87a0eecadba8d2210d">sx_api_acl_custom_bytes_set</a> (sx_api_handle_t handle, sx_access_cmd_t cmd, const sx_acl_custom_bytes_set_attributes_t *custom_bytes_set_attributes, sx_acl_key_t *custom_bytes_set_key_id_p, uint32_t *custom_bytes_set_key_id_cnt_p)</td></tr>
<tr class="separator:a2876e1a90b618f87a0eecadba8d2210d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9321fdeee15f48934a15a97c3f26e35a"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a9321fdeee15f48934a15a97c3f26e35a">sx_api_acl_custom_bytes_get</a> (sx_api_handle_t handle, sx_acl_key_t *custom_bytes_set_key_id_p, sx_acl_custom_bytes_set_attributes_t *custom_bytes_set_attributes_p)</td></tr>
<tr class="separator:a9321fdeee15f48934a15a97c3f26e35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a79809a0f568054e319455fddd622b4"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#a8a79809a0f568054e319455fddd622b4">sx_api_acl_policy_based_ilm_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_acl_pbilm_entry_t *pbilm_entry_p, sx_acl_pbilm_id_t *pbilm_id_p)</td></tr>
<tr class="separator:a8a79809a0f568054e319455fddd622b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb5216bf594357e8c6067bebd65d511"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#adfb5216bf594357e8c6067bebd65d511">sx_api_acl_policy_based_ilm_get</a> (const sx_api_handle_t handle, const sx_acl_pbilm_id_t pbilm_id, sx_acl_pbilm_entry_t *pbilm_entry_p)</td></tr>
<tr class="separator:adfb5216bf594357e8c6067bebd65d511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14ff3de7ade2aa6f5af206fda62fa26"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__acl_8h.html#aa14ff3de7ade2aa6f5af206fda62fa26">sx_api_acl_flex_rules_priority_set</a> (const sx_api_handle_t handle, const sx_acl_region_id_t region_id, const sx_flex_acl_rule_priority_t min_priority, const sx_flex_acl_rule_priority_t max_priority, const int32_t priority_change)</td></tr>
<tr class="separator:aa14ff3de7ade2aa6f5af206fda62fa26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aadfc89bd1ed719720aef093a6d27aef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadfc89bd1ed719720aef093a6d27aef0">&#9670;&nbsp;</a></span>sx_api_acl_log_verbosity_level_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_log_verbosity_level_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>module_verbosity_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>api_verbosity_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the log verbosity level of the ACL MODULE Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- set verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module_verbosity_level</td><td>- ACL module verbosity level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">api_verbosity_level</td><td>- ACL API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a1b19d38aaad622638cc25ffc1e861e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b19d38aaad622638cc25ffc1e861e53">&#9670;&nbsp;</a></span>sx_api_acl_log_verbosity_level_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_log_verbosity_level_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>module_verbosity_level_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>api_verbosity_level_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets the log verbosity level of the ACL MODULE Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- get verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">module_verbosity_level_p</td><td>- ACL module verbosity level </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">api_verbosity_level_p</td><td>- ACL API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="abeff59071f650e6e79d3d84a2466aef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeff59071f650e6e79d3d84a2466aef1">&#9670;&nbsp;</a></span>sx_api_acl_region_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_region_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_key_type_t&#160;</td>
          <td class="paramname"><em>key_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_action_type_t&#160;</td>
          <td class="paramname"><em>action_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_size_t&#160;</td>
          <td class="paramname"><em>region_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_region_id_t *&#160;</td>
          <td class="paramname"><em>region_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to create an ACL Region (rules list). CREATE is used to create a new region and takes as input the key_type and region size. Region ID is returned on successful creation. DESTORY is used to destroy an existing region. It is required that the ACL region is not bound to any ACL rules. EDIT command is used for resizing an existing ACL region. acl_region_id and new size should be provided. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE / DESTROY / EDIT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_type</td><td>- key type used in this ACL. Should be created using sx_api_acl_flex_key_set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action_type</td><td>- This parameter should be set to zero. Irrelevant for current ACL implementation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_size</td><td>- maximum number of rules in this ACL </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">region_id_p</td><td>- ACL region ID as described above</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if no resources are available to create the region </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if the supplied command is unsupported </dd></dl>

</div>
</div>
<a id="a6b49b3d09fd3e0e105abe4927a5c602d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b49b3d09fd3e0e105abe4927a5c602d">&#9670;&nbsp;</a></span>sx_api_acl_region_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_region_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_id_t&#160;</td>
          <td class="paramname"><em>region_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_key_type_t *&#160;</td>
          <td class="paramname"><em>key_type_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_action_type_t *&#160;</td>
          <td class="paramname"><em>action_type_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_size_t *&#160;</td>
          <td class="paramname"><em>region_size_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to get an ACL region's properties. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">region_id</td><td>- ACL region ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key_type_p</td><td>- key type used in this ACL region </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">action_type_p</td><td>- This parameter is ignored. will be set to 0. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">region_size_p</td><td>- maximum number of rules in this ACL region</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd></dl>

</div>
</div>
<a id="a3d3eac6c48940390d6b9fbd8e4c9326c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3eac6c48940390d6b9fbd8e4c9326c">&#9670;&nbsp;</a></span>sx_api_acl_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_type_t&#160;</td>
          <td class="paramname"><em>acl_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_direction_t&#160;</td>
          <td class="paramname"><em>acl_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_group_t *&#160;</td>
          <td class="paramname"><em>acl_region_group_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>acl_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to create a single region ACL. CREATE command is used for creating a new ACL, it will return an ACL ID on success. DESTROY command may be used to destroy the ACL when it is not bound to HW. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE / DESTROY </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_type</td><td>- ACL type of this ACL (only AGNOSTIC type is currently supported) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_direction</td><td>- ACL direction (ingress or egress port or ingress or egress RIF ACL) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_region_group_p</td><td>- ACL region group matching ACL type </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">acl_id_p</td><td>- ACL ID as described above</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if no HW resources are available to create the ACL </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if the supplied command is unsupported </dd></dl>

</div>
</div>
<a id="a21db595169c45f866832b88844cb9f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21db595169c45f866832b88844cb9f1f">&#9670;&nbsp;</a></span>sx_api_acl_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_id_t&#160;</td>
          <td class="paramname"><em>acl_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_type_t *&#160;</td>
          <td class="paramname"><em>acl_type_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_direction_t *&#160;</td>
          <td class="paramname"><em>acl_direction_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_region_group_t *&#160;</td>
          <td class="paramname"><em>acl_region_group_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to get an ACL's attributes. It takes as input an ACL ID and returns the attributes of that ACL i.e. type and a list of attached regions. The length of the regions list depends on the ACL type. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_id</td><td>- ACL ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_type_p</td><td>- ACL type (packet agnostic or packet sensitive) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_direction_p</td><td>- ACL direction </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_region_group_p</td><td>- ACL region group attached to the ACL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd></dl>

</div>
</div>
<a id="aefb22b1a6ad356f324550aea2c94d93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb22b1a6ad356f324550aea2c94d93b">&#9670;&nbsp;</a></span>sx_api_acl_iter_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_iter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_id_t&#160;</td>
          <td class="paramname"><em>acl_id_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_filter_t *&#160;</td>
          <td class="paramname"><em>acl_filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>acl_id_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>acl_id_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets a list of valid ACL IDs. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>GET/GET_NEXT/GET_FIRST </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_id_key</td><td>- ACL ID to use and key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_filter_p</td><td>- Filter to use (not supported yet) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_id_list_p</td><td>- pointer to the list of ACL IDs returned. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">acl_id_cnt_p</td><td>[in] number of entries to retrieve (max 400); [out] retrieved number of entries.</td></tr>
  </table>
  </dd>
</dl>
<p>Input/Output types</p><ul>
<li>Get first - Get a list of first n entries. Cmd should be SX_ACCESS_CMD_GET_FIRST and count should be equal to n. key is irrelevant in this case. Returns number of entries retrieved as count</li>
<li>Get next - Get n entries after a specified key (it does not have to exist). Cmd should be SX_ACCESS_CMD_GETNEXT. count should be equal to n. Returns number of entries retrieved as count</li>
<li>Get - Gets a specific entry. Cmd should be SX_ACCESS_CMD_GET and count should be 1. If input count is 0, then returns a count of ACL Ids as output instead.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any parameter is in error. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_INVALID_HANDLE if handle in invalid </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a4067494175b80b6cc7ea878fa47b4857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4067494175b80b6cc7ea878fa47b4857">&#9670;&nbsp;</a></span>sx_api_acl_attributes_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_attributes_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_id_t&#160;</td>
          <td class="paramname"><em>acl_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_attributes_t&#160;</td>
          <td class="paramname"><em>acl_attributes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to set the attributes of an ACL. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SET </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_id</td><td>- ACL ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_attributes</td><td>- ACL attributes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if if the supplied command is unsupported </dd></dl>

</div>
</div>
<a id="ab21919706a7abb3c770bd32182fad035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21919706a7abb3c770bd32182fad035">&#9670;&nbsp;</a></span>sx_api_acl_attributes_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_attributes_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_id_t&#160;</td>
          <td class="paramname"><em>acl_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_attributes_t *&#160;</td>
          <td class="paramname"><em>acl_attributes_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to retrieve the attributes of a given ACL. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_id</td><td>- ACL ID </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">acl_attributes_p</td><td>- returned ACL attributes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_NULL if any input parameter is invalid </dd></dl>

</div>
</div>
<a id="a2a2813aef5ed638a95b7aec567f96f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2813aef5ed638a95b7aec567f96f65">&#9670;&nbsp;</a></span>sx_api_acl_global_attributes_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_global_attributes_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_global_attributes_t&#160;</td>
          <td class="paramname"><em>global_acl_attributes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to set certain global attributes of the ACL Module. Note that enabling certain functionality may require enabling both the global and individual attributes. Use sx_api_acl_attributes_set for setting individual attributes. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SET </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">global_acl_attributes</td><td>- Global ACL attributes .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if if the supplied command is unsupported </dd></dl>

</div>
</div>
<a id="ac2379f80cae370b31fc6a90be86c7ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2379f80cae370b31fc6a90be86c7ee2">&#9670;&nbsp;</a></span>sx_api_acl_global_attributes_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_global_attributes_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_global_attributes_t *&#160;</td>
          <td class="paramname"><em>global_acl_attributes_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to retrieve the global attributes of the ACL Module. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">global_acl_attributes_p</td><td>- returned global ACL attributes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_NULL if any input parameter is invalid </dd></dl>

</div>
</div>
<a id="acc922fb9cf64214d703db802ca91bf32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc922fb9cf64214d703db802ca91bf32">&#9670;&nbsp;</a></span>sx_api_acl_group_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_group_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_direction_t&#160;</td>
          <td class="paramname"><em>acl_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>acl_id_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>acl_id_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>group_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used for controlling a group of ACLs or in other words cascaded ACL blocks up to the size of SX_ACL_MAX_ACL_GROUP_SIZE. CREATE is used to create a new group with a specified group direction, returns new Group ID SET is used to add a list of ACLs to the group. The ACLs need to be in the same direction as the Group. DESTROY is used to destroy the ACL group. This can be done only if the ACL group is not bound to HW. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE / SET / DESTROY </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_direction</td><td>- ACL group direction. All ACLs in this group must have the same direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_id_list_p</td><td>- ordered list of ACL IDs. Ignored when CMD=CREATE or CMD=DESTROY. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_id_cnt</td><td>- number of elements in the list of ACL IDs. Ignored when CMD=CREATE or CMD=DESTROY. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">group_id</td><td>- ACL group ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if no resources are available to create the new Group </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if if the supplied command is unsupported </dd></dl>

</div>
</div>
<a id="ab7ecf2ea6914f57c8b24fc288b6aec40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ecf2ea6914f57c8b24fc288b6aec40">&#9670;&nbsp;</a></span>sx_api_acl_group_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_group_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_id_t&#160;</td>
          <td class="paramname"><em>group_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_direction_t *&#160;</td>
          <td class="paramname"><em>acl_direction_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>acl_id_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>acl_id_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to get the properties of a provided group id. If the supplied acl_id_count is 0, it just retrieves a count of the ACLs. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_id</td><td>- ACL group ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_direction</td><td>- ACL direction </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_id_list_p</td><td>- list of the group ACL IDs. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">acl_id_cnt_p</td><td>- In - size of the ACL IDs array, OUT - number of valid ACL IDs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd></dl>

</div>
</div>
<a id="ae82c545a8e0bb101aa5c8aa398c109b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82c545a8e0bb101aa5c8aa398c109b3">&#9670;&nbsp;</a></span>sx_api_acl_group_iter_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_group_iter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_id_t&#160;</td>
          <td class="paramname"><em>group_id_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_filter_t *&#160;</td>
          <td class="paramname"><em>acl_filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>acl_id_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>acl_id_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets a list of valid ACL Group Ids. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>GET/GET_NEXT/GET_FIRST </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_id_key</td><td>- ACL Group ID to use as Key for GET and GET_NEXT commands. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_filter_p</td><td>- Filter to use (not supported yet) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_id_list_p</td><td>- pointer to the list of valid ACL Group IDs returned. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">acl_id_cnt_p</td><td>[in] number of entries to retrieve (max 400); [out] retrieved number of entries.</td></tr>
  </table>
  </dd>
</dl>
<p>Input/Output types</p><ul>
<li>Get first - Get a list of first n entries. Cmd should be SX_ACCESS_CMD_GET_FIRST and count should be equal to n. key is irrelevant in this case. Returns number of entries retrieved as count</li>
<li>Get next - Get n entries after a specified key (it does not have to exist). Cmd should be SX_ACCESS_CMD_GETNEXT. count should be equal to n. Returns number of entries retrieved as count</li>
<li>Get - Gets a specific entry. Cmd should be SX_ACCESS_CMD_GET and count should be 1. If input count is 0, then returns a count of ACL Group Ids as output instead.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any parameter is in error. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_INVALID_HANDLE if handle in invalid </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a9f9bc8fab1341d5a0ac492fae0e918af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9bc8fab1341d5a0ac492fae0e918af">&#9670;&nbsp;</a></span>sx_api_acl_group_attributes_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_group_attributes_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_id_t&#160;</td>
          <td class="paramname"><em>acl_group_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_group_attributes_t *&#160;</td>
          <td class="paramname"><em>acl_group_attr_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to set the attributes of an ACL Group. After the ACL group is created by sx_api_acl_group_set API, it is possible to set a priority to the ACL group. The default group priority is FLEX_ACL_GROUP_PRIORITY_DEFAULT. When binding multiple ACL groups to a port, the groups will be ordered according to their priority. Setting priority to a group that is already bound does not take effect on previously bound groups.</p>
<p>Priority attribute limitations: Priority values range is FLEX_ACL_GROUP_PRIORITY_MIN to FLEX_ACL_GROUP_PRIORITY_MAX.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SET </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_group_id</td><td>- ACL Group ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_group_attr_p</td><td>- ACL group attributes pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if if the supplied command is unsupported </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a39aa648b81eb847a72fa90b9d30acf02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39aa648b81eb847a72fa90b9d30acf02">&#9670;&nbsp;</a></span>sx_api_acl_group_attributes_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_group_attributes_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_id_t&#160;</td>
          <td class="paramname"><em>group_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_group_attributes_t *&#160;</td>
          <td class="paramname"><em>acl_group_attr_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to get the attributes of a given ACL Group</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_group_id</td><td>- ACL group ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_group_attr_p</td><td>- ACL group attributes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="af7f1841f9e865b353f5dc6742212b4a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f1841f9e865b353f5dc6742212b4a0">&#9670;&nbsp;</a></span>sx_api_acl_policy_based_switching_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_policy_based_switching_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_pbs_entry_t *&#160;</td>
          <td class="paramname"><em>pbs_entry_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_pbs_id_t *&#160;</td>
          <td class="paramname"><em>pbs_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds/edits/deletes a policy based switching (PBS) set . Policy based switching entry can be later bound to an ACL rule in order to specify destination port/port group (multicast) or send the frame to the router block. Use ADD command to create a PBS entry. Note that this operation may fail if no HW resources are available. PBS entry can be created without ports in order to ensure future HW resource availability. Use ADD_PORTS and DELETE_PORTS to edit an existing PBS entry and add or delete ports. Note that an unicast entry can have only 1 port. Use DELETE command to clear a PBS record (not allowed when this record is in use by ACL rules) Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD / ADD_PORTS / DELETE_PORTS / DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pbs_entry</td><td>- struct for PBS attributes </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pbs_id</td><td>- PBS ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if there are no HW resources for PBS creation </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if the PBS record is in use </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameters is invalid </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if if the supplied command is unsupported </dd>
<dd>
SX_STATUS_INVALID_HANDLE: Invalid Handle </dd></dl>

</div>
</div>
<a id="a1d3627a7131f363300617de31f7edc3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3627a7131f363300617de31f7edc3b">&#9670;&nbsp;</a></span>sx_api_acl_policy_based_switching_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_policy_based_switching_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_pbs_id_t&#160;</td>
          <td class="paramname"><em>pbs_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_pbs_entry_t *&#160;</td>
          <td class="paramname"><em>pbs_entry_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to get a PBS set or to count the number of ports in a PBS set. Note that for GET command the pbs_entry.log_ports should be pre-allocated and the pbs_entry.port_num should be set to the maximum number of ports to retrieve. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- COUNT / GET </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- SWID of the PBS entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pbs_id</td><td>- Port based switching entry ID </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pbs_entry</td><td>- struct for Policy based switching entry attributes. IN - max port number to retrieve. OUT<ul>
<li>actual number of ports retrieved.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if unsupported command is requested </dd>
<dd>
SX_STATUS_INVALID_HANDLE: Invalid Handle </dd></dl>

</div>
</div>
<a id="a1395c6e1613b712e9854f4e982ff8a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1395c6e1613b712e9854f4e982ff8a62">&#9670;&nbsp;</a></span>sx_api_acl_l4_port_range_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_l4_port_range_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_port_range_entry_t *&#160;</td>
          <td class="paramname"><em>l4_port_range_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_port_range_id_t *&#160;</td>
          <td class="paramname"><em>range_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds/edits/deletes a Layer 4 port range comparison set (up to SX_ACL_MAX_PORT_RANGES). Note: SX_ACL_PORT_RANGE_IP_HEADER_BOTH option for IP header type is not supported by Spectrum2, Spectrum3. ADD command is used to create a new range ID from the supplied port range. EDIT command is used to update the port range of the supplied range ID DELETE command is used to clear the range configuration. This will fail if the range is being used by an ACL. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD / EDIT / DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">l4_port_range</td><td>- struct for Layer 4 port range comparison </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">range_id</td><td>- Port range comparison ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO: Message size error </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT: Message size error </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if the supplied command is unsupported </dd>
<dd>
SX_STATUS_INVALID_HANDLE: Invalid Handle </dd></dl>

</div>
</div>
<a id="ad1c17eb4b9b274fddb09c13f1514c289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c17eb4b9b274fddb09c13f1514c289">&#9670;&nbsp;</a></span>sx_api_acl_l4_port_range_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_l4_port_range_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_port_range_id_t&#160;</td>
          <td class="paramname"><em>range_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_port_range_entry_t *&#160;</td>
          <td class="paramname"><em>l4_port_range_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to get the properties of a Layer 4 port range comparison set. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_id</td><td>- Port range comparison ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">l4_port_range</td><td>- struct for Layer 4 port range comparison</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO: Message size error </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT: Message size error </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd>
<dd>
SX_STATUS_INVALID_HANDLE: Invalid Handle </dd></dl>

</div>
</div>
<a id="abb16aaa28349e293f8d768c91f1ebbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb16aaa28349e293f8d768c91f1ebbc7">&#9670;&nbsp;</a></span>sx_api_acl_l4_port_range_iter_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_l4_port_range_iter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_port_range_id_t&#160;</td>
          <td class="paramname"><em>range_id_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_port_range_filter_t *&#160;</td>
          <td class="paramname"><em>range_id_filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_port_range_id_t *&#160;</td>
          <td class="paramname"><em>range_id_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>range_id_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets a list of ACL L4 Port Range IDs Supported devices: Spectrum, Spectrum2, Spectrum3. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>GET/GET_NEXT/GET_FIRST </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_id_key</td><td>-Range ID to use as Key for GET and GET_NEXT commands. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_id_filter_p</td><td>- Filter to use (not supported yet) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">range_id_list_p</td><td>- pointer to the list of Range IDs returned. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">range_id_cnt_p</td><td>[in] number of entries to retrieve (max 16); [out] retrieved number of entries.</td></tr>
  </table>
  </dd>
</dl>
<p>Input/Output types</p><ul>
<li>Get first - Get a list of first n entries. Cmd should be SX_ACCESS_CMD_GET_FIRST and count should be equal to n. key is irrelevant in this case. Returns number of entries retrieved as count</li>
<li>Get next - Get n entries after a specified key (it does not have to exist). Cmd should be SX_ACCESS_CMD_GETNEXT. count should be equal to n. Returns number of entries retrieved as count</li>
<li>Get - Gets a specific entry. Cmd should be SX_ACCESS_CMD_GET and count should be 1. If input count is 0, then returns a count of Range Ids as output instead.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any parameter is in error. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_INVALID_HANDLE if handle in invalid </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a id="a2700b896f2d6045890fd567e2ddf5fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2700b896f2d6045890fd567e2ddf5fa7">&#9670;&nbsp;</a></span>sx_api_acl_range_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_range_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_range_entry_t *&#160;</td>
          <td class="paramname"><em>range_entry_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_port_range_id_t *&#160;</td>
          <td class="paramname"><em>range_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds/edits/deletes a range comparison set (up to SX_ACL_MAX_PORT_RANGES). Supported devices: Spectrum2, Spectrum3. Supported range comparisons: L4 Port, IP length, TTL, Custom Bytes and UTC. Note: SX_ACL_PORT_RANGE_IP_HEADER_BOTH option for IP header type is not supported by Spectrum2, Spectrum3. Note: At a given time no more than 2 Custom Bytes ranges can be used. When ADD command is used the given ranges are written into a group and its ID is returned. When EDIT command is used the given range is written into a group of range_index. When DELETE command is used the given range_index configuration is cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD / EDIT / DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_entry_p</td><td>- struct for range comparison </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">range_id</td><td>- range comparison ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO: Message size error </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT: Message size error </dd>
<dd>
SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if there are no resources for the operation </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if range is in use and cannot be deleted </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if if the supplied command is unsupported </dd>
<dd>
SX_STATUS_INVALID_HANDLE: Invalid Handle </dd></dl>

</div>
</div>
<a id="a4ef4198e307f8593b7d693f363297678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef4198e307f8593b7d693f363297678">&#9670;&nbsp;</a></span>sx_api_acl_range_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_range_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_port_range_id_t&#160;</td>
          <td class="paramname"><em>range_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_range_entry_t *&#160;</td>
          <td class="paramname"><em>range_entry_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to get a range comparison set. Supported devices: Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_id</td><td>- range comparison ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">range_entry_p</td><td>- struct for range comparison</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_ZERO: Message size error </dd>
<dd>
SX_STATUS_MESSAGE_SIZE_EXCEEDS_LIMIT: Message size error </dd>
<dd>
SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd>
<dd>
SX_STATUS_INVALID_HANDLE: Invalid Handle </dd></dl>

</div>
</div>
<a id="a85de9c7f09f1494b0af588835ba5febb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85de9c7f09f1494b0af588835ba5febb">&#9670;&nbsp;</a></span>sx_api_acl_rules_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_rules_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_id_t&#160;</td>
          <td class="paramname"><em>region_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_rule_t *&#160;</td>
          <td class="paramname"><em>rules_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>rules_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>This API is deprecated and will be removed in the future. Please use sx_api_acl_flex_rules_set in its place.</dd></dl>
<p>This function is used for inserting rules into an ACL region. Inserting rules is allowed before and after bind operation. Rule is inserted to an explicit offset, overriding existing rule on that offset. Rules must have the same key type as the ACL region. Supported devices: SwitchX, SwitchX2.</p>
<p>When in 802.1D mode, instead of providing a vid(Vlan ID) in rules[].key.fields.key_type.vid (if present in the key_type) and rules[].mask.fields.key_type.vid (if present) and rules[].action.basic_action.vid (if present), you should provide a bridge_id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SET / DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">region_id</td><td>- ACL region ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rules_p</td><td>- array of structs representing rule content. should be in size of num_of_rules </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_of_rules</td><td>- number of rules to configure (number of elements in the array)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if there is no more space for rules </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if if the supplied command is unsupported </dd></dl>

</div>
</div>
<a id="a8a71f177218829d87debe98d4c399238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a71f177218829d87debe98d4c399238">&#9670;&nbsp;</a></span>sx_api_acl_rules_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_rules_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_id_t&#160;</td>
          <td class="paramname"><em>region_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_rule_offset_t&#160;</td>
          <td class="paramname"><em>start_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_rule_t *&#160;</td>
          <td class="paramname"><em>rules_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rules_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>This API is deprecated and will be removed in the future. Please use sx_api_acl_flex_rules_get in its place.</dd></dl>
<p>This function is used for getting rules of an ACL block.</p>
<p>When in 802.1D mode, instead of receiving a vid(Vlan ID), on rules[].key.fields.key_type.vid, rules[].mask.fields.key_type.vid and rules[].action.basic_action.vid, a bridge_id's are provided. Supported devices: SwitchX, SwitchX2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">region_id</td><td>- ACL region ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_offset</td><td>- Start offset within the region </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rules_p</td><td>- pointer to array of structs representing rule content. should be in size of num_of_rules. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">num_of_rules</td><td>- IN - number of rules to get (number of elements in the array), OUT - number of rules that were actually read from ACL table</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure requested </dd></dl>

</div>
</div>
<a id="aae2d4dde1a42506c57445dedaa2934d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2d4dde1a42506c57445dedaa2934d7">&#9670;&nbsp;</a></span>sx_api_acl_rule_activity_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_rule_activity_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_id_t&#160;</td>
          <td class="paramname"><em>region_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_rule_offset_t&#160;</td>
          <td class="paramname"><em>rule_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean_t *&#160;</td>
          <td class="paramname"><em>activity_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used for getting and/or clearing the activity of a specific rule. If the region is not bound, activity_p is invalid. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ / READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">region_id</td><td>- ACL region ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rule_offset</td><td>- ACL Rule offset within the region </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">activity_p</td><td>- ACL Rule activity</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd></dl>

</div>
</div>
<a id="a022e95843912425808dcbb26058e6c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022e95843912425808dcbb26058e6c5f">&#9670;&nbsp;</a></span>sx_api_acl_rule_block_move_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_rule_block_move_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_id_t&#160;</td>
          <td class="paramname"><em>region_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_rule_offset_t&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_size_t&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_rule_offset_t&#160;</td>
          <td class="paramname"><em>new_block_start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used for moving a block of rules within an ACL region. Moving is allowed before and after ACL bind. Moving a block does not affect search hits, but may override existing rules if such exist on the new block location. Non-valid rules within the block are moved as well. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">region_id</td><td>- ACL region ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_start</td><td>- Rules block start offset within the ACL block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_size</td><td>- Number of rules to move within the block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_block_start</td><td>- New offset of the first rule of the given rules block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd></dl>

</div>
</div>
<a id="a92286cc3f4baf42e3f97ad25c380ffb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92286cc3f4baf42e3f97ad25c380ffb6">&#9670;&nbsp;</a></span>sx_api_acl_port_bind_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_port_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_id_t&#160;</td>
          <td class="paramname"><em>acl_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to bind/unbind an ACL or an ACL group to a port (or LAG). Binding more than one ACL to port may be achieved by using ACL groups. BIND command is used for binding a single ACL or a single ACL group to a port. UNBIND command will clear port binding, even if there are multiple ACL groups which are bound to the port. ADD command can be used to bind additional ACL groups (not ACLs) to the port. In this case the order of group execution is determined by the group priority, set by sx_api_acl_group_attributes_set API. DELETE command can be used to remove an ACL group from multiple ACL groups bound to the port/LAG.</p>
<p>Binding to L2 tunnel ports is supported in this API as well. Spectrum supports NVE port binding by providing the NVE logical port. Spectrum support is a virtual binding to the NVE decap table, where ADD and DELETE commands are not supported. Spectrum2 support for L2 tunnel port binding has API support like any other port binding. In order to bind L2 tunnel port, the appropriate logical port and an ACL group with one of the directions SX_ACL_DIRECTION_TPORT_INGRESS or SX_ACL_DIRECTION_TPORT_EGRESS should be provided.</p>
<p>Note: ADD and DELETE commands support binding of ACL groups only. Binding or adding groups may fail if there are insufficient resources in HW.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- BIND / UNBIND / ADD / DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID to bind </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_id</td><td>- ACL ID given for ACL or ACL group</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if no resources are available for the operation. </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if if the supplied command is unsupported </dd></dl>

</div>
</div>
<a id="a9543188e428bed340f419ed050a47277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9543188e428bed340f419ed050a47277">&#9670;&nbsp;</a></span>sx_api_acl_port_bind_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_port_bind_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_direction_t&#160;</td>
          <td class="paramname"><em>acl_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>acl_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to get the ACL ID of an ACL table or ACL group which is bound to a specific port When multiple groups are bound to a port, this API will return the highest priority group. To retrieve multiple bindings it is suggested to use the sx_api_acl_port_bindings_get API instead.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_direction</td><td>- ingress or egress ACL </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_id_p</td><td>- ACL ID of an ACL or ACL group</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if port is not bound </dd></dl>

</div>
</div>
<a id="a45e4fd8599f3ba687cad34feb6b27d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e4fd8599f3ba687cad34feb6b27d18">&#9670;&nbsp;</a></span>sx_api_acl_port_bindings_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_port_bindings_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_direction_t&#160;</td>
          <td class="paramname"><em>acl_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>acl_id_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>acl_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to retrieve the ACL IDs/groups bound to a specific port. Since multiple groups may bound to a port, the caller of this API is responsible of providing an allocated array for getting the ACL IDs.</p>
<p>If the API is called with acl_id_p parameter set to NULL or *acl_cnt_p set to 0, it will return the actual number of ACL IDs bound to this port. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_direction</td><td>- ACL direction </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">acl_id_p</td><td>- An array of ACL IDs, should be allocated by the caller. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">acl_cnt_p</td><td>- Specifies the maximum amount of ACL IDs to retrieve, and returns the actual number of ACL IDs retrieved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if port is not bound </dd></dl>

</div>
</div>
<a id="a6cfe4cc96f0de7b65e2a46603fc1b78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cfe4cc96f0de7b65e2a46603fc1b78a">&#9670;&nbsp;</a></span>sx_api_acl_vlan_group_map_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_vlan_group_map_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_id_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vlan_id_t *&#160;</td>
          <td class="paramname"><em>vlan_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>vlan_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_vlan_group_t *&#160;</td>
          <td class="paramname"><em>group_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used for controlling mapping of vlans into vlan groups for ACL binding. CREATE command used for creating a new group, will return a free group ID ADD / DELETE commands are used to control mapping of SWID,VID to an existing vlan group DESTROY command is used to free a vlan group resource</p>
<p>Note: This function is only valid when in 802.1Q mode. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE / ADD / DELETE / DESTROY </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- SWID (used only with ADD/DELETE) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">group_id</td><td>- vlan group ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vlan_list</td><td>- a list of vlans to attach to this group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vlan_num</td><td>- number of elements in the vlan list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if no resources are available </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if if the supplied command is unsupported </dd></dl>

</div>
</div>
<a id="a2943e03e105609c89d70865940ddf9c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2943e03e105609c89d70865940ddf9c4">&#9670;&nbsp;</a></span>sx_api_acl_vlan_group_map_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_vlan_group_map_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_id_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_vlan_group_t&#160;</td>
          <td class="paramname"><em>group_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_vlan_id_t *&#160;</td>
          <td class="paramname"><em>vlan_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>vlan_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used for getting the current mapping of vlans into vlan groups for ACL binding. the vlan_list parameter are arrays at the size of vlan_num which is filled by this function. the actual size is then returned as output.</p>
<p>This function is only valid when in 802.1Q mode. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- SWID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_id</td><td>- vlan group ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vlan_list</td><td>- list of vlans which are members in this vlan group (in the given SWID) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vlan_num</td><td>- IN - number of elements allocated in the mapping entries arrays, OUT - number of actual elements found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if 802.1D mode is enabled </dd></dl>

</div>
</div>
<a id="a3f5727bed5f37c11a2691483d3f368c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5727bed5f37c11a2691483d3f368c9">&#9670;&nbsp;</a></span>sx_api_acl_vlan_group_bind_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_vlan_group_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_vlan_group_t&#160;</td>
          <td class="paramname"><em>vlan_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_id_t&#160;</td>
          <td class="paramname"><em>acl_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to bind/unbind an ACL or an ACL group to a VLAN group. Binding more than one ACL to the VLAN group may be achieved by using ACL groups. BIND command is used for binding a single ACL or a single ACL group to a VLAN group. UNBIND command will clear the VLAN group binding, even if there are multiple ACL groups which are bound to the VLAN group. ADD command can be used to bind multiple ACL groups to the VLAN group. In this case the order of group execution is determined by the group priority, set by sx_api_acl_group_attributes_set API. DELETE command can similarly be used to remove an ACL group from multiple ACL groups bound to a VLAN group.</p>
<p>Note: ADD and DELETE commands support binding of ACL groups only. Binding or adding groups may fail if there are insufficient resources in HW.</p>
<p>When in 802.1D mode instead of providing a VLAN group, a bridge_id should be used. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- BIND / UNBIND / ADD / DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vlan_group</td><td>- Vlan Group ID to bind </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_id</td><td>- ACL ID of an ACL or ACL Group</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if no ACL is available to create </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if if the supplied command is unsupported </dd></dl>

</div>
</div>
<a id="ab91d548d2e1386edee4e5e4fd6c0813a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91d548d2e1386edee4e5e4fd6c0813a">&#9670;&nbsp;</a></span>sx_api_acl_vlan_group_bind_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_vlan_group_bind_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_vlan_group_t&#160;</td>
          <td class="paramname"><em>vlan_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_direction_t&#160;</td>
          <td class="paramname"><em>acl_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>acl_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to get the ACL ID of an ACL table or an ACL group which is bound to a specific VLAN group. When multiple ACLs are bound to the VLAN group, this API will only return the one carrying the highest priority. To retrieve multiple bindings it is suggested to use sx_api_acl_vlan_group_bindings_get</p>
<p>When in 802.1D mode, instead of providing a VLAN group, a bridge_id should be used. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vlan_group</td><td>- VLAN Group ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_direction</td><td>- ingress or egress ACL </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_id_p</td><td>- ACL ID of an ACL or ACL Group</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if VLAN group is not bound </dd></dl>

</div>
</div>
<a id="a054337bbc5264f55e6d21c126db7a053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054337bbc5264f55e6d21c126db7a053">&#9670;&nbsp;</a></span>sx_api_acl_vlan_group_bindings_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_vlan_group_bindings_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_vlan_group_t&#160;</td>
          <td class="paramname"><em>vlan_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_direction_t&#160;</td>
          <td class="paramname"><em>acl_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>acl_id_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>acl_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API allows getting ACL IDs bound to a specific VLAN group. Since multiple groups may bound to a VLAN group, the caller of this API is responsible of providing an allocated array for getting the ACL IDs.</p>
<p>If this API is called with acl_id_p parameter set to NULL or *acl_cnt_p set to 0, it will return the actual number of ACL IDs bound to this VLAN group.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vlan_group</td><td>- VLAN group ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_direction</td><td>- ACL direction </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">acl_id_p</td><td>- An array of ACL IDs, should be allocated by the caller. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">acl_cnt_p</td><td>- Specifies the maximum amount of ACL IDs to retrieve, and returns the actual number of ACL IDs retrieved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if port is not bound </dd></dl>

</div>
</div>
<a id="aaba4b8d2a4b0e13541c5d2dc33caead5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba4b8d2a4b0e13541c5d2dc33caead5">&#9670;&nbsp;</a></span>sx_api_acl_flex_key_attr_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_flex_key_attr_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_key_type_t&#160;</td>
          <td class="paramname"><em>key_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_flex_key_attr_t *&#160;</td>
          <td class="paramname"><em>key_attr_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns attributes of the flexible ACL key.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_handle</td><td>- The handle to flexible key </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key_attr_p</td><td>- Key Attributes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR any input parameters is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND the key handle is wrong </dd></dl>

</div>
</div>
<a id="a77d6ceeb4c13e21075e9e25eb631976b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d6ceeb4c13e21075e9e25eb631976b">&#9670;&nbsp;</a></span>sx_api_acl_flex_key_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_flex_key_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_key_t *&#160;</td>
          <td class="paramname"><em>key_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>key_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_key_type_t *&#160;</td>
          <td class="paramname"><em>key_handle_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to create/delete a FLexible ACL Key. A Flex ACL Key is a combination of (maximum 6) predefined 9B Key blocks. The Key Blocks themselves are composed of several filters and the smallest possible set of Key blocks will be chosen by the SCP algorithm that encompasses all the Keys specified by the API. Key creation is pure DB operation. The maximum number of keys is equal to the maximum number of regions.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- The access cmd CREATE/DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_list_p</td><td>- Array of basic key ID's </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_cnt</td><td>- Number of elements in basic key array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key_handle_p</td><td>- The handle to created flexible key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR any input parameters is invalid </dd>
<dd>
SX_STATUS_UNSUPPORTED the command is unsupported </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="af92b255d5ce7a24c8527cd55f61d8da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92b255d5ce7a24c8527cd55f61d8da1">&#9670;&nbsp;</a></span>sx_api_acl_flex_key_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_flex_key_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_key_type_t&#160;</td>
          <td class="paramname"><em>key_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_key_t *&#160;</td>
          <td class="paramname"><em>key_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>key_count_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the list of filters included in the flexible key. The user is responsible for a memory management of the filters list.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_handle</td><td>- The handle to flexible key </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key_list_p</td><td>- Array of basic key ID's </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">key_count_p</td><td>- Number of elements in basic key array on return will contain the actual number of elements copied to the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR any input parameters are invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND the key handle is not found in the DB </dd></dl>

</div>
</div>
<a id="acbf34d5037f1494d0c146ada9f407840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf34d5037f1494d0c146ada9f407840">&#9670;&nbsp;</a></span>sx_api_acl_flex_rules_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_flex_rules_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_id_t&#160;</td>
          <td class="paramname"><em>region_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_rule_offset_t *&#160;</td>
          <td class="paramname"><em>offsets_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_flex_acl_flex_rule_t *&#160;</td>
          <td class="paramname"><em>rules_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>rules_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to added or remove an ACL rule from an ACL region. The user is responsible for memory management - it is necessary to initialize each member of rules_list_p using call to sx_lib_flex_acl_rule_init before calling this API and de-initialize using call to sx_lib_flex_acl_rule_deinit after calling this API. This operation configures the HW if the ACL is bound to a device. The configured rule will override the existing rule if present at the given offset with the new rule. The Keys specified in the rules_list must be a subset of the keys which were used to create the region. The user can also define a custom set of actions for each rule. If an offset in the offsets array crosses the boundaries of the region the function will return an error. Only one of each of the following types of actions will be allowed within the same rule :</p><ul>
<li>SX_FLEX_ACL_ACTION_FORWARD</li>
<li>SX_FLEX_ACL_ACTION_EGRESS_MIRROR or SX_FLEX_ACL_ACTION_MIRROR</li>
<li>SX_FLEX_ACL_ACTION_TRAP or SX_FLEX_ACL_ACTION_TRAP_W_USER_ID Multiple Forward or Multiple Mirror or a combination where there is more than one of any of the above will return PARAM_ERROR Supported devices: Spectrum, Spectrum2, Spectrum3.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- The access command SET/DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">region_id</td><td>- ACL region ID received during region creation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets_list_p</td><td>- Array of rule offsets into region directly associated with the appropriate item in the array of rules </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rules_list_p</td><td>- Array of structures describing the flexible rule content </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rules_cnt</td><td>- Number of elements in array of flexible rule descriptors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS The operation completed successfully </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED The sent command is unsupported </dd>
<dd>
SX_STATUS_PARAM_ERROR Invalid parameter </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND Wrong region ID </dd>
<dd>
SX_STATUS_NO_RESOURCES No more space for rules. Cannot allocate space for all actions </dd></dl>

</div>
</div>
<a id="a7820db61cf02508199106ad6b52562af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7820db61cf02508199106ad6b52562af">&#9670;&nbsp;</a></span>sx_api_acl_flex_rules_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_flex_rules_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_id_t&#160;</td>
          <td class="paramname"><em>region_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_rule_offset_t *&#160;</td>
          <td class="paramname"><em>offsets_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_flex_acl_flex_rule_t *&#160;</td>
          <td class="paramname"><em>rules_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rules_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns a list of rules associated with particular region. The user is responsible for memory management - it is necessary to initialize each member of rules_list_p using call to sx_lib_flex_acl_rule_init before calling this API and de-initialize using call to sx_lib_flex_acl_rule_deinit after calling this API.</p>
<p>If the function is called with rules_list_p parameter set to NULL or *rules_cnt_p set to 0, it will return the actual number of rules set to the region.</p>
<p>If the function is called with key_desc_list_p and action_list_p parameter of each of the rules in rules_list_p set to NULL and offset_list_p array filled with zeroes - it will return the actual number of keys and actions for each valid rule starting from offset 0, as well as the rule's offset in offset list for this rule.</p>
<p>If the function is called with key_desc_list_p and action_list_p parameter of each of the rules in rules_list_p set to NULL, but offset_list_p array is filled with non-zero values - it will return the actual number of keys and actions for each valid rule according to the offset, which is defined in the offset list. In this case the offset list should be filled with offsets of the rules, which are valid.</p>
<p>If the function is called with key_desc_list_p and action_list_p parameter of each of the rules in rules_list_p set to non-NULL, it is assumed that rule structures are allocated for all rules in the list. It also assumed that the offset list is filled with real offsets of the rules in the same order as in the rules list.</p>
<p>When calling the API, the key_desc_count and action_count of each sx_flex_acl_flex_rule_t should contain number of allocated items, on API return these parameters will contain actual number of items. The offset list should contain offsets of valid rules only.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">region_id</td><td>- ACL region ID received during region creation </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">offsets_list_p</td><td>- Array of rule offsets in the region directly associated with the appropriate item in the array of rules </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rules_list_p</td><td>- Array of structures describing the flexible rule content </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rules_cnt</td><td>- Desirable number of elements in array of flexible rule descriptors. Function returns actual count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS The operation completed successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND Wrong region ID </dd>
<dd>
SX_STATUS_PARAM_ERROR Invalid parameter </dd></dl>

</div>
</div>
<a id="a5affcc85683c3ceca56d5b2bfdc81a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5affcc85683c3ceca56d5b2bfdc81a95">&#9670;&nbsp;</a></span>sx_api_acl_rif_bind_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_rif_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_rif_id_t&#160;</td>
          <td class="paramname"><em>rif_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_id_t&#160;</td>
          <td class="paramname"><em>acl_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to bind/unbind an ACL or an ACL group to a RIF. Binding more than one ACL to a RIF may be achieved by using ACL groups. BIND command is used for binding a single ACL or a single ACL group to a RIF. UNBIND command will clear RIF binding, even if there are multiple ACL groups which are bound to the RIF. ADD command can be used to bind additional groups to the RIF. In this case the order of group execution is determined by the group priority, asset by the sx_api_acl_group_attributes_set API. Similarly it is possible to remove an ACL group from multiple ACL groups bound RIF, using the DELETE command.</p>
<p>Note: ADD and DELETE commands support binding of ACL groups only. Binding or adding groups may fail if there are insufficient resources in HW.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- BIND/UNBIND/ADD/DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif_id</td><td>- RIF ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_id</td><td>- ACL or ACL group ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS The operation completed successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND ACL ID or RIF ID not found in DB </dd>
<dd>
SX_STATUS_PARAM_ERROR Invalid parameter </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED the given command is unsupported </dd>
<dd>
SX_STATUS_ERROR The operation cannot be completed </dd></dl>

</div>
</div>
<a id="a82890bcca35387bcad58a4cc8be18c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82890bcca35387bcad58a4cc8be18c4d">&#9670;&nbsp;</a></span>sx_api_acl_rif_bind_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_rif_bind_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_rif_id_t&#160;</td>
          <td class="paramname"><em>rif_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_direction_t&#160;</td>
          <td class="paramname"><em>acl_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>acl_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to get the ACL or ACL group ID that is bound to the RIF. When multiple ACLs are bound to the RIF, this API will only return the one carrying the highest priority. To retrieve multiple bindings it is suggested to use the sx_api_acl_rif_bindings_get API instead.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif_id</td><td>- RIF ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_direction</td><td>- The direction of ACL(ingress/egress) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acl_id_p</td><td>- ACL or ACL group ID that is bound to RIF</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS The operation completed successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND ACL ID or RIF ID not found in DB </dd>
<dd>
SX_STATUS_PARAM_ERROR Invalid parameter </dd></dl>

</div>
</div>
<a id="af80f84cc17dc40e4eab5181a2af25403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80f84cc17dc40e4eab5181a2af25403">&#9670;&nbsp;</a></span>sx_api_acl_rif_bindings_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_rif_bindings_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_rif_id_t&#160;</td>
          <td class="paramname"><em>rif_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_direction_t&#160;</td>
          <td class="paramname"><em>acl_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>acl_id_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>acl_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API allows getting ACL IDs bound to a specific RIF. Since multiple groups may bound to a RIF, the caller of this API is responsible of providing a pre-allocated array for getting the ACL IDs. priority group. If the API is called with acl_id_p parameter set to NULL or *acl_cnt_p set to 0, it will return the actual number of ACL IDs bound to this RIF. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif_id</td><td>- RIF ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acl_direction</td><td>- ACL direction </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">acl_id_p</td><td>- An array of ACL IDs, should be allocated by the caller. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">acl_cnt_p</td><td>- Specifies the maximum amount of ACL IDs to retrieve, and returns the actual number of ACL IDs retrieved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if RIF is not bound </dd></dl>

</div>
</div>
<a id="a8d75e017d9af517108026cd99b68ece9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d75e017d9af517108026cd99b68ece9">&#9670;&nbsp;</a></span>sx_api_acl_group_bind_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_group_bind_set </td>
          <td>(</td>
          <td class="paramtype">sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t&#160;</td>
          <td class="paramname"><em>group_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t&#160;</td>
          <td class="paramname"><em>next_group_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>On ACL module initialization the user can choose the parallel ACL search type. This function is used to support this feature. It links one ACL group to another. Their relation could be described as "one directional linked list" where the second group is next to the first one. Only the head of the list of groups is allowed to be bound to port/VLAN/RIF. The other linked groups will be bound automatically. An attempt to bind explicitly any group but the head will cause an error. In Parallel operation, the action of the ACL do not apply immediately so each ACL rule will act on the original packet.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- The command BIND/UNBIND </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent_group_id</td><td>- The first, parent ACL or ACL group ID that second one will be bound to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_id</td><td>- The second ACL or ACL group ID that will be bound to the first one</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS The operation completed successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND ACL ID not found in DB </dd>
<dd>
SX_STATUS_PARAM_ERROR Invalid parameter </dd></dl>

</div>
</div>
<a id="aece9f1a820e5fe724e91b5ae46eac747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece9f1a820e5fe724e91b5ae46eac747">&#9670;&nbsp;</a></span>sx_api_acl_group_bind_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_group_bind_get </td>
          <td>(</td>
          <td class="paramtype">sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t&#160;</td>
          <td class="paramname"><em>group_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_id_t *&#160;</td>
          <td class="paramname"><em>group_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the next ACL group bound to the given one. Used when the ACL module has been initialized in parallel mode.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_id</td><td>- The first, parent ACL or ACL group ID that second one was be bound to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">group_id_p</td><td>- The ACL or ACL group ID that bound to the parent. In case no such binding exists to the parent, an invalid ACL ID will be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS The operation completed successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND ACL ID not found in DB </dd>
<dd>
SX_STATUS_PARAM_ERROR Invalid parameter </dd></dl>

</div>
</div>
<a id="ab8f2477244a41031b345572131287a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f2477244a41031b345572131287a04">&#9670;&nbsp;</a></span>sx_api_acl_port_list_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_port_list_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_port_list_entry_t *&#160;</td>
          <td class="paramname"><em>port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>port_list_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_port_list_id_t *&#160;</td>
          <td class="paramname"><em>port_list_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function is used to manipulate a port list container Command CREATE creates a new container with the specified list of logical ports and returns its new container ID in port_list_id_p. Command SET replaces the contents of an existing container specified by port_list_id_p, with the specified list of logical ports in port_list_p. Command DESTROY deletes an existing container specified by port_list_id_p. Notes: A port list in use (e.g. by an ACL key) cannot be destroyed or modified A container may contain at most RM_API_ACL_PORT_LIST_MAX logical ports A container may contain only Ethernet logical ports and not LAG ports</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE/SET/DESTROY. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_list_p</td><td>- Specifies or returns the container ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_list_cnt</td><td>- Specifies the list of logical ports for the container </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>port_list_id_p - specifies the id of the port list created/to change</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if specified container ID does not exist. </dd>
<dd>
SX_STATUS_NO_RESOURCES if there are no resources for the operation. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if group is in use and cannot be destroyed. </dd></dl>

</div>
</div>
<a id="a1f73a62d89a23869e37faf3fa8933a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f73a62d89a23869e37faf3fa8933a60">&#9670;&nbsp;</a></span>sx_api_acl_port_list_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_port_list_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_port_list_id_t&#160;</td>
          <td class="paramname"><em>port_list_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_port_list_entry_t *&#160;</td>
          <td class="paramname"><em>port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>port_list_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve information about a port list container specified by port_list_id. Notes: *port_list_cnt should contain the maximum amount of logical ports to retrieve. If port_list_p is NULL, then port_list_p are not retrieved at all. In this case port_list_cnt will contain the actual number if ports in the port list</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_list_id</td><td>- specifies the id of the port list to retrieve </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">port_list_p</td><td>- array of ports to copy into </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">port_list_cnt_p</td><td>- Specifies the maximum amount of logical ports to retrieve, and returns the amount logical ports retrieved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if specified container does not exist, or no more containers. </dd></dl>

</div>
</div>
<a id="ab93629cae18b47ab7681567547431c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93629cae18b47ab7681567547431c5c">&#9670;&nbsp;</a></span>sx_api_acl_region_hw_size_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_region_hw_size_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_id_t&#160;</td>
          <td class="paramname"><em>region_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_size_t *&#160;</td>
          <td class="paramname"><em>region_size_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to get ACL region HW size . Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">region_id</td><td>- ACL region ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">region_size_p</td><td>- The region actual hw size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in DB </dd>
<dd>
SX_STATUS_PARAM_NULL, SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd></dl>

</div>
</div>
<a id="a2876e1a90b618f87a0eecadba8d2210d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2876e1a90b618f87a0eecadba8d2210d">&#9670;&nbsp;</a></span>sx_api_acl_custom_bytes_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_custom_bytes_set </td>
          <td>(</td>
          <td class="paramtype">sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_custom_bytes_set_attributes_t *&#160;</td>
          <td class="paramname"><em>custom_bytes_set_attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_key_t *&#160;</td>
          <td class="paramname"><em>custom_bytes_set_key_id_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>custom_bytes_set_key_id_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API creates and deletes a Custom Bytes Set. Currently only 4-bytes sets are supported. Returned value is a set of key Ids from sx_acl_key_t space. Each byte in the custom bytes set is accessed as a separate ACL key in the FLEX_ACL_CUSTOM_BYTES_START to FLEX_ACL_CYSTOM_BYTE_LAST range. The Custom Bytes extraction points are a predefined set of extraction points based on the protocol of interest. The key ids returned by this API can then be used to create a Flex ACL key.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE/DESTROY/EDIT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">custom_bytes_set_attributes</td><td>- Specifies extraction points data. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>custom_bytes_set_key_id_p - Specifies an array of the custom bytes keys id. For CREATE an array of SDK key ids should be provided. For destroy only the first key is used to identify the destroyed set. For CREATE, if the first key id in list is zero (FLEX_ACL_KEY_INVALID) or any other value not in the interval [FLEX_ACL_KEY_CUSTOM_BYTES_START .. FLEX_ACL_KEY_CUSTOM_BYTES_LAST], the custom bytes set is allocated by SW as the first free one. If the first key id in the list belongs to interval [FLEX_ACL_KEY_CUSTOM_BYTES_START .. FLEX_ACL_KEY_CUSTOM_BYTES_LAST], it identifies the custom bytes set to be allocated. If the custom bytes set is already allocated, SW allocates first free set. As an example, key ids, which were allocated once and destroyed after that, may be submitted to the CREATE operation in order to get the same key ids, in case they are still free. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>custom_bytes_set_key_id_cnt_p - Specifies how many custom bytes are expected by the user. The counter is updated with the smaller of the available number of bytes in allocated set &amp; Requested number of bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if specified container ID does not exist. </dd>
<dd>
SX_STATUS_NO_RESOURCES if there are no resources for the operation. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if group is in use and cannot be destroyed. </dd></dl>

</div>
</div>
<a id="a9321fdeee15f48934a15a97c3f26e35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9321fdeee15f48934a15a97c3f26e35a">&#9670;&nbsp;</a></span>sx_api_acl_custom_bytes_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_custom_bytes_get </td>
          <td>(</td>
          <td class="paramtype">sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_key_t *&#160;</td>
          <td class="paramname"><em>custom_bytes_set_key_id_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_custom_bytes_set_attributes_t *&#160;</td>
          <td class="paramname"><em>custom_bytes_set_attributes_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API returns extraction point parameters of the existing Custom Bytes Set</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">custom_bytes_set_key_id_p</td><td>- Specifies an array of the custom bytes keys id. Only first item in array is provided. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">custom_bytes_key_extraction_point_list_p</td><td>- Specifies extraction points fetched data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if specified container does not exist, or no more containers. </dd></dl>

</div>
</div>
<a id="a8a79809a0f568054e319455fddd622b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a79809a0f568054e319455fddd622b4">&#9670;&nbsp;</a></span>sx_api_acl_policy_based_ilm_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_policy_based_ilm_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_pbilm_entry_t *&#160;</td>
          <td class="paramname"><em>pbilm_entry_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_pbilm_id_t *&#160;</td>
          <td class="paramname"><em>pbilm_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds/edits/deletes a policy based ILM (PBILM). Policy based ILM entry can be later bound to an ACL rule in order to specify a mpls ecmp that will encapsulate the packet with mpls labels and send it to RIF. It can also send the frame to IP or ILM lookup. Use CREATE to create a PBILM entry, which can be changed when needed by SET. Note that these operations may fail if no HW resources are available. Use DESTROY to remove the PBILM. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE / SET / DESTROY </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pbilm_entry</td><td>- struct for PBILM attributes </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pbilm_id</td><td>- Port range comparison ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL or SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if element is not found in DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if there are no HW resources for PBILM creation </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if the PBILM record is in use </dd>
<dd>
SX_STATUS_SXD_RETURNED_NON_ZERO in case of HW failure </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if if the supplied command is unsupported </dd>
<dd>
SX_STATUS_INVALID_HANDLE: Invalid Handle </dd></dl>

</div>
</div>
<a id="adfb5216bf594357e8c6067bebd65d511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb5216bf594357e8c6067bebd65d511">&#9670;&nbsp;</a></span>sx_api_acl_policy_based_ilm_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_policy_based_ilm_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_pbilm_id_t&#160;</td>
          <td class="paramname"><em>pbilm_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_acl_pbilm_entry_t *&#160;</td>
          <td class="paramname"><em>pbilm_entry_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to get a PBILM set or to count ports of a PBILM set. The user should ensure that the pbilm_entry is preallocated with the maximum number of ports to be retrieved. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pbilm_id</td><td>- Policy based ILM entry ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pbilm_entry</td><td>- struct for Policy ILM</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_NULL or SX_STATUS_PARAM_ERROR if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if if the supplied command is unsupported </dd>
<dd>
SX_STATUS_INVALID_HANDLE: Invalid Handle </dd></dl>

</div>
</div>
<a id="aa14ff3de7ade2aa6f5af206fda62fa26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14ff3de7ade2aa6f5af206fda62fa26">&#9670;&nbsp;</a></span>sx_api_acl_flex_rules_priority_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_acl_flex_rules_priority_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_acl_region_id_t&#160;</td>
          <td class="paramname"><em>region_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_flex_acl_rule_priority_t&#160;</td>
          <td class="paramname"><em>min_priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_flex_acl_rule_priority_t&#160;</td>
          <td class="paramname"><em>max_priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>priority_change</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used for updating a set of priorities, in the range [min_priority, max_priority] to priority + priority_change. Limitation: The priority can be changed only if there is no other rules between min priority + change to max priority + change (and the opposite if the priority_change &lt; 0 ) Supported devices: Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">region_id</td><td>- ACL region ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_priority</td><td>- Minimum priority in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_priority</td><td>- - Maximum priority in the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority_change</td><td>- The offset by which the priority should be changed (can be positive/negative)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR or SX_STATUS_PARAM_EXCEEDS_RANGE if any input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ACL element is not found in DB </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 30 2020 12:08:33 for Mellanox SwitchX SDK API Guide by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
