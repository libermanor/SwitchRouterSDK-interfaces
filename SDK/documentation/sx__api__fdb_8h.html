<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mellanox SwitchX SDK API Guide: sdk/sx_api_fdb.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mellanox SwitchX SDK API Guide
   &#160;<span id="projectnumber">4.4.2044-042</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_243a4ba6b4f893d71afbb5a3e90552fa.html">sdk</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sx_api_fdb.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="sx__api__fdb_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa402a02c1b476045b0bdbfaf4d9e466f"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#aa402a02c1b476045b0bdbfaf4d9e466f">sx_api_fdb_log_verbosity_level_set</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)</td></tr>
<tr class="separator:aa402a02c1b476045b0bdbfaf4d9e466f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69328504a7116dc2db6b42b18b13b16"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#af69328504a7116dc2db6b42b18b13b16">sx_api_fdb_log_verbosity_level_get</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)</td></tr>
<tr class="separator:af69328504a7116dc2db6b42b18b13b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac719da53d4e58dc48ffc21dfce3460"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#acac719da53d4e58dc48ffc21dfce3460">sx_api_fdb_age_time_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_age_time_t age_time)</td></tr>
<tr class="separator:acac719da53d4e58dc48ffc21dfce3460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4396ebb8d79d5757b3f2df8b4ff3dd51"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a4396ebb8d79d5757b3f2df8b4ff3dd51">sx_api_fdb_age_time_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, sx_fdb_age_time_t *age_time_p)</td></tr>
<tr class="separator:a4396ebb8d79d5757b3f2df8b4ff3dd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c85bf694d723fc41318b9f41f801e8a"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a0c85bf694d723fc41318b9f41f801e8a">sx_api_fdb_poll_set</a> (const sx_api_handle_t handle, const sx_swid_t swid)</td></tr>
<tr class="separator:a0c85bf694d723fc41318b9f41f801e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc878a321456849b437245a3889fa2d"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a0fc878a321456849b437245a3889fa2d">sx_api_fdb_polling_interval_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_polling_interval_t interval)</td></tr>
<tr class="separator:a0fc878a321456849b437245a3889fa2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cad0c84e98f74c17ff84e111689b3b"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a53cad0c84e98f74c17ff84e111689b3b">sx_api_fdb_polling_interval_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, sx_fdb_polling_interval_t *interval)</td></tr>
<tr class="separator:a53cad0c84e98f74c17ff84e111689b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463c7cb7c07a29ccba6f1bd5c56fc723"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a463c7cb7c07a29ccba6f1bd5c56fc723">sx_api_fdb_uc_mac_addr_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, sx_fdb_uc_mac_addr_params_t *mac_list_p, uint32_t *data_cnt_p)</td></tr>
<tr class="separator:a463c7cb7c07a29ccba6f1bd5c56fc723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d08fd9a8c2e68d0857b5ae986b5cf5"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ab9d08fd9a8c2e68d0857b5ae986b5cf5">sx_api_fdb_uc_mac_addr_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_access_cmd_t cmd, const sx_fdb_uc_mac_entry_type_t mac_type, const sx_fdb_uc_mac_addr_params_t *key_p, const sx_fdb_uc_key_filter_t *key_filter_p, sx_fdb_uc_mac_addr_params_t *mac_list_p, uint32_t *data_cnt_p)</td></tr>
<tr class="separator:ab9d08fd9a8c2e68d0857b5ae986b5cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa216c40f7212a34ff4f48cdd514b7142"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#aa216c40f7212a34ff4f48cdd514b7142">sx_api_fdb_uc_count_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, uint32_t *data_cnt_p)</td></tr>
<tr class="separator:aa216c40f7212a34ff4f48cdd514b7142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac844669ce5b39ebd0c54403b2ef31207"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ac844669ce5b39ebd0c54403b2ef31207">sx_api_fdb_uc_port_count_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, uint32_t *data_cnt_p)</td></tr>
<tr class="separator:ac844669ce5b39ebd0c54403b2ef31207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5e069db7cd02240336f1ddd556e507"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a3c5e069db7cd02240336f1ddd556e507">sx_api_fdb_uc_fid_count_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, uint32_t *data_cnt_p)</td></tr>
<tr class="separator:a3c5e069db7cd02240336f1ddd556e507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7780abaea19956b6bd7a6738e81e5867"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a7780abaea19956b6bd7a6738e81e5867">sx_api_fdb_uc_limit_port_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const uint32_t limit)</td></tr>
<tr class="separator:a7780abaea19956b6bd7a6738e81e5867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8649abe905403e7facd2edcad0f896a1"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a8649abe905403e7facd2edcad0f896a1">sx_api_fdb_uc_limit_port_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, uint32_t *limit_p)</td></tr>
<tr class="separator:a8649abe905403e7facd2edcad0f896a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e82f33acfac26987e66dd53dee91c38"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a8e82f33acfac26987e66dd53dee91c38">sx_api_fdb_uc_limit_fid_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_fid_t fid, const uint32_t limit)</td></tr>
<tr class="separator:a8e82f33acfac26987e66dd53dee91c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760a24322ae990cad9789b7a579053db"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a760a24322ae990cad9789b7a579053db">sx_api_fdb_uc_limit_fid_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, uint32_t *limit_p)</td></tr>
<tr class="separator:a760a24322ae990cad9789b7a579053db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5444b9e90b307936d49fe0c70232cc9"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ab5444b9e90b307936d49fe0c70232cc9">sx_api_fdb_mc_mac_addr_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_vid_t vid, const sx_mac_addr_t group_addr, const sx_port_log_id_t *log_port_list_p, const uint32_t port_cnt)</td></tr>
<tr class="separator:ab5444b9e90b307936d49fe0c70232cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3640c0c7f4b5fb0112a6342872835131"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a3640c0c7f4b5fb0112a6342872835131">sx_api_fdb_mc_mac_addr_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid, const sx_mac_addr_t group_addr, sx_port_log_id_t *log_port_list_p, uint32_t *port_cnt_p)</td></tr>
<tr class="separator:a3640c0c7f4b5fb0112a6342872835131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfd50615d6d2455cec6ed2bb3305430"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a3bfd50615d6d2455cec6ed2bb3305430">sx_api_fdb_mc_mac_addr_iter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_fdb_mc_mac_key_t *key_p, const sx_fdb_mc_mac_filter_t *filter_p, sx_fdb_mc_mac_key_t *key_list_p, uint32_t *key_cnt_p)</td></tr>
<tr class="separator:a3bfd50615d6d2455cec6ed2bb3305430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d816e7ed1c5915fb626d016831516a"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a03d816e7ed1c5915fb626d016831516a">sx_api_fdb_mc_mac_addr_group_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_fdb_mac_key_t *group_key, const sx_fdb_mac_data_t *data)</td></tr>
<tr class="separator:a03d816e7ed1c5915fb626d016831516a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0c86ed51f1cd28c7ab51a8d49d6723"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a5d0c86ed51f1cd28c7ab51a8d49d6723">sx_api_fdb_mc_mac_addr_group_get</a> (const sx_api_handle_t handle, const sx_fdb_mac_key_t *group_key, sx_fdb_mac_data_t *data_p)</td></tr>
<tr class="separator:a5d0c86ed51f1cd28c7ab51a8d49d6723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34497b9f8df08f526c513c62c696c062"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a34497b9f8df08f526c513c62c696c062">sx_api_fdb_mc_mac_addr_group_iter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_fdb_mac_key_t *key_p, const sx_fdb_mc_key_filter_t *filter_p, sx_fdb_mac_key_t *key_list_p, uint32_t *key_cnt_p)</td></tr>
<tr class="separator:a34497b9f8df08f526c513c62c696c062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af975d298e288b3700edb6bfa46ffe9e6"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#af975d298e288b3700edb6bfa46ffe9e6">sx_api_fdb_uc_flush_all_set</a> (const sx_api_handle_t handle, const sx_swid_t swid)</td></tr>
<tr class="separator:af975d298e288b3700edb6bfa46ffe9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607d3e59f86ea3030361a4d3ab11ca77"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a607d3e59f86ea3030361a4d3ab11ca77">sx_api_fdb_uc_flush_port_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port)</td></tr>
<tr class="separator:a607d3e59f86ea3030361a4d3ab11ca77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bda072a8e6c293b7ee18e106a0818f"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#af9bda072a8e6c293b7ee18e106a0818f">sx_api_fdb_uc_flush_fid_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid)</td></tr>
<tr class="separator:af9bda072a8e6c293b7ee18e106a0818f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa694899ca36680e9e2fb2205831ed0fd"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#aa694899ca36680e9e2fb2205831ed0fd">sx_api_fdb_uc_flush_port_fid_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_fid_t fid)</td></tr>
<tr class="separator:aa694899ca36680e9e2fb2205831ed0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6731a3466288aedc59c1235f43c6820a"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a6731a3466288aedc59c1235f43c6820a">sx_api_fdb_mc_flush_all_set</a> (const sx_api_handle_t handle, const sx_swid_t swid)</td></tr>
<tr class="separator:a6731a3466288aedc59c1235f43c6820a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c1584e35170d3ed04ef20904a57f6c"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a39c1584e35170d3ed04ef20904a57f6c">sx_api_fdb_mc_flush_fid_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid)</td></tr>
<tr class="separator:a39c1584e35170d3ed04ef20904a57f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41aa22e9e12b1044e0a3463dc2535ed"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ae41aa22e9e12b1044e0a3463dc2535ed">sx_api_fdb_flush_by_type_set</a> (const sx_api_handle_t handle, const sx_flush_data_t *flush_data_p)</td></tr>
<tr class="separator:ae41aa22e9e12b1044e0a3463dc2535ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad302ac34a0c93901a8d71c84b830d55e"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ad302ac34a0c93901a8d71c84b830d55e">sx_api_fdb_fid_vlan_member_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_fid_t fid, const sx_vid_t vid)</td></tr>
<tr class="separator:ad302ac34a0c93901a8d71c84b830d55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3021865defc7ae5cb76077cb049f910d"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a3021865defc7ae5cb76077cb049f910d">sx_api_fdb_global_params_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_learn_ctrl_t learn_ctrl)</td></tr>
<tr class="separator:a3021865defc7ae5cb76077cb049f910d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fc5b5032c1b055937b1b04f66def7c"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#af2fc5b5032c1b055937b1b04f66def7c">sx_api_fdb_global_params_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, sx_fdb_learn_ctrl_t *learn_ctrl_p)</td></tr>
<tr class="separator:af2fc5b5032c1b055937b1b04f66def7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6adc069af59af3c899204cd18445b3f"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#af6adc069af59af3c899204cd18445b3f">sx_api_fdb_learn_mode_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_learn_mode_t learn_mode)</td></tr>
<tr class="separator:af6adc069af59af3c899204cd18445b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b53851631fac831d1933522be461403"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a9b53851631fac831d1933522be461403">sx_api_fdb_learn_mode_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, sx_fdb_learn_mode_t *learn_mode_p)</td></tr>
<tr class="separator:a9b53851631fac831d1933522be461403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e05ca88a0204e228589ca94d28af1c"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ad8e05ca88a0204e228589ca94d28af1c">sx_api_fdb_fid_learn_mode_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, const sx_fdb_learn_mode_t learn_mode)</td></tr>
<tr class="separator:ad8e05ca88a0204e228589ca94d28af1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1228d15d780af59066b92bf2efd7d352"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a1228d15d780af59066b92bf2efd7d352">sx_api_fdb_fid_learn_mode_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, sx_fdb_learn_mode_t *learn_mode_p)</td></tr>
<tr class="separator:a1228d15d780af59066b92bf2efd7d352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635769f9f07a0d564566ca33ebd44884"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a635769f9f07a0d564566ca33ebd44884">sx_api_fdb_port_learn_mode_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const sx_fdb_learn_mode_t learn_mode)</td></tr>
<tr class="separator:a635769f9f07a0d564566ca33ebd44884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5156883cfdbcb9f246df889d0199eb7"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#aa5156883cfdbcb9f246df889d0199eb7">sx_api_fdb_port_learn_mode_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_fdb_learn_mode_t *learn_mode_p)</td></tr>
<tr class="separator:aa5156883cfdbcb9f246df889d0199eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a51dd7cd5a11e51b9be1f25e62fd40a"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a5a51dd7cd5a11e51b9be1f25e62fd40a">sx_api_fdb_notify_params_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fdb_notify_params_t *notify_params_p)</td></tr>
<tr class="separator:a5a51dd7cd5a11e51b9be1f25e62fd40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b8c246f21456f227318b5626ca7740"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ab2b8c246f21456f227318b5626ca7740">sx_api_fdb_notify_params_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, sx_fdb_notify_params_t *notify_params_p)</td></tr>
<tr class="separator:ab2b8c246f21456f227318b5626ca7740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65caac4b1e478dbce337541fdfc046f2"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a65caac4b1e478dbce337541fdfc046f2">sx_api_fdb_flood_control_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_fid_t fid, sx_flood_control_type_t type, const uint16_t ports_count, const sx_port_log_id_t *const ports_list)</td></tr>
<tr class="separator:a65caac4b1e478dbce337541fdfc046f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a311aebd885a87ff66de06c452130dd"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a5a311aebd885a87ff66de06c452130dd">sx_api_fdb_flood_control_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, sx_flood_control_type_t type, uint16_t *const ports_count, sx_port_log_id_t *const ports_list)</td></tr>
<tr class="separator:a5a311aebd885a87ff66de06c452130dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34894776eebc52ed74b59b941f701c91"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a34894776eebc52ed74b59b941f701c91">sx_api_fdb_flood_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, const sx_fid_t fid, const sx_mc_container_id_t flood_vector)</td></tr>
<tr class="separator:a34894776eebc52ed74b59b941f701c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23226433dadbbc949fc0a19f0254d7f9"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a23226433dadbbc949fc0a19f0254d7f9">sx_api_fdb_flood_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_fid_t fid, sx_mc_container_id_t *flood_vector)</td></tr>
<tr class="separator:a23226433dadbbc949fc0a19f0254d7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4a16b9c750215270a1ffceb7d6e150"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a2e4a16b9c750215270a1ffceb7d6e150">sx_api_fdb_flood_counter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_swid_t swid, sx_flood_counters_t *const counters)</td></tr>
<tr class="separator:a2e4a16b9c750215270a1ffceb7d6e150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61db615ac875ccce214e8600b86102c8"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a61db615ac875ccce214e8600b86102c8">sx_api_fdb_flood_counter_clear</a> (const sx_api_handle_t handle, const sx_swid_t swid)</td></tr>
<tr class="separator:a61db615ac875ccce214e8600b86102c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea4fb90301561b60d52be1e6d3d8199"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a0ea4fb90301561b60d52be1e6d3d8199">sx_api_fdb_src_miss_protect_set</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, const boolean_t enable)</td></tr>
<tr class="separator:a0ea4fb90301561b60d52be1e6d3d8199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af051ad00c09fa031624b47294adad966"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#af051ad00c09fa031624b47294adad966">sx_api_fdb_src_miss_protect_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, boolean_t *enable_p)</td></tr>
<tr class="separator:af051ad00c09fa031624b47294adad966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4e77d99c8a0a02143ab1b20d5a3fd3"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#aca4e77d99c8a0a02143ab1b20d5a3fd3">sx_api_fdb_src_miss_protect_drop_cntr_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd)</td></tr>
<tr class="separator:aca4e77d99c8a0a02143ab1b20d5a3fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c57302e48355d01d518cad33e1bf12d"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a2c57302e48355d01d518cad33e1bf12d">sx_api_fdb_src_miss_protect_drop_cntr_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, uint64_t *dropped_pkts_cntr_p)</td></tr>
<tr class="separator:a2c57302e48355d01d518cad33e1bf12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b07aa93f3c82a70b451f5b9306b3f9b"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a1b07aa93f3c82a70b451f5b9306b3f9b">sx_api_fdb_igmpv3_state_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_fid_t fid, const sx_fdb_igmpv3_state_t fdb_igmpv3_snooping_state)</td></tr>
<tr class="separator:a1b07aa93f3c82a70b451f5b9306b3f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79b1f2b30e2c8b8065a1320779f84b7"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ae79b1f2b30e2c8b8065a1320779f84b7">sx_api_fdb_igmpv3_state_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_fid_t fid, sx_fdb_igmpv3_state_t *fdb_igmpv3_snooping_state)</td></tr>
<tr class="separator:ae79b1f2b30e2c8b8065a1320779f84b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b80e9d9cfc0540cf8be791423b881bf"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a7b80e9d9cfc0540cf8be791423b881bf">sx_api_fdb_mc_ip_addr_group_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_fdb_mc_ip_key_t *mc_fdb_mc_ip_key, const sx_fdb_mc_ip_action_t *fdb_mc_ip_action)</td></tr>
<tr class="separator:a7b80e9d9cfc0540cf8be791423b881bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f28553045fe213b7c86c9911a80689"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a29f28553045fe213b7c86c9911a80689">sx_api_fdb_mc_ip_addr_group_get</a> (const sx_api_handle_t handle, const sx_fdb_mc_ip_key_t *mc_fdb_mc_ip_key, sx_fdb_mc_ip_action_t *fdb_mc_ip_action_p)</td></tr>
<tr class="separator:a29f28553045fe213b7c86c9911a80689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dbdec283dc6a0e6aed34463e413eb7"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a68dbdec283dc6a0e6aed34463e413eb7">sx_api_fdb_mc_ip_addr_group_counter_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_fdb_mc_ip_key_t *key_p, const sx_flow_counter_id_t counter_id)</td></tr>
<tr class="separator:a68dbdec283dc6a0e6aed34463e413eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4027bd56cbce6623ad155c5ccd3bc11"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#af4027bd56cbce6623ad155c5ccd3bc11">sx_api_fdb_mc_ip_addr_group_counter_bind_get</a> (const sx_api_handle_t handle, const sx_fdb_mc_ip_key_t *key_p, sx_flow_counter_id_t *counter_id_p)</td></tr>
<tr class="separator:af4027bd56cbce6623ad155c5ccd3bc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01cc956ac3e9e78a816f368f8104bdf7"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a01cc956ac3e9e78a816f368f8104bdf7">sx_api_fdb_unreg_mc_flood_mode_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid, const sx_fdb_unreg_flood_mode_t urmc_flood_mode)</td></tr>
<tr class="separator:a01cc956ac3e9e78a816f368f8104bdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b47bb878ed5f257c93073c8e6a43f5"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a38b47bb878ed5f257c93073c8e6a43f5">sx_api_fdb_unreg_mc_flood_mode_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid, sx_fdb_unreg_flood_mode_t *urmc_flood_mode_p)</td></tr>
<tr class="separator:a38b47bb878ed5f257c93073c8e6a43f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e3fbbd807c02081b6153fc89f759b3"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ac8e3fbbd807c02081b6153fc89f759b3">sx_api_fdb_unreg_mc_flood_ports_set</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid, const sx_port_log_id_t *log_port_list_p, const uint32_t port_cnt)</td></tr>
<tr class="separator:ac8e3fbbd807c02081b6153fc89f759b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94842d07542f4a835f7f9d78f1d9043"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#ae94842d07542f4a835f7f9d78f1d9043">sx_api_fdb_unreg_mc_flood_ports_get</a> (const sx_api_handle_t handle, const sx_swid_t swid, const sx_vid_t vid, sx_port_log_id_t *log_port_list_p, uint32_t *port_cnt_p)</td></tr>
<tr class="separator:ae94842d07542f4a835f7f9d78f1d9043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b27e71cead1426a4b4156ce55a00019"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a1b27e71cead1426a4b4156ce55a00019">sx_api_fdb_unreg_mc_flood_mode_ext_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t access_cmd, const sx_fdb_unreg_mc_flood_key_t *flood_key_p, const sx_fdb_unreg_mc_flood_attr_t *flood_attr_p)</td></tr>
<tr class="separator:a1b27e71cead1426a4b4156ce55a00019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a111b8385e37f2ece7d25aff3eb7a33"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a7a111b8385e37f2ece7d25aff3eb7a33">sx_api_fdb_unreg_mc_flood_mode_ext_get</a> (const sx_api_handle_t handle, const sx_fdb_unreg_mc_flood_key_t *flood_key_p, sx_fdb_unreg_mc_flood_attr_t *const flood_attr_p)</td></tr>
<tr class="separator:a7a111b8385e37f2ece7d25aff3eb7a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceaf604e293b33ce3ad10f9f078999df"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#aceaf604e293b33ce3ad10f9f078999df">sx_api_fdb_mc_ip_addr_group_activity_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_fdb_mc_ip_key_t *key_p, boolean_t *activity_p)</td></tr>
<tr class="separator:aceaf604e293b33ce3ad10f9f078999df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f9f71e8e65e1a8687080d39d4119ef"><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__fdb_8h.html#a49f9f71e8e65e1a8687080d39d4119ef">sx_api_fdb_mc_ip_addr_group_activity_notify</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_fdb_mc_ip_filter_t *filter_p)</td></tr>
<tr class="separator:a49f9f71e8e65e1a8687080d39d4119ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa402a02c1b476045b0bdbfaf4d9e466f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa402a02c1b476045b0bdbfaf4d9e466f">&#9670;&nbsp;</a></span>sx_api_fdb_log_verbosity_level_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_log_verbosity_level_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>module_verbosity_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>api_verbosity_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API sets the log verbosity level of FDB MODULE.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- set verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module_verbosity_level</td><td>- FDB module verbosity level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">api_verbosity_level</td><td>- FDB API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="af69328504a7116dc2db6b42b18b13b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69328504a7116dc2db6b42b18b13b16">&#9670;&nbsp;</a></span>sx_api_fdb_log_verbosity_level_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_log_verbosity_level_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>module_verbosity_level_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>api_verbosity_level_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API gets the log verbosity level of FDB MODULE.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- get verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">module_verbosity_level_p</td><td>- FDB module verbosity level </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">api_verbosity_level_p</td><td>- FDB API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="acac719da53d4e58dc48ffc21dfce3460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac719da53d4e58dc48ffc21dfce3460">&#9670;&nbsp;</a></span>sx_api_fdb_age_time_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_age_time_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_age_time_t&#160;</td>
          <td class="paramname"><em>age_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the FDB age time in seconds. Age time is the time after which automatically learned addresses are deleted from the FDB if they receive no traffic.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- switch ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">age_time</td><td>- time in seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a4396ebb8d79d5757b3f2df8b4ff3dd51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4396ebb8d79d5757b3f2df8b4ff3dd51">&#9670;&nbsp;</a></span>sx_api_fdb_age_time_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_age_time_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_age_time_t *&#160;</td>
          <td class="paramname"><em>age_time_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function retrieves the FDB age time in seconds. Age time is the time after which automatically learned addresses are deleted from the FDB if they receive no traffic.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- switch ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">age_time_p</td><td>- time in seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a0c85bf694d723fc41318b9f41f801e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c85bf694d723fc41318b9f41f801e8a">&#9670;&nbsp;</a></span>sx_api_fdb_poll_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_poll_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function triggers an FDB poll for MAC entries notifications.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if there is no place in the jobs buffer </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a0fc878a321456849b437245a3889fa2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc878a321456849b437245a3889fa2d">&#9670;&nbsp;</a></span>sx_api_fdb_polling_interval_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_polling_interval_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_polling_interval_t&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the FDB polling interval at 0.1 second granularity.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interval</td><td>- polling interval in 0.1 seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a53cad0c84e98f74c17ff84e111689b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53cad0c84e98f74c17ff84e111689b3b">&#9670;&nbsp;</a></span>sx_api_fdb_polling_interval_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_polling_interval_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_polling_interval_t *&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets the FDB polling interval in 0.1 second granularity.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interval</td><td>- polling interval in 0.1 seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd></dl>

</div>
</div>
<a id="a463c7cb7c07a29ccba6f1bd5c56fc723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463c7cb7c07a29ccba6f1bd5c56fc723">&#9670;&nbsp;</a></span>sx_api_fdb_uc_mac_addr_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_mac_addr_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_uc_mac_addr_params_t *&#160;</td>
          <td class="paramname"><em>mac_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds/deletes UC MAC and UC LAG MAC entries to/from the FDB. In case the operation fails on one or more entries, an error is returned, mac_list_p stores those entries, and their quantity is stored in data_cnt. If the operation is completed successfully, SUCCESS is returned, and data_cnt_p and mac_list_p are not changed.</p>
<p>Note: If sx_fdb_uc_mac_addr_params_t.dest_type is SX_FDB_UC_MAC_ADDR_DEST_TYPE_ECMP_NEXT_HOP_CONTAINER:</p><ul>
<li>sx_fdb_uc_mac_addr_params_t.entry_type cannot be SX_FDB_UC_AGEABLE;</li>
<li>sx_fdb_uc_mac_addr_params_t.dest.ecmp should point to the ECMP that is one of the next types: SX_ECMP_CONTAINER_TYPE_NVE_FLOOD or SX_ECMP_CONTAINER_TYPE_NVE_MC.</li>
</ul>
<p>Note for Spectrum: When FDB learning is enabled, a packet with the SMAC=MAC1 triggers flushing of remote UC tunnel-ECMP FDB MAC1 entry from the FDB and a roaming MAC1 event is sent to CPU, next packets that have DMAC=MAC1 will be flooded.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<p>When in 802.1D mode, instead of providing a VID(VLAN ID) or FID(filtering ID) in mac_list_p-&gt;fid_vid, you should provide a bridge_id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mac_list_p</td><td>- list of MAC record parameters. For deletion, entry_type is DONT_CARE </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data_cnt_p</td><td>- number of MAC records to ADD/DELETE</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_NO_RESOURCES if the FDB hash bin is full </dd>
<dd>
SX_STATUS_PARAM_NULL if any of the parameters is NULL </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="ab9d08fd9a8c2e68d0857b5ae986b5cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d08fd9a8c2e68d0857b5ae986b5cf5">&#9670;&nbsp;</a></span>sx_api_fdb_uc_mac_addr_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_mac_addr_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_uc_mac_entry_type_t&#160;</td>
          <td class="paramname"><em>mac_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_uc_mac_addr_params_t *&#160;</td>
          <td class="paramname"><em>key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_uc_key_filter_t *&#160;</td>
          <td class="paramname"><em>key_filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_uc_mac_addr_params_t *&#160;</td>
          <td class="paramname"><em>mac_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function reads MAC entries from the SW FDB table, which is an exact copy of the HW DB on any device. The output supports up to SX_FDB_MAX_GET_ENTRIES entries which defaults to 64.</p>
<p>The function can receive three types of input:</p>
<ul>
<li>1) get information for the supplied MAC + vlan - you should insert MAC+VLAN data in the key variable. data_cnt_p should be equal to 1. cmd should be SX_ACCESS_CMD_GET.</li>
<li>2) get a list of first n&lt;=64 MACs - data_cnt_p should be equal to n. mac_type is the type you want to receive. key_filter_p is the filter type(s) you want to filter the results by. cmd should be SX_ACCESS_CMD_GET_FIRST.</li>
<li>3) get a list of n&lt;=64 MACs which comes after certain MAC record (it does not have to exist) you should insert MAC+VLAN data in the key variable. data_cnt_p should be equal to n. mac_type is the type you want to receive. key_filter_p is the filter type(s) you want to filter the results by. cmd should be SX_ACCESS_CMD_GETNEXT.</li>
</ul>
<p>mac_list_p returns the records info and their quantity in data_cnt_p for all types of requests.</p>
<p>When in 802.1D mode, instead of providing a vid(Vlan ID) or fid (filtering ID) in key_p-&gt;fid_vid and fid in key_filter_p-&gt;fid, you should provide a bridge_id. bridge_id's will be stored in mac_list_p-&gt;fid_vid</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET, GETNEXT, GET_FIRST </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mac_type</td><td>- static, dynamic, all </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_p</td><td>- MAC entry with information for search (MAC+FID) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_filter_p</td><td>- filter types used on the mac_list_p - FID/MAC/logical port </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mac_list_p</td><td>- pointer to list </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data_cnt_p</td><td>- number of entries to retrieve, also retrieved number of entries</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="aa216c40f7212a34ff4f48cdd514b7142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa216c40f7212a34ff4f48cdd514b7142">&#9670;&nbsp;</a></span>sx_api_fdb_uc_count_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_count_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function counts all MAC entries in the SW FDB table (static and dynamic).</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data_cnt_p</td><td>- retrieved number of entries</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if the SWID is out of range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="ac844669ce5b39ebd0c54403b2ef31207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac844669ce5b39ebd0c54403b2ef31207">&#9670;&nbsp;</a></span>sx_api_fdb_uc_port_count_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_port_count_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function retrieves the number of MACs learned on a port (static and dynamic).</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data_cnt_p</td><td>- retrieved number of entries</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE for an invalid handle </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd></dl>

</div>
</div>
<a id="a3c5e069db7cd02240336f1ddd556e507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5e069db7cd02240336f1ddd556e507">&#9670;&nbsp;</a></span>sx_api_fdb_uc_fid_count_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_fid_count_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function retrieves the number of MACs learned on an FID (static and dynamic).</p>
<p>When in 802.1D mode, instead of providing a fid (filtering ID), you should provide a bridge_id.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering DB ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data_cnt_p</td><td>- retrieved number of entries</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE for an invalid handle </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if FID/SWID is out of range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a7780abaea19956b6bd7a6738e81e5867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7780abaea19956b6bd7a6738e81e5867">&#9670;&nbsp;</a></span>sx_api_fdb_uc_limit_port_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_limit_port_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets/removes the limit on the amount of dynamic MACs learned on a port.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SET/DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limit</td><td>- when SET command is used, this is the new limit to set (between 0 and SX_FDB_MAX_ENTRIES)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE for an invalid handle </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if limit is out of range </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a8649abe905403e7facd2edcad0f896a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8649abe905403e7facd2edcad0f896a1">&#9670;&nbsp;</a></span>sx_api_fdb_uc_limit_port_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_limit_port_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>limit_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function retrieves the maximum amount of dynamic MACs that can be learned on a port.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">limit_p</td><td>- the result limit. If no limit is set SX_FDB_MAX_ENTRIES is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE for an invalid handle </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a8e82f33acfac26987e66dd53dee91c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e82f33acfac26987e66dd53dee91c38">&#9670;&nbsp;</a></span>sx_api_fdb_uc_limit_fid_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_limit_fid_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets/removes the limit on the amount of dynamic MACs learned on FID.</p>
<p>When in 802.1D mode, instead of providing a fid (filtering ID), you should provide a bridge_id.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SET/DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering DB ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limit</td><td>- when SET command is used, this is the new limit to set (between 0 and SX_FDB_MAX_ENTRIES)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE for an invalid handle </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if the SWID/FID/limit is out of range </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a760a24322ae990cad9789b7a579053db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760a24322ae990cad9789b7a579053db">&#9670;&nbsp;</a></span>sx_api_fdb_uc_limit_fid_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_limit_fid_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>limit_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function retrieves the maximum amount of dynamic MACs that can be learned on an FID.</p>
<p>When in 802.1D mode, instead of providing a fid (filtering ID), you should provide a bridge_id.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering DB ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">limit_p</td><td>- the result limit. If no limit is set SX_FDB_MAX_ENTRIES is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE for an invalid handle </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if the FID/SWID is out of range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="ab5444b9e90b307936d49fe0c70232cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5444b9e90b307936d49fe0c70232cc9">&#9670;&nbsp;</a></span>sx_api_fdb_mc_mac_addr_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_mac_addr_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mac_addr_t&#160;</td>
          <td class="paramname"><em>group_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>log_port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>port_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> This function adds/deletes MC MAC entries from the FDB.
 Note: MC entries cannot be created and associated with ports at the same time
 i.e the MC entry needs to be created first before adding ports.

 Note: The log_port_list_p list should not contain the
        logical port items which are specified as an Ethernet
        port and which are members of a LAG port at same time.

 When the ADD command is requested this function performs the following:
 - checks a MC group is already created and returns FAILURE if yes;
 - allocates and stores the MC group;

 When the DELETE command is requested this function performs the following
 for each leaf device:
 - deletes MC FDB records
 - deletes FDB MC ID records
 - deletes SPGT record
 - deletes MC group from MCDB
 - returns pgi into the pool

 When ADD_PORTS command is used this function performs
 the following:
 - updates the MC DB for adding logical ports and LAG ports
 - for each leaf device:
   - retrieves a list of LAG-member logical ports from LAGLib for
     all LAG logical ports which belong to this MC group
   - updates the SPGT record for adding the spine, MC members and
     LAGs member ports
   - adds local ports to FDB MC ID records (if FDB look-up
     by MC ID is allowed on leaf devices)

 When DELETE_PORTS command is used this function performs
 the following:
 - updates MC DB for deleting logical ports and LAG ports
 - for each leaf device:
   - updates the SPGT record for deleting requested ports
     (if logical port is a LAG port then all LAG-member logical ports
     are removed);
   - removes local ports from FDB MC ID records
     (if FDB look up by MC ID is allowed on leaf devices)

 When in 802.1D mode, instead of providing a vid (Vlan ID),
 you should provide a bridge_id.

 Supported devices: Spectrum, Spectrum2, Spectrum3.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- add/delete/add port/delete port </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>- filtering DB ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_addr</td><td>- MAC group address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port_list_p</td><td>- a pointer to a port list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_cnt</td><td>- size of port list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS if group_addr is already added </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a3640c0c7f4b5fb0112a6342872835131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3640c0c7f4b5fb0112a6342872835131">&#9670;&nbsp;</a></span>sx_api_fdb_mc_mac_addr_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_mac_addr_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mac_addr_t&#160;</td>
          <td class="paramname"><em>group_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>log_port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>port_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function retrieves MC MAC entries data. User is responsible for memory management of retrieved list. If the log_port_list_p is NULL or port_cnt is 0, the API retrieves the count of MC MAC entries for the vid. NOTE: If LAG ports are being supplied, the log_port_list_p list should contain only LAG-port IDs and not LAG members logical-port IDs.</p>
<p>When in 802.1D mode, instead of providing a vid (Vlan ID), you should provide a bridge_id.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>- filtering DB ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_addr</td><td>- MAC group address </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">log_port_list_p</td><td>- a pointer to a port list </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">port_cnt_p</td><td>- size of port list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a3bfd50615d6d2455cec6ed2bb3305430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bfd50615d6d2455cec6ed2bb3305430">&#9670;&nbsp;</a></span>sx_api_fdb_mc_mac_addr_iter_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_mac_addr_iter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mc_mac_key_t *&#160;</td>
          <td class="paramname"><em>key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mc_mac_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_mc_mac_key_t *&#160;</td>
          <td class="paramname"><em>key_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>key_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function retrieves a list of one or more MC MAC keys (VLAN ID + MC MAC address). When in 802.1D mode, instead of providing a vid (VLAN ID) in key_p-&gt;vid and filter_p-&gt;vid, you should provide a bridge_id. In 802.1D mode, returned bridge_id's will be stored in key_list_p-&gt;vid. The following use case scenarios apply with different input parameters X = don't-care</p><ul>
<li>1) cmd = SX_ACCESS_CMD_GET, swid = valid, key = X, filter = valid/invalid, key_list = X key_cnt = 0: In this case the API will return the total number of MC MAC keys filtered by the filter parameter if present.</li>
<li>2) cmd = SX_ACCESS_CMD_GET, swid = valid, key = valid/invalid, filter = valid/invalid, key_list = valid, key_cnt = 1: The MC MAC key will be returned in the key_list along with a key_cnt of 1 in the following conditions: a) the key exists, a filter is provided and the key matches the filter b) the key exists, no filter is provided An empty list will be returned with key_cnt = 0 in the following conditions: a) the key doesn't exist b) the key exists, a filter is provided and the key doesn't match the filter A non-NULL key_list pointer must be provided in this case.</li>
<li>3) cmd = SX_ACCESS_CMD_GET, swid = valid, key = valid/invalid, filter = valid/invalid, key_list = valid, key_cnt &gt; 1: An key_cnt &gt; 1 will be treated as a key_cnt of 1 and the behavior will be same as the earlier GET use cases.</li>
<li>4) cmd = SX_ACCESS_CMD_GET_FIRST/SX_ACCESS_CMD_GETNEXT, swid = X, key = X, filter = X, key_list = NULL, key_cnt = 0: A zero key_cnt and an empty key_list will be returned.</li>
<li>5) cmd = SX_ACCESS_CMD_GET_FIRST, swid = valid, key = X, filter = valid/invalid, key_list = valid, key_cnt &gt; 0: In this case the API will return a list of MC MAC keys (max key_cnt) starting with first key of the internal DB and matching the filter if present. The input MC MAC key is ignored in this case. A non-NULL key_list pointer must be provided in this case.</li>
<li>6) cmd = SX_ACCESS_CMD_GETNEXT, swid = valid, key = valid/invalid, filter = valid/invalid, key_list = valid, key_cnt &gt; 0: In this case the API will return a list of MC MAC keys (max key_cnt) starting with the next key after the input key and matching the filter if present. A non-NULL key_list pointer must be provided in this case.</li>
</ul>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET/GET_FIRST/GET_NEXT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_p</td><td>- MC MAC key (VLAN ID + MC MAC address) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_p</td><td>- specify a filter parameter </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key_list_p</td><td>- return list of MC MAC keys </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">key_cnt_p</td><td>- [in] number of MC MAC keys to get<ul>
<li>[out] number of MC MAC keys returned</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a03d816e7ed1c5915fb626d016831516a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d816e7ed1c5915fb626d016831516a">&#9670;&nbsp;</a></span>sx_api_fdb_mc_mac_addr_group_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_mac_addr_group_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mac_key_t *&#160;</td>
          <td class="paramname"><em>group_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mac_data_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds/deletes FDB MC MAC entries from/to a Multicast container. Note: The Multicast container should have already been created.</p>
<p>The MC container from the parameter "data" should be one of the following types: SX_MC_CONTAINER_TYPE_BRIDGE_MC or SX_MC_CONTAINER_TYPE_VLAN_UNAWARE. An FDB MC MAC entry can be created only if the FID from the parameter "group_key" is equal to the FID from the attributes of the MC container. For MC containers of the type SX_MC_CONTAINER_TYPE_VLAN_UNAWARE, the FID parity validation is skipped.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_key</td><td>- {fid, mac} key for multicast </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- fdb data including action and MC container ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS if group_addr is already added </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a5d0c86ed51f1cd28c7ab51a8d49d6723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0c86ed51f1cd28c7ab51a8d49d6723">&#9670;&nbsp;</a></span>sx_api_fdb_mc_mac_addr_group_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_mac_addr_group_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mac_key_t *&#160;</td>
          <td class="paramname"><em>group_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_mac_data_t *&#160;</td>
          <td class="paramname"><em>data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets FDB MC MAC entries from a multicast container.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_key</td><td>- {fid, mac} key for multicast </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>- fdb data including action and mc container id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS if group_addr is already added </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a34497b9f8df08f526c513c62c696c062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34497b9f8df08f526c513c62c696c062">&#9670;&nbsp;</a></span>sx_api_fdb_mc_mac_addr_group_iter_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_mac_addr_group_iter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mac_key_t *&#160;</td>
          <td class="paramname"><em>key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mc_key_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_mac_key_t *&#160;</td>
          <td class="paramname"><em>key_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>key_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns a list of one or more FDB MC keys (FID + MC MAC address). The following use case scenarios apply with different input parameters X = don't-care</p><ul>
<li>1) cmd = SX_ACCESS_CMD_GET, key = X, Filter = X, key_list = X, Count =0: In this case the API will return the total number of MACs in the Internal db</li>
<li>2) cmd = SX_ACCESS_CMD_GET, key = valid/invalid, Filter = X, key_list = Valid, Count = 1: In this case the API will check if the specified key exists. if it does the key will be returned in the key_list along with a count of 1. If the key does not exist an empty list will be returned with count = 0</li>
<li>3) cmd = SX_ACCESS_CMD_GET, key = valid, Filter = Valid, key_list = Valid, Count = 1: In this case the API will check if the specified key exists. if it does it will check it against the filter parameter. If the filter matches, the key will be returned in the key_list along with a count of 1. If the key does not exist or the filter does not match an empty list will be returned with count = 0</li>
<li>4) cmd = SX_ACCESS_CMD_GET, key = valid, Filter = Valid/invalid, key_list is Valid, Count &gt; 1: A count &gt;1 will be treated as a count of 1 and the behavior will be same as earlier GET use cases.</li>
<li>5) cmd = SX_ACCESS_CMD_GET_FIRST/SX_ACCESS_CMD_GETNEXT, key = X, Filter = X, key_list = Null, Count =0: For either SX_ACCESS_CMD_GET_FIRST/SX_ACCESS_CMD_GETNEXT a zero count will return an empty list.</li>
<li>6) cmd = SX_ACCESS_CMD_GET_FIRST, key = X, Filter = valid/invalid, key_list = Valid, Count &gt; 0: In this case the API will return the first count MACs starting from the head of the database. The total elements fetched will be returned as the return count. Note: return count may be less than or equal to the requested count. The key is dont-care. If a filter is specified only those MACs that match the filter will be returned. a non-Null return key_list pointer must be provided</li>
<li>7) cmd = SX_ACCESS_CMD_GETNEXT, key = valid/invalid, Filter = valid/invalid, key_list = Valid, Count &gt; 0: In this case the API will return the next set of MACs starting from the next valid MAC after the specified key. The total elements fetched will be returned as the return count. If a filter is specified only those MACs that match the filter will be returned. Note: return count may be less than or equal to the requested count. If no valid next MAC exists in the db (key = end of list, or invalid key specified, or key too large), an empty list will be returned.</li>
</ul>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>: GET/GET_FIRST/GET_NEXT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_p</td><td>: specify a MAC key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_p</td><td>: specify a filter parameter </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key_list_p</td><td>: return list of MAC keys </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data_cnt_p</td><td>: [in] number of MACs to get. : [out] number of MACs returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_NULL if an unexpected NULL parameter was passed. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ERROR general error. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED - if invalid cmd is passed </dd>
<dd>
SX_STATUS_DB_NOT_INITIALIZED - if internal DB is not initialized </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd></dl>

</div>
</div>
<a id="af975d298e288b3700edb6bfa46ffe9e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af975d298e288b3700edb6bfa46ffe9e6">&#9670;&nbsp;</a></span>sx_api_fdb_uc_flush_all_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_flush_all_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function deletes all learned (Dynamic) FDB table entries on a switch partition Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a607d3e59f86ea3030361a4d3ab11ca77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607d3e59f86ea3030361a4d3ab11ca77">&#9670;&nbsp;</a></span>sx_api_fdb_uc_flush_port_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_flush_port_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function deletes the FDB table entries that were learned on a port</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="af9bda072a8e6c293b7ee18e106a0818f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bda072a8e6c293b7ee18e106a0818f">&#9670;&nbsp;</a></span>sx_api_fdb_uc_flush_fid_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_flush_fid_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function deletes all FDB table entries that were learned on a FID.</p>
<p>When in 802.1D mode, instead of providing a fid (filtering ID), you should provide a bridge_id.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering DB ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="aa694899ca36680e9e2fb2205831ed0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa694899ca36680e9e2fb2205831ed0fd">&#9670;&nbsp;</a></span>sx_api_fdb_uc_flush_port_fid_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_uc_flush_port_fid_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function deletes all FDB table entries that were learned on the flushed FID and port.</p>
<p>When in 802.1D mode, instead of providing a fid (filtering ID), you should provide a bridge_id.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering DB ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a6731a3466288aedc59c1235f43c6820a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6731a3466288aedc59c1235f43c6820a">&#9670;&nbsp;</a></span>sx_api_fdb_mc_flush_all_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_flush_all_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function deletes all FDB MC tables on a switch partition.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a39c1584e35170d3ed04ef20904a57f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c1584e35170d3ed04ef20904a57f6c">&#9670;&nbsp;</a></span>sx_api_fdb_mc_flush_fid_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_flush_fid_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function deletes all FDB MC table entries that were learned on the flushed FID on a switch partition.</p>
<p>When in 802.1D mode, instead of providing a fid (filtering ID), you should provide a bridge_id.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering DB ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="ae41aa22e9e12b1044e0a3463dc2535ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41aa22e9e12b1044e0a3463dc2535ed">&#9670;&nbsp;</a></span>sx_api_fdb_flush_by_type_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_flush_by_type_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_flush_data_t *&#160;</td>
          <td class="paramname"><em>flush_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function deletes dynamic FDB table entries according to the provided flush type and parameters.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush_data</td><td>- struct including the type and</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_ERROR if a parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="ad302ac34a0c93901a8d71c84b830d55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad302ac34a0c93901a8d71c84b830d55e">&#9670;&nbsp;</a></span>sx_api_fdb_fid_vlan_member_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_fid_vlan_member_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>vid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function maps VLANs to filtering databases for shared VLAN learning (SVL) between VLANs. If independent VLAN learning is desired, a single VLAN should be mapped to a single FID.</p>
<p>When cmd=add This function adds FID to VID mapping record to the selected SWID. When cmd=delete This function deletes FID to VID mapping record from the selected SWID. The DEF_FID value is added to the corresponding VLAN.</p>
<p>NOTE: This API performs FDB flushing by FID before FID to VID mapping changing</p>
<p>NOTE: Only independent learning is supported in the current release.</p>
<p>This function is only valid when in 802.1Q mode.</p>
<p>Supported devices: Not supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- add/delete </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering DB ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>- VLAN ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a3021865defc7ae5cb76077cb049f910d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3021865defc7ae5cb76077cb049f910d">&#9670;&nbsp;</a></span>sx_api_fdb_global_params_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_global_params_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_learn_ctrl_t&#160;</td>
          <td class="paramname"><em>learn_ctrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API sets the SWID's learning parameters into the system's DB.</p>
<p>NOTE: Only independent learning is supported in the current release.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- switch (virtual) ID (whose parameters to set) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">learn_ctrl</td><td>- is independent/shared learning and is roaming enabled/disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="af2fc5b5032c1b055937b1b04f66def7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2fc5b5032c1b055937b1b04f66def7c">&#9670;&nbsp;</a></span>sx_api_fdb_global_params_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_global_params_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_learn_ctrl_t *&#160;</td>
          <td class="paramname"><em>learn_ctrl_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API retrieves the SWID's learning parameters from the system's DB.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- Switch (virtual) ID (whose parameters to retrieve) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">learn_ctrl_p</td><td>- Is independent/shared learning and is roaming enabled/disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="af6adc069af59af3c899204cd18445b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6adc069af59af3c899204cd18445b3f">&#9670;&nbsp;</a></span>sx_api_fdb_learn_mode_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_learn_mode_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_learn_mode_t&#160;</td>
          <td class="paramname"><em>learn_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the FDB learning mode per SWID affecting all ports and VLANs in the SWID.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">learn_mode</td><td>- new SWID's learn mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a9b53851631fac831d1933522be461403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b53851631fac831d1933522be461403">&#9670;&nbsp;</a></span>sx_api_fdb_learn_mode_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_learn_mode_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_learn_mode_t *&#160;</td>
          <td class="paramname"><em>learn_mode_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function retrieves the FDB learning mode per SWID.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">learn_mode_p</td><td>- SWID's learn mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="ad8e05ca88a0204e228589ca94d28af1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e05ca88a0204e228589ca94d28af1c">&#9670;&nbsp;</a></span>sx_api_fdb_fid_learn_mode_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_fid_learn_mode_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_learn_mode_t&#160;</td>
          <td class="paramname"><em>learn_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets a FID's learn mode.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- switch ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering identifier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">learn_mode</td><td>- FID's learn mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a1228d15d780af59066b92bf2efd7d352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1228d15d780af59066b92bf2efd7d352">&#9670;&nbsp;</a></span>sx_api_fdb_fid_learn_mode_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_fid_learn_mode_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_learn_mode_t *&#160;</td>
          <td class="paramname"><em>learn_mode_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets a fid's learn mode.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- switch ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- filtering identifier </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">learn_mode_p</td><td>- FID's learn mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a635769f9f07a0d564566ca33ebd44884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635769f9f07a0d564566ca33ebd44884">&#9670;&nbsp;</a></span>sx_api_fdb_port_learn_mode_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_port_learn_mode_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_learn_mode_t&#160;</td>
          <td class="paramname"><em>learn_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets a port's learn mode. Note: The learn mode on the NVE port can be configured only when there is connected NVE tunnel in the system. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">learn_mode</td><td>- port's learn mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="aa5156883cfdbcb9f246df889d0199eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5156883cfdbcb9f246df889d0199eb7">&#9670;&nbsp;</a></span>sx_api_fdb_port_learn_mode_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_port_learn_mode_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_learn_mode_t *&#160;</td>
          <td class="paramname"><em>learn_mode_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets a port's learn mode. Note: The API can retrieve the learn mode on the NVE port only when there is a connected NVE tunnel in the system. Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">learn_mode_p</td><td>- port's learn mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a5a51dd7cd5a11e51b9be1f25e62fd40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a51dd7cd5a11e51b9be1f25e62fd40a">&#9670;&nbsp;</a></span>sx_api_fdb_notify_params_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_notify_params_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_notify_params_t *&#160;</td>
          <td class="paramname"><em>notify_params_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets FDB notify parameters. Note: Only takes effect when controlled learn mode is set.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notify_params_p</td><td>- new notify parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if any parameters are NULL </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="ab2b8c246f21456f227318b5626ca7740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b8c246f21456f227318b5626ca7740">&#9670;&nbsp;</a></span>sx_api_fdb_notify_params_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_notify_params_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_notify_params_t *&#160;</td>
          <td class="paramname"><em>notify_params_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets FDB notify parameters.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">notify_params_p</td><td>- swid's notify params</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if any parameters are NULL </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a65caac4b1e478dbce337541fdfc046f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65caac4b1e478dbce337541fdfc046f2">&#9670;&nbsp;</a></span>sx_api_fdb_flood_control_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_flood_control_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_flood_control_type_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>ports_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t *const&#160;</td>
          <td class="paramname"><em>ports_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to block ports from flooding a selected FID.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD_PORTS / DELETE_PORTS / REPLACE_ALL_PORTS/ DELETE_ALL_PORTS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- VID/Bridge-ID to apply blocking list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>- Flood type to control. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ports_count</td><td>- Number of items in ports_list array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ports_list</td><td>- Array of logical ports</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_NULL if ports_list is null and cmd is not DELETE_ALL_PORTS </dd>
<dd>
SX_STATUS_UNSUPPORTED if flood control is not supported in the switch. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED Command provided is not supported. </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a5a311aebd885a87ff66de06c452130dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a311aebd885a87ff66de06c452130dd">&#9670;&nbsp;</a></span>sx_api_fdb_flood_control_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_flood_control_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_flood_control_type_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>ports_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_log_id_t *const&#160;</td>
          <td class="paramname"><em>ports_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to retrieve the list of ports on which flood control has been enabled. ports count will be updated with the number of blocked ports. If ports_count is non-zero user is responsible for memory management of ports_list. Passing ports_count as 0 and ports_list NULL will return a count of the number of ports.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- VID/Bridge-ID to apply blocking list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>- Flood type to control. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ports_count</td><td>- Number of items in ports_list array, returned as number of actual ports </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ports_list</td><td>- (Optional) Array to fill blocked logical ports.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_UNSUPPORTED if flood control is not supported in the switch. </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_NULL if ports_list is null and ports_count is not 0. </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a34894776eebc52ed74b59b941f701c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34894776eebc52ed74b59b941f701c91">&#9670;&nbsp;</a></span>sx_api_fdb_flood_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_flood_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_container_id_t&#160;</td>
          <td class="paramname"><em>flood_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to manage flood control for tunnels. Configuration from this API extends config from sx_api_fdb_flood_control_set for tunnel support. For each tunnel, you can add or remove flooding for specified bridge.</p>
<p>The MC container that is pointed by the parameter "flood_vector" should be one of the following types: SX_MC_CONTAINER_TYPE_NVE_FLOOD, SX_MC_CONTAINER_TYPE_BRIDGE_MC or SX_MC_CONTAINER_TYPE_VLAN_UNAWARE. An MC container of the type SX_MC_CONTAINER_TYPE_NVE_FLOOD or SX_MC_CONTAINER_TYPE_BRIDGE_MC container can be bound to a given FID only if the FID is equal to a FID from the attributes of the MC container. On Spectrum, an MC container of the SX_MC_CONTAINER_TYPE_BRIDGE_MC type cannot be used as a tunnel flood vector if sx_tunnel_nve_general_params_t.mc_ecmp_enabled != sx_tunnel_nve_general_params_t.flood_ecmp_enabled. For MC containers of the type SX_MC_CONTAINER_TYPE_VLAN_UNAWARE, the FID parity validation is skipped.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD / DELETE / SET </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- FID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flood_vector</td><td>- MC container, which next-hops are used to flood through a tunnel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if tunnel or fid doesn't exists. </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_BOUND if fid already have flooding vector. </dd>
<dd>
SX_STATUS_UNSUPPORTED if api is not supported for this device </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a23226433dadbbc949fc0a19f0254d7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23226433dadbbc949fc0a19f0254d7f9">&#9670;&nbsp;</a></span>sx_api_fdb_flood_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_flood_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_mc_container_id_t *&#160;</td>
          <td class="paramname"><em>flood_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to get flood control settings for a tunnel.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- FID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flood_vector</td><td>- MC Container contains Flooding vector as ecmp object for head replication.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if flooding vector not set </dd>
<dd>
SX_STATUS_UNSUPPORTED if api is not supported for this device </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a2e4a16b9c750215270a1ffceb7d6e150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4a16b9c750215270a1ffceb7d6e150">&#9670;&nbsp;</a></span>sx_api_fdb_flood_counter_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_flood_counter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_flood_counters_t *const&#160;</td>
          <td class="paramname"><em>counters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to retrieve flooding counters of the switch.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ / READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counters</td><td>- counters struct to store retrieved information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_UNSUPPORTED if flooding counters are not supported in the switch. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command provided is not supported. </dd>
<dd>
SX_STATUS_PARAM_NULL if counters are null </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a61db615ac875ccce214e8600b86102c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61db615ac875ccce214e8600b86102c8">&#9670;&nbsp;</a></span>sx_api_fdb_flood_counter_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_flood_counter_clear </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to clear flooding counters of the switch.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_UNSUPPORTED if flooding counters are not supported in the switch. </dd></dl>

</div>
</div>
<a id="a0ea4fb90301561b60d52be1e6d3d8199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea4fb90301561b60d52be1e6d3d8199">&#9670;&nbsp;</a></span>sx_api_fdb_src_miss_protect_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_src_miss_protect_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boolean_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets port's fdb miss protect mode. When enabled the SMAC will not be learned and will be used for a security lookup on the packet.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3. Note: Not supported in 802.1D mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>- enable/disable smac miss port protection</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd></dl>

</div>
</div>
<a id="af051ad00c09fa031624b47294adad966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af051ad00c09fa031624b47294adad966">&#9670;&nbsp;</a></span>sx_api_fdb_src_miss_protect_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_src_miss_protect_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean_t *&#160;</td>
          <td class="paramname"><em>enable_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets port's fdb smac miss protect mode status.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3. Note: Not supported in 802.1D mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- logical port number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">enable_p</td><td>- port's fdb miss protection status</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd></dl>

</div>
</div>
<a id="aca4e77d99c8a0a02143ab1b20d5a3fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4e77d99c8a0a02143ab1b20d5a3fd3">&#9670;&nbsp;</a></span>sx_api_fdb_src_miss_protect_drop_cntr_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_src_miss_protect_drop_cntr_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets up FDB source miss protection drop counter.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3. Note: Not supported in 802.1D mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE / DESTROY</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd></dl>

</div>
</div>
<a id="a2c57302e48355d01d518cad33e1bf12d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c57302e48355d01d518cad33e1bf12d">&#9670;&nbsp;</a></span>sx_api_fdb_src_miss_protect_drop_cntr_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_src_miss_protect_drop_cntr_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>dropped_pkts_cntr_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets the FDB source miss protection drop counters.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3. Note: Not supported in 802.1D mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET / GET_AND_CLEAR </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dropped_pkts_cntr_p</td><td>- port's source miss protection packet counter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_PARAM_NULL if dropped_pkts_cntr is null </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd></dl>

</div>
</div>
<a id="a1b07aa93f3c82a70b451f5b9306b3f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b07aa93f3c82a70b451f5b9306b3f9b">&#9670;&nbsp;</a></span>sx_api_fdb_igmpv3_state_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_igmpv3_state_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_igmpv3_state_t&#160;</td>
          <td class="paramname"><em>fdb_igmpv3_snooping_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the IGMP v3 state.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SET </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- FID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fdb_igmpv3_snooping_state</td><td>- Enable/ Disable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS if snooping is already enabled </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="ae79b1f2b30e2c8b8065a1320779f84b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79b1f2b30e2c8b8065a1320779f84b7">&#9670;&nbsp;</a></span>sx_api_fdb_igmpv3_state_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_igmpv3_state_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fid_t&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_igmpv3_state_t *&#160;</td>
          <td class="paramname"><em>fdb_igmpv3_snooping_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets the IGMP v3 state.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- Command: Get </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fid</td><td>- FID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fdb_igmpv3_snooping_state-</td><td>Pointer to the IGMP v3 state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a7b80e9d9cfc0540cf8be791423b881bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b80e9d9cfc0540cf8be791423b881bf">&#9670;&nbsp;</a></span>sx_api_fdb_mc_ip_addr_group_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_ip_addr_group_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mc_ip_key_t *&#160;</td>
          <td class="paramname"><em>mc_fdb_mc_ip_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mc_ip_action_t *&#160;</td>
          <td class="paramname"><em>fdb_mc_ip_action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets MC IP entries using a multicast container as the destination.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- add/delete/delete_all </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_fdb_mc_ip_key</td><td>- Structure containing the FID/SIP/DIP of the MC group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fdb_mc_ip_action</td><td>- Structure containing Action/Container ID/Trap</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS if group_addr is already added </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a29f28553045fe213b7c86c9911a80689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f28553045fe213b7c86c9911a80689">&#9670;&nbsp;</a></span>sx_api_fdb_mc_ip_addr_group_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_ip_addr_group_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mc_ip_key_t *&#160;</td>
          <td class="paramname"><em>mc_fdb_mc_ip_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_mc_ip_action_t *&#160;</td>
          <td class="paramname"><em>fdb_mc_ip_action_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets MC IP entries using a multicast container as destination.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_fdb_mc_ip_key</td><td>- Structure containing the FID/SIP/DIP of the MC group </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fdb_mc_ip_action</td><td>- Pointer to a Structure containing Action/Container ID/Trap</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a68dbdec283dc6a0e6aed34463e413eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68dbdec283dc6a0e6aed34463e413eb7">&#9670;&nbsp;</a></span>sx_api_fdb_mc_ip_addr_group_counter_bind_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_ip_addr_group_counter_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mc_ip_key_t *&#160;</td>
          <td class="paramname"><em>key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_flow_counter_id_t&#160;</td>
          <td class="paramname"><em>counter_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function binds a flow counter to a MC IP Entry.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_p</td><td>- Structure containing the FID/SIP/DIP of the MC group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- Command: SX_ACCESS_CMD_ADD/SX_ACCESS_CMD_DELETE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_id</td><td>- counter id for adding/deleting from rule</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_EXISTS if counter is already added </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="af4027bd56cbce6623ad155c5ccd3bc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4027bd56cbce6623ad155c5ccd3bc11">&#9670;&nbsp;</a></span>sx_api_fdb_mc_ip_addr_group_counter_bind_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_ip_addr_group_counter_bind_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mc_ip_key_t *&#160;</td>
          <td class="paramname"><em>key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_flow_counter_id_t *&#160;</td>
          <td class="paramname"><em>counter_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets the flow counter bound to an MC IP entry.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_p</td><td>- Structure containing the FID/SIP/DIP of the MC group </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter_id</td><td>- Pointer to counter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_INVALID_HANDLE if a NULL handle is received </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if a parameter exceeds its range </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_NO_MEMORY if memory allocation fails </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a01cc956ac3e9e78a816f368f8104bdf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01cc956ac3e9e78a816f368f8104bdf7">&#9670;&nbsp;</a></span>sx_api_fdb_unreg_mc_flood_mode_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_unreg_mc_flood_mode_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_unreg_flood_mode_t&#160;</td>
          <td class="paramname"><em>urmc_flood_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API sets the unregistered MC flood mode.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<p>When in 802.1D mode, instead of providing a vid(Vlan ID), you should provide a bridge_id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>- VLAN ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">urmc_flood_mode</td><td>- unregistered MC flood mode: FLOOD / PRUNE</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a38b47bb878ed5f257c93073c8e6a43f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b47bb878ed5f257c93073c8e6a43f5">&#9670;&nbsp;</a></span>sx_api_fdb_unreg_mc_flood_mode_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_unreg_mc_flood_mode_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_unreg_flood_mode_t *&#160;</td>
          <td class="paramname"><em>urmc_flood_mode_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API retrieves the unregistered MC flood mode.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<p>When in 802.1D mode, instead of providing a vid(Vlan ID), you should provide a bridge_id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>- VLAN ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">urmc_flood_mode_p</td><td>- unregister MC flood mode: FLOOD / PRUNE</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="ac8e3fbbd807c02081b6153fc89f759b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e3fbbd807c02081b6153fc89f759b3">&#9670;&nbsp;</a></span>sx_api_fdb_unreg_mc_flood_ports_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_unreg_mc_flood_ports_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>log_port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>port_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API sets unregistered MC flood ports.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<p>When in 802.1D mode, instead of providing a vid(Vlan ID), you should provide a bridge_id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>- VLAN ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port_list_p</td><td>- a pointer to a port list, port may be a LAG or physical port </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_cnt</td><td>- size of port list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="ae94842d07542f4a835f7f9d78f1d9043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94842d07542f4a835f7f9d78f1d9043">&#9670;&nbsp;</a></span>sx_api_fdb_unreg_mc_flood_ports_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_unreg_mc_flood_ports_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_swid_t&#160;</td>
          <td class="paramname"><em>swid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vid_t&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_port_log_id_t *&#160;</td>
          <td class="paramname"><em>log_port_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>port_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API retrieves unregistered MC flood ports.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<p>When in 802.1D mode, instead of providing a vid(Vlan ID), you should provide a bridge_id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swid</td><td>- virtual switch partition ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>- VLAN ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">log_port_list_p</td><td>- a pointer to a port list, port can be LAG or physical port </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">port_cnt_p</td><td>- size of port list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if requested element is not found in the DB </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a1b27e71cead1426a4b4156ce55a00019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b27e71cead1426a4b4156ce55a00019">&#9670;&nbsp;</a></span>sx_api_fdb_unreg_mc_flood_mode_ext_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_unreg_mc_flood_mode_ext_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>access_cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_unreg_mc_flood_key_t *&#160;</td>
          <td class="paramname"><em>flood_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_unreg_mc_flood_attr_t *&#160;</td>
          <td class="paramname"><em>flood_attr_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to set the flooding mode and vector for Unregistered MC traffic IPv4 and IPv6 Specifically :</p><ul>
<li>Flooding mode : FLOOD / PRUNE</li>
<li>In Prune mode, user should provide MC container with list of ports. In Flood mode , the flood_vector is N/A. SDK will set the flooding vector to be all VLAN members.</li>
</ul>
<p>NOTE: In order to have separate vector for Unregistered MC traffic IPv6 the following flag should be enabled sdk_init_params.fdb_params.unreg_mc_ipv6_flood_en as part of SDK init. Else the Broadcast vector will apply for Unregistered MC traffic IPv6.</p>
<p>This API are mutually exclusive and supersedes the following APIs below which will be deprecated: sx_api_fdb_unreg_mc_flood_mode_set(..) sx_api_fdb_unreg_mc_flood_ports_set(..)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">access_cmd</td><td>- SET / UNSET SET will configure URMC according flood_attr UNSET will configure URMC mode to be FLOOD to release MC container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flood_key_p</td><td>- flood key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flood_attr_p</td><td>- flood attributes</td></tr>
  </table>
  </dd>
</dl>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="a7a111b8385e37f2ece7d25aff3eb7a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a111b8385e37f2ece7d25aff3eb7a33">&#9670;&nbsp;</a></span>sx_api_fdb_unreg_mc_flood_mode_ext_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_unreg_mc_flood_mode_ext_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_unreg_mc_flood_key_t *&#160;</td>
          <td class="paramname"><em>flood_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_fdb_unreg_mc_flood_attr_t *const&#160;</td>
          <td class="paramname"><em>flood_attr_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to get the flooding mode and vector for Unregistered MC traffic IPv4 and IPv6. Only one type can be provided at time. Specifically :</p><ul>
<li>flooding mode FLOOD / PRUNE</li>
<li>In PRUNE mode: flood_attr flood_vector will contains MC container with log_ports In FLOOD mode: flood_vector will return SX_MC_CONTAINER_ID_INVALID</li>
</ul>
<p>NOTE: In order to have separate vector for Unregistered MC traffic IPv6 the following flag should be enabled sdk_init_params.fdb_params.unreg_mc_ipv6_flood_en as part of SDK init. Else the Broadcast vector will apply for Unregistered MC traffic IPv6.</p>
<p>This API are mutually exclusive and supersedes the following APIs below which will be deprecated: sx_api_fdb_unreg_mc_flood_mode_get(..) sx_api_fdb_unreg_mc_flood_ports_get(..)</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flood_key_p</td><td>- Flood key </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flood_attr_p</td><td>- Flood attributes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_UNSUPPORTED if flood control is not supported in the switch. </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_PARAM_NULL if ports_list is null and ports_count is not 0. </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a id="aceaf604e293b33ce3ad10f9f078999df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceaf604e293b33ce3ad10f9f078999df">&#9670;&nbsp;</a></span>sx_api_fdb_mc_ip_addr_group_activity_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_ip_addr_group_activity_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mc_ip_key_t *&#160;</td>
          <td class="paramname"><em>key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean_t *&#160;</td>
          <td class="paramname"><em>activity_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function reads and/or clears activity on a specified multicast IP Entry.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ\READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fdb_mc_key_p</td><td>- mc entry key {fid, source IP address, group address} </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">activity_p</td><td>- activity state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if Key parameters exceed allowed range </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if mc route is not found </dd>
<dd>
SX_STATUS_PARAM_NULL if a parameter is NULL </dd>
<dd>
SX_STATUS_ERROR general error </dd></dl>

</div>
</div>
<a id="a49f9f71e8e65e1a8687080d39d4119ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f9f71e8e65e1a8687080d39d4119ef">&#9670;&nbsp;</a></span>sx_api_fdb_mc_ip_addr_group_activity_notify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_fdb_mc_ip_addr_group_activity_notify </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_fdb_mc_ip_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function initiates a notification regarding active mc fdb entries in the system.</p>
<p>Supported devices: Spectrum, Spectrum2, Spectrum3</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ\READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_p</td><td>- activity notifier filter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SX_STATUS_SUCCESS if the operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_PARAM_ERROR if parameter is invalid. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if a notification procedure is already running. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 30 2020 12:08:33 for Mellanox SwitchX SDK API Guide by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
