<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mellanox SwitchX SDK API Guide: sdk/sx_api_router.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mellanox SwitchX SDK API Guide&#160;<span id="projectnumber">4.2.7004</span></div>
  </td>
  <td>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>sdk/sx_api_router.h File Reference</h1>  </div>
</div>
<div class="contents">

<p><a href="sx__api__router_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a34f17bf4bcc4feeac94a3dad937ac9ef">sx_api_router_log_verbosity_level_set</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a16054cd7f48ec56a42953a3b38dfd4b3">sx_api_router_log_verbosity_level_get</a> (const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#ac828368205f9110cb12ce1efaa127e36">sx_api_router_ecmp_hash_params_set</a> (const sx_api_handle_t handle, const sx_router_ecmp_hash_params_t *ecmp_hash_params_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a745c179a22cc63568a0cc1fa3375cd35">sx_api_router_ecmp_port_hash_params_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_router_ecmp_port_hash_params_t *ecmp_hash_params_p, const sx_router_ecmp_hash_field_enable_t *hash_field_enable_list_p, const uint32_t hash_field_enable_list_cnt, const sx_router_ecmp_hash_field_t *hash_field_list_p, const uint32_t hash_field_list_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a24b800ec0358c5525688d2d430c409a6">sx_api_router_ecmp_hash_params_get</a> (const sx_api_handle_t handle, sx_router_ecmp_hash_params_t *ecmp_hash_params_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a9240dce50ddf1d16f2fee274487bd107">sx_api_router_ecmp_port_hash_params_get</a> (const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_router_ecmp_port_hash_params_t *ecmp_hash_params_p, sx_router_ecmp_hash_field_enable_t *hash_field_enable_list_p, uint32_t *hash_field_enable_list_cnt_p, sx_router_ecmp_hash_field_t *hash_field_list_p, uint32_t *hash_field_list_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a1ef69aecaf04fa448db5bca24195b338">sx_api_router_init_set</a> (const sx_api_handle_t handle, const sx_router_general_param_t *general_params_p, const sx_router_resources_param_t *router_resource_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a2e1cae9d18872c0657706f776130f2cf">sx_api_router_deinit_set</a> (const sx_api_handle_t handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a2dc149f2962ae58006fe5d99c30f2170">sx_api_router_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_attributes_t *router_attr, sx_router_id_t *vrid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a2c3deff6c205855116423b65854ddaff">sx_api_router_get</a> (const sx_api_handle_t handle, const sx_router_id_t vrid, sx_router_attributes_t *router_attr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a920b436f76d03c2b0c47ba4b48b05ac6">sx_api_router_vrid_iter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid_key, const sx_vrid_filter_t *vrid_filter_p, sx_router_id_t *vrid_list_p, uint32_t *vrid_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#aa75e9b0a9cb41809d2b7158ad9742e88">sx_api_router_interface_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_router_interface_param_t *ifc_p, const sx_interface_attributes_t *ifc_attr_p, sx_router_interface_t *rif_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a726222b37bb531286106877b469ee77d">sx_api_router_interface_get</a> (const sx_api_handle_t handle, const sx_router_interface_t rif, sx_router_id_t *vrid_p, sx_router_interface_param_t *ifc_p, sx_interface_attributes_t *ifc_attr_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a5e983db0a332579417b4d809c79e93c4">sx_api_router_interface_iter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_interface_t *rif_key_p, const sx_rif_filter_t *filter_p, sx_router_interface_t *rif_list_p, uint32_t *rif_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a8e7036a60c1a30149df0849edcf4b1cf">sx_api_router_interface_state_set</a> (const sx_api_handle_t handle, const sx_router_interface_t rif, const sx_router_interface_state_t *rif_state_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#afca9be4809b7930481b23d13b62260c4">sx_api_router_interface_state_get</a> (const sx_api_handle_t handle, const sx_router_interface_t rif, sx_router_interface_state_t *rif_state_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a45fa8aa8bb1a944fc76388b380d32e48">sx_api_router_interface_mac_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_interface_t rif, const sx_mac_addr_t *mac_addr_list_p, const uint32_t mac_addr_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a6cfa5bcd99c9b86516cdbf088bbc4270">sx_api_router_interface_mac_get</a> (const sx_api_handle_t handle, const sx_router_interface_t rif, sx_mac_addr_t *mac_addr_list_p, uint32_t *mac_addr_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a717aefbc20f4378e82b1114943384025">sx_api_router_neigh_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_interface_t rif, const sx_ip_addr_t *ip_addr_p, const sx_neigh_data_t *neigh_data_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a418c04f432cd961383aaddf3f5de01ad">sx_api_router_neigh_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_interface_t rif, const sx_ip_addr_t *neigh_key_p, const sx_neigh_filter_t *filter_p, sx_neigh_get_entry_t *neigh_entry_list_p, uint32_t *neigh_entry_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#acf9f7e35f14c64b05c3aa179d40f4d35">sx_api_router_neigh_activity_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_interface_t rif, const sx_ip_addr_t *ip_addr_p, boolean_t *activity_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a567fd03de370a075336735995e17e77b">sx_api_router_uc_route_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_ip_prefix_t *network_addr, sx_uc_route_data_t *uc_route_data_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a7e7840f0e1e453e677668b9f652c66fc">sx_api_router_uc_route_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_ip_prefix_t *network_addr, sx_uc_route_key_filter_t *filter_p, sx_uc_route_get_entry_t *uc_route_get_entries_list_p, uint32_t *uc_route_get_entries_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a059c220b2a25fb94729c83688e7f8ff0">sx_api_router_uc_route_operational_ecmp_get</a> (const sx_api_handle_t handle, const sx_router_id_t vrid, const sx_ip_prefix_t *network_addr_p, sx_uc_route_get_entry_t *oper_uc_route_entries_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#ada19ea02653d8cea4a46b48752f524a1">sx_api_router_uc_route_counter_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_ip_prefix_t *network_addr_p, const sx_flow_counter_id_t counter_id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a8d9e8525ebab84f8c49bff8d59f0eb59">sx_api_router_uc_route_counter_bind_get</a> (const sx_api_handle_t handle, const sx_router_id_t vrid, const sx_ip_prefix_t *network_addr_p, sx_flow_counter_id_t *counter_id_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a472c9bb573ce5a76a04f14cd53346b6f">sx_api_router_counter_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_router_counter_id_t *counter_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a0e73f38b6a51b7090c5c775c96689dfd">sx_api_router_counter_extended_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_counter_attributes_t cntr_attributes, sx_router_counter_id_t *counter_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a71f2d9f69205e6835bd4290703106121">sx_api_router_interface_counter_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_counter_id_t counter, const sx_router_interface_t rif)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#aa81e1f46c5501aee769e56e4fa4ebf23">sx_api_router_interface_counter_bind_get</a> (const sx_api_handle_t handle, const sx_router_counter_id_t counter, sx_router_interface_t *rif_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#ab4c18223f082f72efeb16ef6ab4545c6">sx_api_router_counter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_counter_id_t counter, sx_router_counter_set_t *counter_set_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a1b43b5655884e760afefdfd3f3910ea4">sx_api_router_counter_extended_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_counter_id_t counter_id, sx_router_counter_set_extended_t *counter_data_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a1c3d7ede0cc2b4a383aacf414c9d84a3">sx_api_router_counter_clear_set</a> (const sx_api_handle_t handle, const sx_router_counter_id_t counter, const boolean_t all)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a88d28b1cf1ea8606acaecf5c01c31051">sx_api_router_mc_route_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, const sx_mc_route_attributes_t *mc_route_attr_p, const sx_mc_route_data_t *mc_route_data_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a24a37e74c648d6bd3de469df8cbd5b8c">sx_api_router_mc_route_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, sx_mc_route_key_filter_t *filter_p, sx_mc_route_get_entry_t *mc_route_get_entries_list_p, uint32_t *mc_route_get_entries_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#ab70bf9ca856f55a88e7dd5a4fe5f77fa">sx_api_router_mc_route_activity_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, boolean_t *activity_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a209bcda3949dca1c76a5e18aa6705255">sx_api_router_mc_route_activity_notify</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_mc_route_activity_notify_filter_t *filter_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a49d704b1d7e401edc59dde5aff4bf376">sx_api_router_mc_egress_rif_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, const sx_router_interface_t *egress_rif_list_p, const uint32_t egress_rif_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a530c3fdb5083d5c3a8f8e74ee348da69">sx_api_router_mc_egress_rif_get</a> (const sx_api_handle_t handle, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, sx_router_interface_t *egress_rif_list_p, uint32_t *egress_rif_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#ad8dbefb60e445f59551a682a9177faa4">sx_api_router_cos_rewrite_pcpdei_enable_set</a> (const sx_api_handle_t handle, const sx_cos_pcp_dei_rewrite_e rewrite_pcp_dei)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a263b0c24b5930c791a6691a473934ee8">sx_api_router_cos_rewrite_pcpdei_enable_get</a> (const sx_api_handle_t handle, sx_cos_pcp_dei_rewrite_e *rewrite_pcp_dei_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a8d98abb2561504116bda54e5e7a1647c">sx_api_router_cos_prio_update_enable_set</a> (const sx_api_handle_t handle, const boolean_t update_priority_color)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#aa1bd7e45636b6128e1add0ad579b2f86">sx_api_router_cos_prio_update_enable_get</a> (const sx_api_handle_t handle, boolean_t *update_priority_color_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a3601a683f22a7e13bc89b3f80a4a3c0e">sx_api_router_cos_dscp_to_prio_set</a> (const sx_api_handle_t handle, const sx_cos_dscp_t *dscp_p, const sx_cos_priority_color_t *priority_color_p, const uint32_t element_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a3dffe9f627debece49b7ed508c12bf0b">sx_api_router_cos_dscp_to_prio_get</a> (const sx_api_handle_t handle, sx_cos_dscp_t *dscp_p, sx_cos_priority_color_t *priority_color_p, uint32_t *element_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#abd1c22691400cdcd80424831ff6bc942">sx_api_router_ecmp_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_ecmp_id_t *ecmp_id_p, sx_next_hop_t *next_hop_list_p, uint32_t *next_hop_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a7c569920c238a3289dc3877a5c10783e">sx_api_router_ecmp_get</a> (const sx_api_handle_t handle, const sx_ecmp_id_t ecmp_id, sx_next_hop_t *next_hop_list_p, uint32_t *next_hop_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a866dedd655aa7313be54227fe54ec57e">sx_api_router_ecmp_iter_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_ecmp_id_t ecmp_id, const sx_ecmp_filter_t *filter_p, sx_ecmp_id_t *ecmp_list_p, uint32_t *ecmp_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a44c2973c659f035cbde4f0a519b1082b">sx_api_router_operational_ecmp_get</a> (const sx_api_handle_t handle, const sx_ecmp_id_t ecmp_id, sx_next_hop_t *next_hop_list_p, uint32_t *next_hop_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a2aa9c0bda0299d13e275a267c1249fb8">sx_api_router_ecmp_counter_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_ecmp_id_t ecmp_id, const sx_flow_counter_id_t *counter_id_list_p, const uint32_t *offset_list_p, const uint32_t elements_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a2fa0de25ef37a9cef1652e920c5fc019">sx_api_router_ecmp_fine_grain_counter_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_ecmp_id_t ecmp_id, const sx_flow_counter_id_t counter_id, const uint32_t *offset_list_p, const uint32_t elements_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a823465cf10115d18b458c33a678cfccf">sx_api_router_neigh_activity_notify</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_neigh_activity_filter_t *filter_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a242f69b150debcf00867d67f8515e8a6">sx_api_router_ecmp_attributes_set</a> (const sx_api_handle_t handle, const sx_ecmp_id_t ecmp_id, const sx_ecmp_attributes_t *attr_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#afa58f3a820da481643de557c94a401ea">sx_api_router_ecmp_attributes_get</a> (const sx_api_handle_t handle, const sx_ecmp_id_t ecmp_id, sx_ecmp_attributes_t *attr_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a1936f4c977dfe4c92e31af4ba9390845">sx_api_router_ecmp_clone_set</a> (const sx_api_handle_t handle, const sx_ecmp_id_t old_ecmp_id, sx_ecmp_id_t *new_ecmp_id_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#aa529787aa5b258a80c567f751dbfe2ee">sx_api_router_mc_rpf_group_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_rpf_group_id_t *rpf_group_id_p, sx_router_vinterface_t *rpf_vif_list_p, uint32_t rpf_vif_cnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#ae922af870268cc2ccf178169027ac093">sx_api_router_mc_rpf_group_get</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_rpf_group_id_t *rpf_group_id_p, sx_router_vinterface_t *rpf_vif_list_p, uint32_t *rpf_vif_cnt_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a6a4327a03b23e683f531b359fa569ecf">sx_api_router_mc_route_counter_bind_set</a> (const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, const sx_flow_counter_id_t counter_id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sx_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sx__api__router_8h.html#a450a42c80363d8802247f85c77fae63d">sx_api_router_mc_route_counter_bind_get</a> (const sx_api_handle_t handle, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, sx_flow_counter_id_t *counter_id_p)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a34f17bf4bcc4feeac94a3dad937ac9ef"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_log_verbosity_level_set" ref="a34f17bf4bcc4feeac94a3dad937ac9ef" args="(const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, const sx_verbosity_level_t module_verbosity_level, const sx_verbosity_level_t api_verbosity_level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_log_verbosity_level_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>module_verbosity_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_verbosity_level_t&#160;</td>
          <td class="paramname"><em>api_verbosity_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets the log verbosity level of ROUTER MODULE. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- set verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module_verbosity_level</td><td>- ROUTER module verbosity level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">api_verbosity_level</td><td>- ROUTER API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a16054cd7f48ec56a42953a3b38dfd4b3"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_log_verbosity_level_get" ref="a16054cd7f48ec56a42953a3b38dfd4b3" args="(const sx_api_handle_t handle, const sx_log_verbosity_target_t verbosity_target, sx_verbosity_level_t *module_verbosity_level_p, sx_verbosity_level_t *api_verbosity_level_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_log_verbosity_level_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_log_verbosity_target_t&#160;</td>
          <td class="paramname"><em>verbosity_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>module_verbosity_level_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_verbosity_level_t *&#160;</td>
          <td class="paramname"><em>api_verbosity_level_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API gets the log verbosity level of ROUTER MODULE. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_target</td><td>- get verbosity of : API / MODULE / BOTH </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">module_verbosity_level_p</td><td>- ROUTER module verbosity level </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">api_verbosity_level_p</td><td>- ROUTER API verbosity level</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="ac828368205f9110cb12ce1efaa127e36"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_ecmp_hash_params_set" ref="ac828368205f9110cb12ce1efaa127e36" args="(const sx_api_handle_t handle, const sx_router_ecmp_hash_params_t *ecmp_hash_params_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_hash_params_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_ecmp_hash_params_t *&#160;</td>
          <td class="paramname"><em>ecmp_hash_params_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the ECMP hash function configuration parameters. If ecmp_hash_params_p-&gt;symmetric_hash is TRUE, enabling bits in ecmp_hash_params_p-&gt;ecmp_hash bitmask should be in couples, both source and destination. This API is disabled once sx_api_router_ecmp_port_hash_params_set is called. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ecmp_hash_param_p</td><td>- ECMP hash configuration parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a745c179a22cc63568a0cc1fa3375cd35"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_ecmp_port_hash_params_set" ref="a745c179a22cc63568a0cc1fa3375cd35" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_port_log_id_t log_port, const sx_router_ecmp_port_hash_params_t *ecmp_hash_params_p, const sx_router_ecmp_hash_field_enable_t *hash_field_enable_list_p, const uint32_t hash_field_enable_list_cnt, const sx_router_ecmp_hash_field_t *hash_field_list_p, const uint32_t hash_field_list_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_port_hash_params_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_ecmp_port_hash_params_t *&#160;</td>
          <td class="paramname"><em>ecmp_hash_params_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_ecmp_hash_field_enable_t *&#160;</td>
          <td class="paramname"><em>hash_field_enable_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>hash_field_enable_list_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_ecmp_hash_field_t *&#160;</td>
          <td class="paramname"><em>hash_field_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>hash_field_list_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the ECMP port hash function configuration parameters. Once this API is called sx_api_router_ecmp_hash_params_set is disabled.</p>
<p>If ecmp_hash_params_p-&gt;symmetric_hash is TRUE, setting fields in hash_field_list_p should be in couples, both source and destination. Each element in hash_field_enable_list_p enables a specific layer field to be included in the hash calculation. Each element in hash_field_list_p represents a different field to be included in the hash calculation, subject to the enables which are given in hash_field_enable_list_p.</p>
<p>Supported devices: Spectrum</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- SET/ ADD/ DELETE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- log port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ecmp_hash_params_p</td><td>- ECMP hash configuration parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_field_enable_list_p</td><td>- Array of enables to be included in the hash calculation (may be NULL if empty) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_field_enable_list_cnt</td><td>- Number of elements in hash_field_enable_list_p </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_field_list_p</td><td>- Array of fields to be included in the hash calculation (may be NULL if empty) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_field_list_cnt</td><td>- Number of elements in hash_field_list_p</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is incorrectly NULL. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a24b800ec0358c5525688d2d430c409a6"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_ecmp_hash_params_get" ref="a24b800ec0358c5525688d2d430c409a6" args="(const sx_api_handle_t handle, sx_router_ecmp_hash_params_t *ecmp_hash_params_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_hash_params_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_ecmp_hash_params_t *&#160;</td>
          <td class="paramname"><em>ecmp_hash_params_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the ECMP hash function configuration parameters. This API is disabled once sx_api_router_ecmp_port_hash_params_set is called. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ecmp_hash_params_p</td><td>- ECMP hash configuration parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a9240dce50ddf1d16f2fee274487bd107"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_ecmp_port_hash_params_get" ref="a9240dce50ddf1d16f2fee274487bd107" args="(const sx_api_handle_t handle, const sx_port_log_id_t log_port, sx_router_ecmp_port_hash_params_t *ecmp_hash_params_p, sx_router_ecmp_hash_field_enable_t *hash_field_enable_list_p, uint32_t *hash_field_enable_list_cnt_p, sx_router_ecmp_hash_field_t *hash_field_list_p, uint32_t *hash_field_list_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_port_hash_params_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_port_log_id_t&#160;</td>
          <td class="paramname"><em>log_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_ecmp_port_hash_params_t *&#160;</td>
          <td class="paramname"><em>ecmp_hash_params_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_ecmp_hash_field_enable_t *&#160;</td>
          <td class="paramname"><em>hash_field_enable_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>hash_field_enable_list_cnt_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_ecmp_hash_field_t *&#160;</td>
          <td class="paramname"><em>hash_field_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>hash_field_list_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the ECMP hash function configuration parameters. if the given number of fields / fields enables is 0, the API will only return number of fields / enables.</p>
<p>Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_port</td><td>- local port </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ecmp_hash_params_p</td><td>- ECMP hash configuration parameters. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hash_field_enable_list_p</td><td>- array of enables used in the hash calculation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in/out]</td><td>hash_field_enable_list_cnt_p - number of objects in hash_field_list_p </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hash_field_list_p</td><td>- array of fields used in the hash calculation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in/out]</td><td>hash_field_list_cnt_p - number of objects in hash_field_list_p</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ef69aecaf04fa448db5bca24195b338"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_init_set" ref="a1ef69aecaf04fa448db5bca24195b338" args="(const sx_api_handle_t handle, const sx_router_general_param_t *general_params_p, const sx_router_resources_param_t *router_resource_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_init_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_general_param_t *&#160;</td>
          <td class="paramname"><em>general_params_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_resources_param_t *&#160;</td>
          <td class="paramname"><em>router_resource_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function Initiates the router module in SDK. uc_params-&gt;ipv4_num requires a value larger than 30. mc_params-&gt;mc_routes-&gt;ipv4_num requires a value larger than 30. (If mc_router is enabled).</p>
<p>Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">general_params_p</td><td>- general router parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">router_resource_p-</td><td>router resource parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS - if operation completes successfully. </dd>
<dd>
SX_STATUS_ALREADY_INITIALIZED - When router is already initialized. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE - When calling with bad parameters. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e1cae9d18872c0657706f776130f2cf"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_deinit_set" ref="a2e1cae9d18872c0657706f776130f2cf" args="(const sx_api_handle_t handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_deinit_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This api deinitializes the router block in the sdk. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE When router is still active. </dd></dl>

</div>
</div>
<a class="anchor" id="a2dc149f2962ae58006fe5d99c30f2170"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_set" ref="a2dc149f2962ae58006fe5d99c30f2170" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_attributes_t *router_attr, sx_router_id_t *vrid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_attributes_t *&#160;</td>
          <td class="paramname"><em>router_attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_id_t *&#160;</td>
          <td class="paramname"><em>vrid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function adds/deletes/edits a virtual router. The router ID is allocated and returned to the caller when cmd is ADD, otherwise it is given by the caller. All interfaces and routes associated with a router must be deleted before the router can be deleted as well.</p>
<p>Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE/EDIT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">router_attr</td><td>- Router attributes. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vrid</td><td>- Virtual router ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if router was not added. </dd>
<dd>
SX_STATUS_NO_RESOURCES if there are no resources to create another router </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if router has interfaces or routes. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c3deff6c205855116423b65854ddaff"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_get" ref="a2c3deff6c205855116423b65854ddaff" args="(const sx_api_handle_t handle, const sx_router_id_t vrid, sx_router_attributes_t *router_attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_attributes_t *&#160;</td>
          <td class="paramname"><em>router_attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets a virtual router information. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">router_attr</td><td>- Router attributes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if router was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a920b436f76d03c2b0c47ba4b48b05ac6"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_vrid_iter_get" ref="a920b436f76d03c2b0c47ba4b48b05ac6" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid_key, const sx_vrid_filter_t *vrid_filter_p, sx_router_id_t *vrid_list_p, uint32_t *vrid_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_vrid_iter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_vrid_filter_t *&#160;</td>
          <td class="paramname"><em>vrid_filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_id_t *&#160;</td>
          <td class="paramname"><em>vrid_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>vrid_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets a list of valid VRIDs. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>GET/GET_NEXT/GET_FIRST </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid_key</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid_filter_p</td><td>- Filter to use (not supported yet) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vrid_list_p</td><td>- pointer to the list of valid VRIDs returned. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vrid_cnt_p</td><td>[in] number of entries to retrieve (max: 254).; [out] retrieved number of entries.</td></tr>
  </table>
  </dd>
</dl>
<p>Input/Output types</p>
<ul>
<li>Get first - Get a list of first n entries. Cmd should be SX_ACCESS_CMD_GET_FIRST and vrid_cnt_p should be equal to n. key is irrelevant in this case. Returns number of entries retrieved as vrid_cnt_p</li>
<li>Get next - Get n entries after a specified vrid (it does not have to exist). Cmd should be SX_ACCESS_CMD_GETNEXT. vrid_cnt_p should be equal to n. Returns number of entries retrieved as vrid_cnt_p</li>
<li>Get - Gets a specific entry. Cmd should be SX_ACCESS_CMD_GET and vrid_cnt_p should be 1. * input vrid_cnt_p is 0, then returns a count of valid VRIDs as output instead.</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if command is not supported </dd>
<dd>
SX_STATUS_INVALID_HANDLE if handle in invalid </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="aa75e9b0a9cb41809d2b7158ad9742e88"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_interface_set" ref="aa75e9b0a9cb41809d2b7158ad9742e88" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_router_interface_param_t *ifc_p, const sx_interface_attributes_t *ifc_attr_p, sx_router_interface_t *rif_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_param_t *&#160;</td>
          <td class="paramname"><em>ifc_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_interface_attributes_t *&#160;</td>
          <td class="paramname"><em>ifc_attr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_interface_t *&#160;</td>
          <td class="paramname"><em>rif_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function adds/modifies/deletes/delete_all a router interface. A router interface is associated with L2 interface. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<p>When in 802.1D mode, if ifc_p of type SX_L2_INTERFACE_TYPE_VLAN is provided, instead of providing ifc.vlan.vlan you should provide a bridge_id.</p>
<p>On Spectrum with command EDIT:</p>
<ul>
<li>The only applicable RIF type that can be edited in ifc_p is SX_L2_INTERFACE_TYPE_PORT_VLAN. In this type, the only field that can be edited is the vlan field.</li>
<li>The only applicable fields in ifc_attr_p are mtu, multicast_ttl_threshold and loopback_enable. Other fields may not be edited.</li>
</ul>
<p>On Spectrum the mac field in ifc_attr_p, is made from 38 bits of common base and only the last 10 bits can be different from one rif to another</p>
<p>On Spectrum the qos_mode field in ifc_attr_p is redundant, instead use the global router qos configuration. the rif must be aligned with the router global qos mode configured using sx_api_router_cos_prio_update_enable_set, or use SX_ROUTER_QOS_MODE_NOP to use the router global configured qos mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/EDIT/DELETE/DELETE ALL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ifc_p</td><td>- Interface type and parameters . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ifc_attr_p</td><td>-Interface attributes. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rif</td><td>- Router Interface ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if router interface was not added. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no interface is available to create. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if router interface has routes. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a726222b37bb531286106877b469ee77d"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_interface_get" ref="a726222b37bb531286106877b469ee77d" args="(const sx_api_handle_t handle, const sx_router_interface_t rif, sx_router_id_t *vrid_p, sx_router_interface_param_t *ifc_p, sx_interface_attributes_t *ifc_attr_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t&#160;</td>
          <td class="paramname"><em>rif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_id_t *&#160;</td>
          <td class="paramname"><em>vrid_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_interface_param_t *&#160;</td>
          <td class="paramname"><em>ifc_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_interface_attributes_t *&#160;</td>
          <td class="paramname"><em>ifc_attr_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets a router interface information. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<p>When in 802.1D mode, if ifc_p of type SX_L2_INTERFACE_TYPE_VLAN is returned, instead of receiving a vlan ID on ifc.vlan.vlan, a bridge ID is provided.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif</td><td>- Router Interface ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vrid_p</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ifc_p</td><td>- Interface type and parameters . </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ifc_attr_p</td><td>-Interface attributes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if router interface was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e983db0a332579417b4d809c79e93c4"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_interface_iter_get" ref="a5e983db0a332579417b4d809c79e93c4" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_interface_t *rif_key_p, const sx_rif_filter_t *filter_p, sx_router_interface_t *rif_list_p, uint32_t *rif_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_iter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t *&#160;</td>
          <td class="paramname"><em>rif_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_rif_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_interface_t *&#160;</td>
          <td class="paramname"><em>rif_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rif_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns a list of one or more router interface identifiers. The following use case scenarios apply with different input parameters X = don't-care</p>
<ul>
<li>1) cmd = SX_ACCESS_CMD_GET, key = X, Filter = X, Rif_list = X, Count =0: In this case the API will return the total number of RIFs in the Internal db</li>
</ul>
<ul>
<li>2) cmd = SX_ACCESS_CMD_GET, key = valid/invalid, Filter = X, Rif_list = Valid, Count = 1: In this case the API will check if the specified key exists. if it does the key will be returned in the rif_list along with a count of 1. If the key does not exist an empty list will be returned with count = 0</li>
</ul>
<ul>
<li>3) cmd = SX_ACCESS_CMD_GET, key = valid, Filter = Valid, Rif_list is Valid, Count =1: In this case the API will check if the specified key exists. if it does it will check it against the filter parameter. If the filter matches, the key will be returned in the rif_list along with a count of 1. If the key does not exist or the filter does not match an empty list will be returned with count = 0</li>
</ul>
<ul>
<li>4) cmd = SX_ACCESS_CMD_GET, key = valid, Filter = Valid/invalid, Rif_list is Valid, Count &gt; 1: A count &gt;1 will be treated as a count of 1 and the behavior will be same as earlier GET use cases.</li>
</ul>
<ul>
<li>5) cmd = SX_ACCESS_CMD_GET_FIRST/SX_ACCESS_CMD_GETNEXT, key = X, Filter = X, Rif_list = Null, Count =0: For either SX_ACCESS_CMD_GET_FIRST/SX_ACCESS_CMD_GETNEXT a zero count will return an empty list.</li>
</ul>
<ul>
<li>6) cmd = SX_ACCESS_CMD_GET_FIRST, key = X, Filter = valid/invalid, Rif_list = Valid, Count &gt; 0: In this case the API will return the first count rifs starting from the head of the database. The total elements fetched will be returned as the return count. Note: return count may be less than or equal to the requested count. The key is dont-care. If a filter is specified only those rifs that match the filter will be returned. a non-Null return rif_list pointer must be provided</li>
</ul>
<ul>
<li>7) cmd = SX_ACCESS_CMD_GETNEXT, key = valid/invalid, Filter = valid/invalid, Rif_list = Valid, Count &gt; 0: In this case the API will return the next set of rifs starting from the next valid rif after the specified key. The total elements fetched will be returned as the return count. If a filter is specified only those rifs that match the filter will be returned. Note: return count may be less than or equal to the requested count. If no valid next rif exists in the db (key = end of list, or invalid key specified, or key too large), an empty list will be returned.</li>
</ul>
<p>Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>: SX API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>: GET/GET_FIRST/GET_NEXT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif_key_p</td><td>: specify a rif key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>: specify a filter parameter </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rif_list_p</td><td>: return list of rif ids </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rif_cnt_p</td><td>: [in] number of rifs to get. max 400 : [out] number of rifs returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if an unexpected NULL parameter was passed. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ERROR general error. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED - if invalid cmd is passed </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED - if router module is uninitialized </dd>
<dd>
SX_STATUS_CMD_ERROR - if internal RPC mechanism to SDK server fails </dd>
<dd>
SX_STATUS_DB_NOT_INITIALIZED - if internal RIF DB is not initialized </dd></dl>

</div>
</div>
<a class="anchor" id="a8e7036a60c1a30149df0849edcf4b1cf"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_interface_state_set" ref="a8e7036a60c1a30149df0849edcf4b1cf" args="(const sx_api_handle_t handle, const sx_router_interface_t rif, const sx_router_interface_state_t *rif_state_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_state_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t&#160;</td>
          <td class="paramname"><em>rif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_state_t *&#160;</td>
          <td class="paramname"><em>rif_state_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets admin state of a router interface. Admin state is set per IP protocol. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif</td><td>- Router Interface ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif_state_p</td><td>- Admin state for unicast routing and multicast routing .</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if router interface was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="afca9be4809b7930481b23d13b62260c4"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_interface_state_get" ref="afca9be4809b7930481b23d13b62260c4" args="(const sx_api_handle_t handle, const sx_router_interface_t rif, sx_router_interface_state_t *rif_state_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_state_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t&#160;</td>
          <td class="paramname"><em>rif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_interface_state_t *&#160;</td>
          <td class="paramname"><em>rif_state_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets admin state of a router interface. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif</td><td>- Router Interface ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif_state_p</td><td>- Admin state for unicast routing and multicast routing .</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if router interface was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a45fa8aa8bb1a944fc76388b380d32e48"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_interface_mac_set" ref="a45fa8aa8bb1a944fc76388b380d32e48" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_interface_t rif, const sx_mac_addr_t *mac_addr_list_p, const uint32_t mac_addr_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_mac_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t&#160;</td>
          <td class="paramname"><em>rif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mac_addr_t *&#160;</td>
          <td class="paramname"><em>mac_addr_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mac_addr_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function adds/deletes a MAC address from a router interface. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE/DELETE_ALL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif</td><td>- Router Interface ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mac_addr_list_p</td><td>- MAC addresses array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mac_addr_cnt</td><td>- MAC addresses array size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if router interface was not added. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a6cfa5bcd99c9b86516cdbf088bbc4270"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_interface_mac_get" ref="a6cfa5bcd99c9b86516cdbf088bbc4270" args="(const sx_api_handle_t handle, const sx_router_interface_t rif, sx_mac_addr_t *mac_addr_list_p, uint32_t *mac_addr_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_mac_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t&#160;</td>
          <td class="paramname"><em>rif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_mac_addr_t *&#160;</td>
          <td class="paramname"><em>mac_addr_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>mac_addr_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets MAC address of a router interface. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif</td><td>- Router Interface ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mac_addr_list_p</td><td>- MAC addresses array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mac_addr_cnt_p</td><td>- MAC addresses array size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if router interface was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a717aefbc20f4378e82b1114943384025"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_neigh_set" ref="a717aefbc20f4378e82b1114943384025" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_interface_t rif, const sx_ip_addr_t *ip_addr_p, const sx_neigh_data_t *neigh_data_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_neigh_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t&#160;</td>
          <td class="paramname"><em>rif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ip_addr_t *&#160;</td>
          <td class="paramname"><em>ip_addr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_neigh_data_t *&#160;</td>
          <td class="paramname"><em>neigh_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function adds/deletes/delete_all a neighbor information. The neighbor's information associates an IP address to a MAC address. The neighbor's IP addresses are learned via ARP/ND discovery at the control protocols layer. The interface that the neighbors are associated with is derived from the IP interface configuration.</p>
<p>In SwitchX the Virtual Router Id must be given instead of the Router Interface Index parameter.</p>
<p>When cmd = DELETE_ALL, all neighbors which match the ip_addr_p-&gt;version and the rif, will be deleted. In SwitchX rif is given in neigh_data_p-&gt;rif parameter. In case rif is rm_resource_global.router_rifs_dontcare, all neighbors, on all rifs, corresponding with the ip_addr_p-&gt;version will be deleted. If ip_addr_p-&gt;version = SX_IP_VERSION_NONE then only IPv4 neighbors will be deleted.</p>
<p>In case action is SX_ROUTER_ACTION_TRAP_FORWARD/SX_ROUTER_ACTION_TRAP:</p>
<ul>
<li>In SwitchX, trap ID will be set to SX_TRAP_ID_L3_NEIGH_IP_BASE + trap priority.</li>
<li>In Spectrum, trap ID will be set to SXD_TRAP_ID_RTR_EGRESS0 if trap priority is BEST EFFORT, LOW or MED, and SXD_TRAP_ID_RTR_EGRESS1 otherwise.</li>
</ul>
<p>Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE/DELETE_ALL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif</td><td>- Spectrum - Router Interface Id, SwitchX - Virtual Router id. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ip_addr</td><td>- IP address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neigh_data_p</td><td>- Neighbors information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if neighbor was not added. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no neighbor entry is available to create. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a418c04f432cd961383aaddf3f5de01ad"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_neigh_get" ref="a418c04f432cd961383aaddf3f5de01ad" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_interface_t rif, const sx_ip_addr_t *neigh_key_p, const sx_neigh_filter_t *filter_p, sx_neigh_get_entry_t *neigh_entry_list_p, uint32_t *neigh_entry_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_neigh_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t&#160;</td>
          <td class="paramname"><em>rif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ip_addr_t *&#160;</td>
          <td class="paramname"><em>neigh_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_neigh_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_neigh_get_entry_t *&#160;</td>
          <td class="paramname"><em>neigh_entry_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>neigh_entry_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the neighbor's information.</p>
<p>For SwitchX the Virtual Router ID must be given instead of Router Interface ID.</p>
<p>The function can receive three types of input:</p>
<ul>
<li>1) cmd SX_ACCESS_CMD_GET, gets the neighbor whose RIF and IP address match those given in rif and ip_addr_p. neigh_entry_cnt_p should be equal to 1. In SwitchX VRID should be used instead of rif.</li>
</ul>
<ul>
<li>2) cmd SX_ACCESS_CMD_GET_FIRST, get a list of first n&lt;=20 neighbors whose IP version matches ip_addr_p-&gt;version. In SwitchX, API will return entries on the requested VRID. In Spectrum, RIF ID in rif parameter is ignored. Entries can be filtered by the rif given in filter_p. If neigh_key_p-&gt;ip_addr.version == SX_IP_VERSION_NONE only IPv4 neighbors will be returned.</li>
</ul>
<ul>
<li>3) cmd SX_ACCESS_CMD_GETNEXT, get a list of n&lt;=20 next neighbors after the key's IP address and RIF. The neighbor with the specific key doesn't have to exist. In SwitchX, VRID should be given instead of RIF. Entries can be filtered by the rif given in filter_p. If neigh_key_p-&gt;ip_addr.version == SX_IP_VERSION_NONE only IPv4 neighbors will be returned.</li>
</ul>
<p>Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET/GET_FIRST/ GET_NEXT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif</td><td>- Spectrum - Router Interface Id, SwitchX - Virtual Router id. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neigh_key_p</td><td>- neigh key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_p</td><td>- neigh key_filter. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">neigh_entry_list_p</td><td>- found neigh entries arr </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">neigh_entry_cnt_p</td><td>- found neigh entries num</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if neighbor was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="acf9f7e35f14c64b05c3aa179d40f4d35"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_neigh_activity_get" ref="acf9f7e35f14c64b05c3aa179d40f4d35" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_interface_t rif, const sx_ip_addr_t *ip_addr_p, boolean_t *activity_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_neigh_activity_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t&#160;</td>
          <td class="paramname"><em>rif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ip_addr_t *&#160;</td>
          <td class="paramname"><em>ip_addr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean_t *&#160;</td>
          <td class="paramname"><em>activity_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function reads and cleans the neighbor's activity information. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<p>For SwitchX the Virtual Router Id must be given instead of the Router Interface Index parameter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ / READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif</td><td>- Spectrum - Router Interface Id, SwitchX - Virtual Router id. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ip_addr_p</td><td>- neigh IP address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">activity_p</td><td>- activity .</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if neighbor was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a567fd03de370a075336735995e17e77b"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_uc_route_set" ref="a567fd03de370a075336735995e17e77b" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_ip_prefix_t *network_addr, sx_uc_route_data_t *uc_route_data_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_uc_route_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ip_prefix_t *&#160;</td>
          <td class="paramname"><em>network_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_uc_route_data_t *&#160;</td>
          <td class="paramname"><em>uc_route_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function modifies unicast routes in the routing table. A route may have one of several types: IP2ME, LOCAL, or NEXT_HOP IP2ME routes trap traffic with the specified destination IP of the router host. Such traffic will have trap ID of IP2ME. Local routes allow IP forwarding to neighbors, and also trap traffic to unknown neighbors within the subnet. Such traffic will have trap ID of ARP-cache miss. Next-hop routes allow IP forwarding to next hop router(s) Next-hop routes may be defined with a set of next hop IPs, or with an ECMP container ID, but never both. For routes with next-hop IPs, commands ADD and DELETE may be used to modify the set of next hops. The route is created with its first next-hop and deleted when its last next hop is deleted. If used with next_hop_cnt=0, command DELETE deletes all next-hops of a route as well as the route itself. Command SOFT_ADD is similar to ADD, but also returns the actual set of next-hops used in hardware, which may be a sub-set of the requested set, due to lack of hardware resources. When SOFT_ADD returns, unused next hops are changed to have SX_IP_VERSION_NONE. For all other types of routes, ADD creates a new route and DELETE deletes an existing route. Command SET may be used to replace an existing route. This includes optionally changing its type. If a flow-counter is bound to the route, it stays bound. Command DELETE_ALL deletes all of the unicast routes of the specified virtual router, the specified route type in uc_route_data_p-&gt;type, and the IP protocol(s) in network_addr-&gt;version. If uc_route_data_p is NULL, then routes of type NEXT_HOP are deleted. If network_addr is NULL or network_addr-&gt;version is SX_IP_VERSION_NONE then all IPv4 routes of the specified type are deleted. For routes with action TRAP or TRAP_FORWARD, the trapped traffic will have Trap ID of SX_TRAP_ID_L3_UC_IP_BASE + trap priority in SwitchX/SwitchX2; In Spectrum, the trap ID is SX_TRAP_ID_L3_UC_IP_BASE for trap priority BEST_EFFORT, LOW or MEDIUM, or (SX_TRAP_ID_L3_UC_IP_BASE+3) for higher trap priorities. Note: SwitchX/SwitchX2 support only routes of type NEXT_HOP with next-hop IPs</p>
<p>Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/SET/SOFT_ADD/DELETE/DELETE_ALL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">network_addr_p</td><td>- IP network address. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">uc_route_data_p</td><td>- route data {Next hop list,action}</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no routes is available to create. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e7840f0e1e453e677668b9f652c66fc"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_uc_route_get" ref="a7e7840f0e1e453e677668b9f652c66fc" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_ip_prefix_t *network_addr, sx_uc_route_key_filter_t *filter_p, sx_uc_route_get_entry_t *uc_route_get_entries_list_p, uint32_t *uc_route_get_entries_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_uc_route_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ip_prefix_t *&#160;</td>
          <td class="paramname"><em>network_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_uc_route_key_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_uc_route_get_entry_t *&#160;</td>
          <td class="paramname"><em>uc_route_get_entries_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>uc_route_get_entries_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets unicast route information from the routing table. The function can receive four types of input:</p>
<ul>
<li>1) Get information for a specific IP address. Set the specific IP prefix in the network_addr parameter. uc_route_get_entries_cnt_p should be set to 1. cmd should be set to SX_ACCESS_CMD_GET.</li>
</ul>
<ul>
<li>2) Count the number of configured IPv4/6 UC routes, according to the network_addr-&gt;version parameter. uc_route_get_entries_cnt_p should be set to 0. cmd should be set to SX_ACCESS_CMD_GET.</li>
</ul>
<ul>
<li>3) Get a list of first n&lt;=64 routes. Set IP prefix data in the network_addr parameter. uc_route_get_entries_cnt_p should be set to n. Set filter_p filter type(s) to filter the results by. cmd should be set to SX_ACCESS_CMD_GET_FIRST.</li>
</ul>
<ul>
<li>4) Get a list of n&lt;=64 routes which comes after specific IP prefix (not necessarily an existing one). Set IP prefix address in the network_addr parameter. uc_route_get_entries_cnt_p should be set to n, filter_p is the filter type(s) you want to filter the results by. cmd should be SX_ACCESS_CMD_GETNEXT.</li>
</ul>
<p>Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET /GET_FIRST/ GETNEXT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">network_addr</td><td>- IP network address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_p</td><td>- UC route key_filter. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"></td><td>found uc route entries arr . </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"></td><td>found uc route entries num .</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if UC route was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a059c220b2a25fb94729c83688e7f8ff0"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_uc_route_operational_ecmp_get" ref="a059c220b2a25fb94729c83688e7f8ff0" args="(const sx_api_handle_t handle, const sx_router_id_t vrid, const sx_ip_prefix_t *network_addr_p, sx_uc_route_get_entry_t *oper_uc_route_entries_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_uc_route_operational_ecmp_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ip_prefix_t *&#160;</td>
          <td class="paramname"><em>network_addr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_uc_route_get_entry_t *&#160;</td>
          <td class="paramname"><em>oper_uc_route_entries_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves active unicast ECMP route information from the routing table. When using oper_uc_route_entries_p-&gt;route_data.next_hop_cnt=0 only the number of next hops will be returned. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">network_addr</td><td>- IP network address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">oper_uc_route_entries_p</td><td>- found uc route entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ECMP UC route was not found. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="ada19ea02653d8cea4a46b48752f524a1"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_uc_route_counter_bind_set" ref="ada19ea02653d8cea4a46b48752f524a1" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_ip_prefix_t *network_addr_p, const sx_flow_counter_id_t counter_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_uc_route_counter_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ip_prefix_t *&#160;</td>
          <td class="paramname"><em>network_addr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_flow_counter_id_t&#160;</td>
          <td class="paramname"><em>counter_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Binds or un-binds a flow counter to an existing unicast route Note: A route may be created via a call to <a class="el" href="sx__api__router_8h.html#a567fd03de370a075336735995e17e77b">sx_api_router_uc_route_set()</a> A flow counter may be created via a call to <a class="el" href="sx__api__flow__counter_8h.html#a9d043e95b58d1d326128c643c0952802">sx_api_flow_counter_set()</a> Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- BIND/UNBIND </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">network_addr_p</td><td>- Network prefix of a unicast route </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_id</td><td>- A flow counter identifier. Applicable only for command BIND</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if the specified route or flow counter was not found. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d9e8525ebab84f8c49bff8d59f0eb59"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_uc_route_counter_bind_get" ref="a8d9e8525ebab84f8c49bff8d59f0eb59" args="(const sx_api_handle_t handle, const sx_router_id_t vrid, const sx_ip_prefix_t *network_addr_p, sx_flow_counter_id_t *counter_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_uc_route_counter_bind_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ip_prefix_t *&#160;</td>
          <td class="paramname"><em>network_addr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_flow_counter_id_t *&#160;</td>
          <td class="paramname"><em>counter_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the flow counter currently bound to a specified unicast route Notes: A flow counter may be bound to a route via a call to <a class="el" href="sx__api__router_8h.html#ada19ea02653d8cea4a46b48752f524a1">sx_api_router_uc_route_counter_bind_set()</a> If no counter if bound to the specified route, this function returns SUCCESS, and sets *counter_id_p to SX_FLOW_COUNTER_ID_INVALID Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">network_addr_p</td><td>- Network prefix of a unicast route </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter_id_p</td><td>- Returns the flow counter ID bound to the specified route</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if the specified route was not found. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a472c9bb573ce5a76a04f14cd53346b6f"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_counter_set" ref="a472c9bb573ce5a76a04f14cd53346b6f" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_router_counter_id_t *counter_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_counter_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_counter_id_t *&#160;</td>
          <td class="paramname"><em>counter_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function creates/destroys a router counter. A router counter should be bound later to a router interface. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE/DESTROY. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">counter_p</td><td>- Router counter ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no counter is available to create. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e73f38b6a51b7090c5c775c96689dfd"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_counter_extended_set" ref="a0e73f38b6a51b7090c5c775c96689dfd" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_counter_attributes_t cntr_attributes, sx_router_counter_id_t *counter_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_counter_extended_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_counter_attributes_t&#160;</td>
          <td class="paramname"><em>cntr_attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_counter_id_t *&#160;</td>
          <td class="paramname"><em>counter_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function creates/destroys a router counter by given type. A router counter should be bound later to a router interface. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE/DESTROY. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>- Router counter type. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">counter_p</td><td>- Router counter ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no counter is available to create. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a71f2d9f69205e6835bd4290703106121"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_interface_counter_bind_set" ref="a71f2d9f69205e6835bd4290703106121" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_counter_id_t counter, const sx_router_interface_t rif)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_counter_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_counter_id_t&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t&#160;</td>
          <td class="paramname"><em>rif</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function binds/unbinds a router counter to a router interface. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- BIND/UNBIND. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter</td><td>- Router counter ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rif</td><td>- Router Interface ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if counter was not added. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if interface is already bound. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="aa81e1f46c5501aee769e56e4fa4ebf23"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_interface_counter_bind_get" ref="aa81e1f46c5501aee769e56e4fa4ebf23" args="(const sx_api_handle_t handle, const sx_router_counter_id_t counter, sx_router_interface_t *rif_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_interface_counter_bind_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_counter_id_t&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_interface_t *&#160;</td>
          <td class="paramname"><em>rif_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets a router counter bind of a router interface. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter</td><td>- Router counter ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rif_p</td><td>- Router Interface ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if counter was not added. </dd>
<dd>
SX_STATUS_ENTRY_NOT_BOUND if counter was not bound. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4c18223f082f72efeb16ef6ab4545c6"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_counter_get" ref="ab4c18223f082f72efeb16ef6ab4545c6" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_counter_id_t counter, sx_router_counter_set_t *counter_set_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_counter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_counter_id_t&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_counter_set_t *&#160;</td>
          <td class="paramname"><em>counter_set_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets a router counter. When using cmd=READ_CLEAR, the counters will be returned and cleared. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ/READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter</td><td>- Router counter ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter_set_p</td><td>- Router counter set values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if counter was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b43b5655884e760afefdfd3f3910ea4"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_counter_extended_get" ref="a1b43b5655884e760afefdfd3f3910ea4" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_counter_id_t counter_id, sx_router_counter_set_extended_t *counter_data_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_counter_extended_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_counter_id_t&#160;</td>
          <td class="paramname"><em>counter_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_counter_set_extended_t *&#160;</td>
          <td class="paramname"><em>counter_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets a router counter by given type. When using cmd=READ_CLEAR, the counters will be returned and cleared. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ/READ_CLEAR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter</td><td>- Router counter ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter_data_p</td><td>- Router counter data values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if counter was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a1c3d7ede0cc2b4a383aacf414c9d84a3"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_counter_clear_set" ref="a1c3d7ede0cc2b4a383aacf414c9d84a3" args="(const sx_api_handle_t handle, const sx_router_counter_id_t counter, const boolean_t all)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_counter_clear_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_counter_id_t&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boolean_t&#160;</td>
          <td class="paramname"><em>all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function clears router counter set of a router counter. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter</td><td>- Router counter ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">all</td><td>- Clear all Router counters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if counter was not added. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a88d28b1cf1ea8606acaecf5c01c31051"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_mc_route_set" ref="a88d28b1cf1ea8606acaecf5c01c31051" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, const sx_mc_route_attributes_t *mc_route_attr_p, const sx_mc_route_data_t *mc_route_data_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_route_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_key_t *&#160;</td>
          <td class="paramname"><em>mc_route_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_attributes_t *&#160;</td>
          <td class="paramname"><em>mc_route_attr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_data_t *&#160;</td>
          <td class="paramname"><em>mc_route_data_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function adds/modifies/deletes a multicast route from the MC routing table.</p>
<p>In case action is not SX_ROUTER_ACTION_FORWARD/SX_ROUTER_ACTION_DROP, Trap ID will be set to SX_TRAP_ID_L3_MC_IP_BASE + trap priority.</p>
<p>In case mc_router_attr_p-&gt;rpf_action is SX_ROUTER_RPF_ACTION_TRAP, the caller should configure SX_TRAP_ID_ETH_L3_RPF trap first.</p>
<p>In case the RPF action is SX_ROUTER_RPF_ACTION_TRAP or SX_ROUTER_RPF_ACTION_DROP, the ingress RIF in the key should be the RPF RIF. In case the RPF action is SX_ROUTER_RPF_ACTION_DIRECTIONAL, a valid ingress RIF must be given. Multicast containers are valid on Spectrum only. egress_rif_cnt and egress_container_id are mutually exclusive and may not be both specified. e.g. if egress_rif_cnt is nonzero then egress_container_id must be SX_MC_CONTAINER_ID_INVALID. The DELETE_ALL command will delete all MC routes that match a given VRID and IP version specified by source_addr.version. If the given IP version is SX_IP_VERSION_NONE, then all MC routes on the given VRID will be deleted, regardless of the IP version. Assert is supported on SwitchX and SwitchX2 only. It is not applicable on Spectrum. On SwitchX, SwitchX2, and Spectrum, the valid manual priority range is 1 - 32. Router action SX_ROUTER_ACTION_SPAN is not supported on any device. in case RPF actions SX_ROUTER_RPF_ACTION_TRAP_LIST and SX_ROUTER_RPF_ACTION_DROP_LIST a valid RPF Group id must be given (that was previously created).</p>
<p>Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/EDIT/DELETE/DELETE_ALL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_route_key_p</td><td>- mc route entry key {source IP prefix, group mask, ingress RIF} </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_router_attr_p</td><td>- multicast route attributes (e.g. RPF mode, ttl, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_route_data_p</td><td>- route data (e.g. action, egress RIF list, etc.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no routes are available to create. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a24a37e74c648d6bd3de469df8cbd5b8c"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_mc_route_get" ref="a24a37e74c648d6bd3de469df8cbd5b8c" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, sx_mc_route_key_filter_t *filter_p, sx_mc_route_get_entry_t *mc_route_get_entries_list_p, uint32_t *mc_route_get_entries_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_route_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_key_t *&#160;</td>
          <td class="paramname"><em>mc_route_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_mc_route_key_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_mc_route_get_entry_t *&#160;</td>
          <td class="paramname"><em>mc_route_get_entries_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>mc_route_get_entries_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets a multicast route or routes from the MC routing table, based on a given key or criteria. The COUNT, GET_FIRST and GET_NEXT commands are supported only on Spectrum. For GET_FIRST and GET_NEXT, the value of mc_route_get_entries_cnt_p must be smaller or equal to SX_API_MC_ROUTE_GET_MAX_COUNT. The ingress RIF is only considered part of the key for routes that have RPF action SX_ROUTER_RPF_ACTION_DIRECTIONAL. Therefore, routes that were configured with any other RPF action, and with an ingress RIF other than the "don't care" RIF, will still be returned when filtering by the "don't care" ingress RIF. In these cases, the configured ingress RIF can be found in the MC route data.</p>
<p>Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET - Get multicast route entry from DB. COUNT - Get number of MC entries from the DB that match the criteria set by filter_p. GET_FIRST - Spectrum only. Get first MC route entries from DB. The maximum number of entries to be returned is defined by mc_route_get_entries_cnt_p. The criteria according to which entries will be returned is defined by filter_p. The last route returned will be in mc_route_key_p, and all routes returned will be in mc_route_get_entries_list_p. GET_NEXT - Spectrum only. Get next MC route entries from DB. The maximum number of entries to be returned is defined by mc_route_get_entries_cnt_p. The criteria according to which entries will be returned is defined by filter_p. The first entry returned will be the entry after that given in mc_route_key_p, which should have been received by a previous call to this API with GET_FIRST or GET_NEXT. The last route returned will be in mc_route_key_p, and all routes returned will be in mc_route_get_entries_list_p. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_route_key_p</td><td>- mc route entry key {Source IP Address, group address, ingress rif} </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_p</td><td>- filter according to which MC routes should be returned. Relevant only for GET_FIRST and GET_NEXT commands. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mc_route_get_entries_list_p</td><td>- list of returned MC routes </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mc_route_get_entries_cnt_p</td><td>- as input: number of entries in mc_route_get_entries_list_p as output: number of entries returned in mc_route_get_entries_list_p</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_NOT_FOUND if mc route is not found </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="ab70bf9ca856f55a88e7dd5a4fe5f77fa"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_mc_route_activity_get" ref="ab70bf9ca856f55a88e7dd5a4fe5f77fa" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, boolean_t *activity_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_route_activity_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_key_t *&#160;</td>
          <td class="paramname"><em>mc_route_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean_t *&#160;</td>
          <td class="paramname"><em>activity_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function reads and clears multicast route activity. Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_route_key_p</td><td>- mc route entry key {Source IP Address, group address, ingress rif} </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">activity_p</td><td>- Route activity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_NOT_FOUND if mc route is not found </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a209bcda3949dca1c76a5e18aa6705255"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_mc_route_activity_notify" ref="a209bcda3949dca1c76a5e18aa6705255" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_mc_route_activity_notify_filter_t *filter_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_route_activity_notify </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_activity_notify_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initiates a notification regarding active mc routes in the system. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_p</td><td>- activity notifier filter</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if parameter is invalid. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if a notification procedure is already running. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a49d704b1d7e401edc59dde5aff4bf376"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_mc_egress_rif_set" ref="a49d704b1d7e401edc59dde5aff4bf376" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, const sx_router_interface_t *egress_rif_list_p, const uint32_t egress_rif_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_egress_rif_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_key_t *&#160;</td>
          <td class="paramname"><em>mc_route_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_interface_t *&#160;</td>
          <td class="paramname"><em>egress_rif_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>egress_rif_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function adds/sets/deletes/deletes-all egress RIFs to/from a previously configured MC route. Only routes configured with egress_rif_cnt and egress_rif_list_p are supported by this function. Routes configured with egress_container_id are not.</p>
<p>Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- ADD/DELETE/DELETE_ALL/SET SET command replaces the entire list of existing egress RIFs with the given list. DELETE_ALL command deletes all egress router interfaces associated with multicast group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_route_key_p</td><td>- mc route entry key {Source IP Address, group address, ingress rif} </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">egress_rif_list_p</td><td>- Egress Router Interface array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">egress_rif_cnt</td><td>- Egress Router Interface array num.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no more RIFs can be set. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a530c3fdb5083d5c3a8f8e74ee348da69"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_mc_egress_rif_get" ref="a530c3fdb5083d5c3a8f8e74ee348da69" args="(const sx_api_handle_t handle, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, sx_router_interface_t *egress_rif_list_p, uint32_t *egress_rif_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_egress_rif_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_key_t *&#160;</td>
          <td class="paramname"><em>mc_route_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_interface_t *&#160;</td>
          <td class="paramname"><em>egress_rif_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>egress_rif_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the list of egress RIFs associated with the given multicast route. When egress_rif_num is 0 or egress_rif_arr == NULL, the function will return the number of egress RIFs, and egress_rif_arr will remain empty. Only routes configured with egress_rif_cnt and egress_rif_list_p are supported by this function. Routes configured with egress_container_id are not.</p>
<p>Supported devices: SwitchX, SwitchX2, Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_route_key_p</td><td>- mc route entry key {Source IP Address, group address, ingress rif} </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">egress_rif_list_p</td><td>- Egress Router Interface array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">egress_rif_cnt_p</td><td>- as input: number of entries in egress_rif_list_p as output: number of egress RIFs returned in egress_rif_list_p</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8dbefb60e445f59551a682a9177faa4"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_cos_rewrite_pcpdei_enable_set" ref="ad8dbefb60e445f59551a682a9177faa4" args="(const sx_api_handle_t handle, const sx_cos_pcp_dei_rewrite_e rewrite_pcp_dei)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_cos_rewrite_pcpdei_enable_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_cos_pcp_dei_rewrite_e&#160;</td>
          <td class="paramname"><em>rewrite_pcp_dei</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function enables in-router rewriting of PCP, DEI rewriting bits. The configuration is per IP router. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rewrite_pcp_dei</td><td>- enable the option to rewrite PCP and DEI fields at the egress port (preserve from the ingress, disable rewrite, enable rewrite).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a263b0c24b5930c791a6691a473934ee8"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_cos_rewrite_pcpdei_enable_get" ref="a263b0c24b5930c791a6691a473934ee8" args="(const sx_api_handle_t handle, sx_cos_pcp_dei_rewrite_e *rewrite_pcp_dei_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_cos_rewrite_pcpdei_enable_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_cos_pcp_dei_rewrite_e *&#160;</td>
          <td class="paramname"><em>rewrite_pcp_dei_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves in-router rewriting of PCP, DEI rewriting bits. The configuration is per IP router. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rewrite_pcp_dei</td><td>- enable the option to rewrite PCP and DEI fields at the egress port (preserve from the ingress, disable rewrite, enable rewrite).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a8d98abb2561504116bda54e5e7a1647c"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_cos_prio_update_enable_set" ref="a8d98abb2561504116bda54e5e7a1647c" args="(const sx_api_handle_t handle, const boolean_t update_priority_color)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_cos_prio_update_enable_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boolean_t&#160;</td>
          <td class="paramname"><em>update_priority_color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function enables in-router updating of switch-priority and color. The updated mapping is defined using sx_api_router_cos_dscp_to_prio_set. The configuration is per IP router. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update_priority_color</td><td>- enable updates the switch priority and color by the DSCP map described in sx_api_router_cos_dscp_to_prio_set</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="aa1bd7e45636b6128e1add0ad579b2f86"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_cos_prio_update_enable_get" ref="aa1bd7e45636b6128e1add0ad579b2f86" args="(const sx_api_handle_t handle, boolean_t *update_priority_color_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_cos_prio_update_enable_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean_t *&#160;</td>
          <td class="paramname"><em>update_priority_color_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves in-router updating of switch-priority and color. The updated mapping is defined using sx_api_router_cos_dscp_to_prio_set. The configuration is per IP router. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">update_priority_color_p</td><td>- enable updates the switch priority and color by the DSCP map described in sx_api_router_cos_dscp_to_prio_set</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a3601a683f22a7e13bc89b3f80a4a3c0e"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_cos_dscp_to_prio_set" ref="a3601a683f22a7e13bc89b3f80a4a3c0e" args="(const sx_api_handle_t handle, const sx_cos_dscp_t *dscp_p, const sx_cos_priority_color_t *priority_color_p, const uint32_t element_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_cos_dscp_to_prio_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_cos_dscp_t *&#160;</td>
          <td class="paramname"><em>dscp_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_cos_priority_color_t *&#160;</td>
          <td class="paramname"><em>priority_color_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>element_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the mapping from DSCP to switch-priority and color for in-router rewrite. Supported devices: Spectrum. The mapping is used only if enabled in sx_api_router_cos_prio_update_enable_set.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dscp</td><td>- a list of DSCP's </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">switch_priority_color</td><td>- a list of switch priorities and color </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element_cnt</td><td>- num of elements in switch priorities and DSCP's lists</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd></dl>

</div>
</div>
<a class="anchor" id="a3dffe9f627debece49b7ed508c12bf0b"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_cos_dscp_to_prio_get" ref="a3dffe9f627debece49b7ed508c12bf0b" args="(const sx_api_handle_t handle, sx_cos_dscp_t *dscp_p, sx_cos_priority_color_t *priority_color_p, uint32_t *element_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_cos_dscp_to_prio_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_cos_dscp_t *&#160;</td>
          <td class="paramname"><em>dscp_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_cos_priority_color_t *&#160;</td>
          <td class="paramname"><em>priority_color_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>element_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves the mapping from DSCP to switch-priority and color for in-router rewrite. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dscp</td><td>- a list of DSCP's </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">switch_priority_color_p</td><td>- a list of switch priorities and color </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element_cnt_p</td><td>- num of elements in switch priorities and DSCP's lists</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully </dd>
<dd>
SX_STATUS_PARAM_ERROR if an input parameter is invalid </dd>
<dd>
SX_STATUS_ERROR for a general error </dd>
<dd>
SX_STATUS_PARAM_NULL if parameter is NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="abd1c22691400cdcd80424831ff6bc942"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_ecmp_set" ref="abd1c22691400cdcd80424831ff6bc942" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_ecmp_id_t *ecmp_id_p, sx_next_hop_t *next_hop_list_p, uint32_t *next_hop_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_ecmp_id_t *&#160;</td>
          <td class="paramname"><em>ecmp_id_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_next_hop_t *&#160;</td>
          <td class="paramname"><em>next_hop_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>next_hop_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function creates/modifies/destroys an ECMP container, according to cmd.</p>
<p>SX_ACCESS_CMD_CREATE - by providing a next hops list, the command creates an EMCP container. Container content is formed as a subset of the resolved next hops. Returned Next hops weights are adjusted to the proper weights as written on HW. This command returns the containers next hops as written on HW, list count and new container ID. SX_ACCESS_CMD_SET - Modifies the contents of an existing ECMP container, specified by *ecmp_id_p. If *next_hop_cnt_p is zero, empties the container. SX_ACCESS_CMD_DESTROY - by providing a container ID, the command removes all next hops from the existing given container, destroying the container as well. The container ID is invalid until reassigned on container creation. This command returns list count 0 Weights will be modified on runtime according to next hops resolution changes. Supported devices: Spectrum. Setting a container in use by UC route(s), is allowed only with next hops on the same VRID. Clearing(set with an empty next hops list), is not allowed in case container is in use by UC route(s).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- action to perform: CREATE, DESTROY, SET, </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ecmp_id</td><td>- id of ECMP container </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">next_hop_list_p</td><td>- a given list of next hops </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">next_hop_cnt_p</td><td>- amount of next hops</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if parameter is NULL or exceeds range. </dd>
<dd>
SX_STATUS_UNSUPPORTED if invalid cmd. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no space for ECMP container allocation. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if trying to destroy ECMP an container in use. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ecmp_id not found. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c569920c238a3289dc3877a5c10783e"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_ecmp_get" ref="a7c569920c238a3289dc3877a5c10783e" args="(const sx_api_handle_t handle, const sx_ecmp_id_t ecmp_id, sx_next_hop_t *next_hop_list_p, uint32_t *next_hop_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ecmp_id_t&#160;</td>
          <td class="paramname"><em>ecmp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_next_hop_t *&#160;</td>
          <td class="paramname"><em>next_hop_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>next_hop_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves an ECMP container content, as defined by the user. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ecmp_id</td><td>- id of an ECMP container </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">next_hop_list_p</td><td>- a given list of next hops </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">next_hop_cnt_p</td><td>- amount of next hops</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if parameter is NULL or exceeds range. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ecmp_id not found. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a866dedd655aa7313be54227fe54ec57e"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_ecmp_iter_get" ref="a866dedd655aa7313be54227fe54ec57e" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_ecmp_id_t ecmp_id, const sx_ecmp_filter_t *filter_p, sx_ecmp_id_t *ecmp_list_p, uint32_t *ecmp_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_iter_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ecmp_id_t&#160;</td>
          <td class="paramname"><em>ecmp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ecmp_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_ecmp_id_t *&#160;</td>
          <td class="paramname"><em>ecmp_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ecmp_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns a list of one or more ECMP container identifiers. The following use case scenarios apply with different input parameters X = don't-care</p>
<ul>
<li>1) cmd = SX_ACCESS_CMD_GET, ecmp_id = X, ecmp_list = X, ecmp_cnt = 0: In this case the API will return the total number of ECMP containers in the Internal db.</li>
</ul>
<ul>
<li>2) cmd = SX_ACCESS_CMD_GET, ecmp_id = valid/invalid, ecmp_list = valid, ecmp_cnt = 1: In this case the API will check if the specified ECMP container ID exists. If it does, the ECMP container ID will be returned in the ecmp_list along with a ecmp_cnt of 1. If the key does not exist, an empty list will be returned with ecmp_cnt = 0. A non-NULL ecmp_list pointer must be provided in this case.</li>
</ul>
<ul>
<li>3) cmd = SX_ACCESS_CMD_GET, ecmp_id = valid/invalid, ecmp_list = valid, ecmp_cnt &gt; 1: An ecmp_cnt &gt; 1 will be treated as a ecmp_cnt of 1 and the behavior will be same as the earlier GET use cases.</li>
</ul>
<ul>
<li>4) cmd = SX_ACCESS_CMD_GET_FIRST/SX_ACCESS_CMD_GETNEXT, ecmp_id = X ecmp_list = NULL, ecmp_cnt = 0: A zero ecmp_cnt and an empty ecmp_list will be returned.</li>
</ul>
<ul>
<li>5) cmd = SX_ACCESS_CMD_GET_FIRST, ecmp_id = X, ecmp_list = valid, ecmp_cnt &gt; 0: In this case the API will return the first ecmp_cnt ECMP container IDs starting from the head of the database. The total number of elements fetched will be returned as ecmp_cnt. Note: returned ecmp_cnt may be less than or equal to the requested ecmp_cnt. The key is ignored in this case. A non-NULL ecmp_list pointer must be provided in this case.</li>
</ul>
<ul>
<li>6) cmd = SX_ACCESS_CMD_GETNEXT, ecmp_id = valid/invalid, ecmp_list = valid, ecmp_cnt &gt; 0: In this case the API will return the next set of ECMP container IDs starting from the next valid ECMP container ID after the specified ECMP container ID. The total number of elements fetched will be returned as the ecmp_cnt. Note: returned ecmp_cnt may be less than or equal to the requested ecmp_cnt. If no valid next ECMP container ID exists in the db, an empty list will be returned. A non-NULL ecmp_list pointer must be provided in this case.</li>
</ul>
<p>Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>: SX API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>: GET/GET_FIRST/GET_NEXT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ecmp_id</td><td>: specify an ECMP container ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>: specify a filter parameter (not supported yet) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ecmp_list_p</td><td>: return list of ECMP container IDs </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ecmp_cnt_p</td><td>: [in] number of ECMP container IDs to get : [out] number of ECMP container IDs returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_EXCEEDS_RANGE if parameters exceed range. </dd>
<dd>
SX_STATUS_PARAM_NULL if an unexpected NULL parameter was passed. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ERROR general error. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED - if invalid cmd is passed </dd>
<dd>
SX_STATUS_MODULE_UNINITIALIZED - if router module is uninitialized </dd>
<dd>
SX_STATUS_CMD_ERROR - if internal RPC mechanism to SDK server fails </dd>
<dd>
SX_STATUS_DB_NOT_INITIALIZED - if internal ECMP DB is not initialized </dd></dl>

</div>
</div>
<a class="anchor" id="a44c2973c659f035cbde4f0a519b1082b"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_operational_ecmp_get" ref="a44c2973c659f035cbde4f0a519b1082b" args="(const sx_api_handle_t handle, const sx_ecmp_id_t ecmp_id, sx_next_hop_t *next_hop_list_p, uint32_t *next_hop_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_operational_ecmp_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ecmp_id_t&#160;</td>
          <td class="paramname"><em>ecmp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_next_hop_t *&#160;</td>
          <td class="paramname"><em>next_hop_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>next_hop_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves the EMCP container content, as written on HW(only resolved next hops). Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ecmp_id</td><td>- id of an ECMP container </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">next_hop_list_p</td><td>- a given list of next hops </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">next_hop_cnt_p</td><td>- amount of next hops</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if parameter is NULL or exceeds range. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ecmp_id not found. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a2aa9c0bda0299d13e275a267c1249fb8"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_ecmp_counter_bind_set" ref="a2aa9c0bda0299d13e275a267c1249fb8" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_ecmp_id_t ecmp_id, const sx_flow_counter_id_t *counter_id_list_p, const uint32_t *offset_list_p, const uint32_t elements_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_counter_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ecmp_id_t&#160;</td>
          <td class="paramname"><em>ecmp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_flow_counter_id_t *&#160;</td>
          <td class="paramname"><em>counter_id_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>offset_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>elements_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function binds/unbinds a router counter to a list of next hops for a given container. In case of INVALID_NEXT_HOP_OFFSET counter will be bound to all next hops in given ECMP container. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- BIND/UNBIND. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ecmp_id</td><td>- id of an ECMP container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_id_list_p</td><td>- list of counter IDs to bind to matching offsets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset_list_p</td><td>- list of next hop entries offset in configured next hops list to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elements_cnt</td><td>- amount of next hops offsets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if counter was not added. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if interface is already bound. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a2fa0de25ef37a9cef1652e920c5fc019"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_ecmp_fine_grain_counter_bind_set" ref="a2fa0de25ef37a9cef1652e920c5fc019" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_ecmp_id_t ecmp_id, const sx_flow_counter_id_t counter_id, const uint32_t *offset_list_p, const uint32_t elements_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_fine_grain_counter_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ecmp_id_t&#160;</td>
          <td class="paramname"><em>ecmp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_flow_counter_id_t&#160;</td>
          <td class="paramname"><em>counter_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>offset_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>elements_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function binds/unbinds a router counter to a list of indices in a container active set. This API should be used for containers that are not static containers. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- BIND/UNBIND. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ecmp_id</td><td>- ID of a non static ECMP container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_id</td><td>- ID of a counter to bind to the given offsets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset_list_p</td><td>- list of entry offsets in configured ECMP container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elements_cnt</td><td>- amount of entry offsets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if counter was not added. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if interface is already bound. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a823465cf10115d18b458c33a678cfccf"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_neigh_activity_notify" ref="a823465cf10115d18b458c33a678cfccf" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_neigh_activity_filter_t *filter_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_neigh_activity_notify </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_neigh_activity_filter_t *&#160;</td>
          <td class="paramname"><em>filter_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initiates a notification regarding active neighbors in the system. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- READ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_p</td><td>- neigh activity notifier filter</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if parameter is invalid. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if a notification procedure is already running. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a242f69b150debcf00867d67f8515e8a6"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_ecmp_attributes_set" ref="a242f69b150debcf00867d67f8515e8a6" args="(const sx_api_handle_t handle, const sx_ecmp_id_t ecmp_id, const sx_ecmp_attributes_t *attr_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_attributes_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ecmp_id_t&#160;</td>
          <td class="paramname"><em>ecmp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ecmp_attributes_t *&#160;</td>
          <td class="paramname"><em>attr_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets an ECMP container's attributes. Using this API is not mandatory for ECMP hashing (default value is SX_ECMP_TYPE_STATIC_E) To use this API one should create an empty ECMP container, set the container attributes and add next hops. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ecmp_id</td><td>- an ID of an ECMP container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attr_p</td><td>- ECMP container attributes</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_ERROR general error </dd>
<dd>
SX_STATUS_PARAM_ERROR if parameter is NULL or exceeds range. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ecmp_id not found. </dd></dl>

</div>
</div>
<a class="anchor" id="afa58f3a820da481643de557c94a401ea"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_ecmp_attributes_get" ref="afa58f3a820da481643de557c94a401ea" args="(const sx_api_handle_t handle, const sx_ecmp_id_t ecmp_id, sx_ecmp_attributes_t *attr_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_attributes_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ecmp_id_t&#160;</td>
          <td class="paramname"><em>ecmp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_ecmp_attributes_t *&#160;</td>
          <td class="paramname"><em>attr_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves an ECMP container's attributes. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ecmp_id</td><td>- id of ECMP container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">attr_p</td><td>- ECMP container attributes</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_ERROR general error </dd>
<dd>
SX_STATUS_PARAM_ERROR if parameter is NULL or exceeds range. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ecmp_id not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a1936f4c977dfe4c92e31af4ba9390845"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_ecmp_clone_set" ref="a1936f4c977dfe4c92e31af4ba9390845" args="(const sx_api_handle_t handle, const sx_ecmp_id_t old_ecmp_id, sx_ecmp_id_t *new_ecmp_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_ecmp_clone_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_ecmp_id_t&#160;</td>
          <td class="paramname"><em>old_ecmp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_ecmp_id_t *&#160;</td>
          <td class="paramname"><em>new_ecmp_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function clone an ECMP container. Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_ecmp_id</td><td>- Old ID of ECMP container </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_ecmp_id_p</td><td>- New ID of ECMP container pointer return with pointer that contains the new created container ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if parameter is NULL or exceeds range. </dd>
<dd>
SX_STATUS_NO_RESOURCES if no space for ECMP container allocation. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if ecmp_id not found. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="aa529787aa5b258a80c567f751dbfe2ee"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_mc_rpf_group_set" ref="aa529787aa5b258a80c567f751dbfe2ee" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_rpf_group_id_t *rpf_group_id_p, sx_router_vinterface_t *rpf_vif_list_p, uint32_t rpf_vif_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_rpf_group_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_rpf_group_id_t *&#160;</td>
          <td class="paramname"><em>rpf_group_id_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_vinterface_t *&#160;</td>
          <td class="paramname"><em>rpf_vif_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rpf_vif_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API is not supported. Manipulate a multicast router Reverse-Path Forwarding group Command CREATE creates a new RPF group which contains the specified list of ingress RIFs in rpf_rif_list_p, and returns its new group ID in rpf_group_id_p. Command SET replaces the contents of an existing RPF group specified by rpf_group_id_p, with the specified list of ingress RIFs in rpf_rif_list_p. Command DESTROY deletes the existing RPF group specified by rpf_group_id_p Command DELETE_ALL deletes all existing RPF groups. Notes: An RPF group in use by a multicast route cannot be destroyed An RPF group may contain only ingress RIFs which belong to the same virtual router An RPF group must contain at least one ingress RIF</p>
<p>Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- CREATE/SET/DESTROY/DELETE_ALL. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rpf_group_id_p</td><td>- Specifies or returns the group ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rpf_rif_list_p</td><td>- Specifies the list of ingress RIFs in a group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rpf_rif_cnt</td><td>- Specifies the amount of ingress RIFs in rpf_rif_list_p</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if specified group ID does not exist. </dd>
<dd>
SX_STATUS_NO_RESOURCES if there are no resources for the operation. </dd>
<dd>
SX_STATUS_RESOURCE_IN_USE if group is in use and cannot be destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="ae922af870268cc2ccf178169027ac093"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_mc_rpf_group_get" ref="ae922af870268cc2ccf178169027ac093" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, sx_rpf_group_id_t *rpf_group_id_p, sx_router_vinterface_t *rpf_vif_list_p, uint32_t *rpf_vif_cnt_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_rpf_group_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_rpf_group_id_t *&#160;</td>
          <td class="paramname"><em>rpf_group_id_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_router_vinterface_t *&#160;</td>
          <td class="paramname"><em>rpf_vif_list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rpf_vif_cnt_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve information about a multicast router Reverse-Path Forwarding group Command GET retrieves information about an RPF group specified by rpf_group_id_p Command GETFIRST retrieves the first existing RPF group, its ID and contents Command GETNEXT retrieves the next existing RPF group, its ID and contents Notes: In order to enumerate all existing RPF groups, a client application may call GETFIRST once, and then repeatedly call GETNEXT until all groups are retrieved If *rpf_rif_cnt_p is 0, then rpf_rif_list_p may be NULL, and only the amount of RIFs is returned without the list of RIFs</p>
<p>Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- GET/GETFIRST/GETNEXT </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rpf_group_id_p</td><td>- Specifies a previous group ID or returns a group ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rpf_rif_list_p</td><td>- Returns a list of ingress RIFs in the group </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rpf_rif_cnt</td><td>- Specifies the size of rpf_rif_list_p, and returns the amount of ingress RIFs in rpf_rif_list_p</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if specified group ID does not exist, or no more groups. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a4327a03b23e683f531b359fa569ecf"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_mc_route_counter_bind_set" ref="a6a4327a03b23e683f531b359fa569ecf" args="(const sx_api_handle_t handle, const sx_access_cmd_t cmd, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, const sx_flow_counter_id_t counter_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_route_counter_bind_set </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_access_cmd_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_key_t *&#160;</td>
          <td class="paramname"><em>mc_route_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_flow_counter_id_t&#160;</td>
          <td class="paramname"><em>counter_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Binds or un-binds a flow counter to an existing multicast route Note: A route may be created via a call to <a class="el" href="sx__api__router_8h.html#a88d28b1cf1ea8606acaecf5c01c31051">sx_api_router_mc_route_set()</a> A flow counter may be created via a call to <a class="el" href="sx__api__flow__counter_8h.html#a9d043e95b58d1d326128c643c0952802">sx_api_flow_counter_set()</a> Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>- BIND/UNBIND </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_route_key_p</td><td>- MC route key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_id</td><td>- A flow counter identifier. Applicable only for command BIND</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_CMD_UNSUPPORTED if access command isn't supported. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_PARAM_NULL if any input parameter is null. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if the specified route or flow counter was not found. </dd>
<dd>
SX_STATUS_ENTRY_ALREADY_BOUND if mc route already bounded. </dd>
<dd>
SX_STATUS_ENTRY_NOT_BOUND if counter was not bound. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a450a42c80363d8802247f85c77fae63d"></a><!-- doxytag: member="sx_api_router.h::sx_api_router_mc_route_counter_bind_get" ref="a450a42c80363d8802247f85c77fae63d" args="(const sx_api_handle_t handle, const sx_router_id_t vrid, const sx_mc_route_key_t *mc_route_key_p, sx_flow_counter_id_t *counter_id_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sx_status_t sx_api_router_mc_route_counter_bind_get </td>
          <td>(</td>
          <td class="paramtype">const sx_api_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_router_id_t&#160;</td>
          <td class="paramname"><em>vrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx_mc_route_key_t *&#160;</td>
          <td class="paramname"><em>mc_route_key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sx_flow_counter_id_t *&#160;</td>
          <td class="paramname"><em>counter_id_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the flow counter currently bound to a specified multicast route Notes: A flow counter may be bound to a route via a call to <a class="el" href="sx__api__router_8h.html#a6a4327a03b23e683f531b359fa569ecf">sx_api_router_mc_route_counter_bind_set()</a> If no counter if bound to the specified route, this function returns SUCCESS, and sets *counter_id_p to SX_FLOW_COUNTER_ID_INVALID Supported devices: Spectrum.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- SX-API handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrid</td><td>- Virtual Router ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mc_route_key_p</td><td>- MC route key </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter_id_p</td><td>- Returns the flow counter ID bound to the specified route</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SX_STATUS_SUCCESS if operation completes successfully. </dd>
<dd>
SX_STATUS_PARAM_ERROR if any input parameter is invalid. </dd>
<dd>
SX_STATUS_PARAM_NULL if any input parameter is null. </dd>
<dd>
SX_STATUS_ENTRY_NOT_FOUND if the specified route was not found. </dd>
<dd>
SX_STATUS_ERROR general error. </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head></head>
<body>
<hr class="footer">
<address class="footer"><small>Generated on Fri Jan 26 2018 10:07:25 by Mellanox Technologies LTD <a href="http://www.mellanox.com" target="_blank"> <img src="Mellanoxlogo.gif" alt="Mellanox" border="0" height="41" width="51"></a></small></address>

</body></html>
